<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
  <title>Table of Contents &mdash; Vitis™ Tutorials 2021.1 documentation</title>
      <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../../../../../index.html" class="icon icon-home"> Vitis™ Tutorials
            <img src="../../../../../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2021.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">日本語版</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/master/docs-jp/index.html">Master</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Getting_Started/Vitis-Getting-Started.html">Getting Started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Acceleration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Hardware_Acceleration/Hardware-Acceleration.html">Hardware Acceleration</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">AI Engine</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../AI_Engine_Development.html">AI Engine Development</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Platforms</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Vitis_Platform_Creation/Vitis_Platform_Creation.html">Vitis Platform Creation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-2/docs/index.html">2020.2</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-1/docs/README.html">2020.1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">Vitis™ Tutorials</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Table of Contents</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../_sources/docs/AI_Engine_Development/Design_Tutorials/07-firFilter_AIEvsHLS/HLS/README.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <table>
 <tr>
   <td align="center"><img src="https://raw.githubusercontent.com/Xilinx/Image-Collateral/main/xilinx-logo.png" width="30%"/><h1>2021.1 Versal AI Engine/HLS FIR Filter Tutorial (HLS Implementation)</h1>
   </td>
 </tr>
</table><section id="table-of-contents">
<h1>Table of Contents<a class="headerlink" href="#table-of-contents" title="Permalink to this heading">¶</a></h1>
<p><a class="reference external" href="#building-the-design">Building the Design</a></p>
<p><a class="reference external" href="#hardware-design-details">Hardware Design Details</a></p>
<p><a class="reference external" href="#software-design-details">Software Design Details</a></p>
<p><a class="reference external" href="#references">References</a></p>
<p><a class="reference external" href="#revision-history">Revision History</a></p>
</section>
<section id="building-the-design">
<h1>Building the Design<a class="headerlink" href="#building-the-design" title="Permalink to this heading">¶</a></h1>
<details>
<summary>Design Build</summary><section id="design-build">
<h2>Design Build<a class="headerlink" href="#design-build" title="Permalink to this heading">¶</a></h2>
<p>In this section, you will build and run the FIR filter design using the DSP implementation. The difference between this implementation and the AI Engine implementation, where users compile the AI Engine design and integrate it into a larger system design (including the programmable logic (PL) kernels and processing system (PS) host application), is that the FIR filter is now implemented in PL using DSP Engines.</p>
<p>At the end of this section, the design flow will generate a new directory (called <code class="docutils literal notranslate"><span class="pre">build/</span></code>). Underneath are sub-directories named <code class="docutils literal notranslate"><span class="pre">fir_dsp_$(N_FIR_FILTERS)firs_$(N_FIR_TAPS)taps</span></code> (for example, fir_dsp_1firs_15taps) depending on value of <code class="docutils literal notranslate"><span class="pre">N_FIR_FILTERS</span></code> and <code class="docutils literal notranslate"><span class="pre">N_FIR_TAPS</span></code> chosen in the build. Each sub-directory contains the <code class="docutils literal notranslate"><span class="pre">hw_emu/</span></code> and <code class="docutils literal notranslate"><span class="pre">hw/</span></code> subfolders. The <code class="docutils literal notranslate"><span class="pre">hw_emu/</span></code> subfolder contains the build for hardware emulation. The <code class="docutils literal notranslate"><span class="pre">hw/</span></code> subfolder contains the build for the hardware run on a VCK190 board.</p>
</details><details>
<summary>Make Steps</summary></section>
<section id="make-steps">
<h2>Make Steps<a class="headerlink" href="#make-steps" title="Permalink to this heading">¶</a></h2>
<p>To run the following <code class="docutils literal notranslate"><span class="pre">make</span></code> steps (e.g. <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">kernels</span></code>, <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">graph</span></code>, etc), you must be in the <code class="docutils literal notranslate"><span class="pre">Makefiles/</span></code> folder.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> Makefiles
</pre></div>
</div>
<p>The following options can be specified in the make steps. See the make steps for instructions how to apply them.</p>
<ul class="simple">
<li><p>TARGET: it can be set to “hw” or “hw_emu” to build the design in hardware or hardware emulation flow. Default is “hw_emu”.</p></li>
<li><p>N_FIR_FILTERS: specifies the number of FIR filters in the chain. Default is 1.</p></li>
<li><p>N_FIR_TAPS: specifies the number of FIR filter taps. Default is 15.</p></li>
<li><p>EN_TRACE: Flag to enable trace data to be captured. 0 is disabled and 1 is enabled. Default is 0.</p></li>
</ul>
</details><details>
<summary>Build the Entire Design with a Single Command</summary></section>
<section id="build-the-entire-design-with-a-single-command">
<h2>Build the Entire Design with a Single Command<a class="headerlink" href="#build-the-entire-design-with-a-single-command" title="Permalink to this heading">¶</a></h2>
<p>If you are already familiar with the AI Engine and Vitis™ accelerated kernel compilation flows, you can build the entire design with one command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make run <span class="o">(</span>default hardware emulation, <span class="m">1</span> filter <span class="m">15</span> taps, no trace enabled<span class="o">)</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make run <span class="nv">TARGET</span><span class="o">=</span>hw <span class="nv">N_FIR_FILTERS</span><span class="o">=</span><span class="m">5</span> <span class="nv">N_FIR_TAPS</span><span class="o">=</span><span class="m">15</span> <span class="nv">EN_TRACE</span><span class="o">=</span><span class="m">1</span>   <span class="o">(</span>hardware, <span class="m">5</span> FIR filters, each with <span class="m">15</span> taps, <span class="nb">enable</span> tracing<span class="o">)</span>
</pre></div>
</div>
<p>This command will run the <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">kernels</span></code>,<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">xclbin</span></code>,<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">application</span></code>,<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">package</span></code> and <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">run_emu</span></code> for hardware emulation or to run on hardware (VCK190 board) depending on the <code class="docutils literal notranslate"><span class="pre">TARGET</span></code> you specify. The default <code class="docutils literal notranslate"><span class="pre">TARGET</span></code> without specification is hw_emu. The settings also apply to the following individual make steps.</p>
<p>Note: Simulation takes considerably longer to execute the application than when running on actual hardware, so it is recommended to simulate with a smaller data set to have it complete in a reasonable time. The hardware implementation uses a much larger data set to reduce measurement effects.
In the file <code class="docutils literal notranslate"><span class="pre">\&lt;project&gt;/DSP/design/app_src/fir_dsp_app.c</span></code>, un-comment the following, as appropriate:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define REPEAT_OFFSET   4096</span>
<span class="c1">#define REPETITIONS      509     &lt;-- use this for TARGET=hw;     will produce a 2M sample data set</span>
<span class="o">//</span><span class="c1">#define REPETITIONS        3   &lt;-- use this for TARGET=hw_emu; will produce an 8K sample data set</span>
<span class="c1">#define FLUSH_SAMPLES   4096</span>
</pre></div>
</div>
<p><strong>Note</strong></p>
<ol class="simple">
<li><p>The generated files for a particular build are placed under individual directory: build/fir_dsp_$(N_FIR_FILTERS)firs_$(N_FIR_TAPS)taps</p></li>
<li><p>See the specification in each make step for options used and location of input and output files.</p></li>
</ol>
</details><p>The individual make steps to build the design with the options that applied to them are specified as follows.</p>
<details>
<summary>make kernels: Compile PL Kernels</summary></section>
<section id="make-kernels-compile-pl-kernels">
<h2>make kernels: Compile PL Kernels<a class="headerlink" href="#make-kernels-compile-pl-kernels" title="Permalink to this heading">¶</a></h2>
<p>In this step, the Vitis compiler takes any kernels (RTL or HLS C) in the PL region of the target platform (<code class="docutils literal notranslate"><span class="pre">xilinx_vck190_base_202110_1</span></code>) and compiles them into their respective XO files.</p>
<p>The following commands compiles the kernels (default TARGET=hw_emu, N_FIR_FILTERS=1, N_FIR_TAPS=15, EN_TRACE=0):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">kernels</span>
</pre></div>
</div>
<p>The expanded command is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>mkdir -p ../build/fir_dsp_$(N_FIR_FILTERS)firs_$(N_FIR_TAPS)taps/hw_emu

cd ../build/fir_dsp_$(N_FIR_FILTERS)firs_$(N_FIR_TAPS)taps/hw_emu

v++ 	--target hw_emu					\
        --hls.pre_tcl ./directives/hls_pre.tcl		\
	--hls.clock 300000000:s2mm 			\
	--platform xilinx_vck190_base_202110_1		\
	--include ../../../design/pl_src 		\
	--save-temps 					\
	--temp_dir _x 					\
	--verbose 					\
	-g -c 						\
	-k fir_dsp 					\
	../../../design/pl_src/fir_dsp.cpp 		\
	-o fir_dsp.hw_emu.xo   

v++ 	--target hw_emu					\
	--hls.clock 300000000:s2mm 			\
	--platform xilinx_vck190_base_202110_1		\
	--save-temps 					\
	--temp_dir _x 					\
	--verbose 					\
	-g -c 						\
	-k s2mm 					\
	../../../design/pl_src/s2mm.cpp 		\
	-o s2mm.hw_emu.xo   

v++ 	--target hw_emu					\
	--hls.clock 300000000:mm2s 			\
	--platform xilinx_vck190_base_202110_1		\
	--save-temps 					\
	--temp_dir _x 					\
	--verbose 					\
	-g -c 						\
	-k mm2s 					\
	../../../design/pl_src/mm2s.cpp 		\
	-o mm2s.hw_emu.xo   
</pre></div>
</div>
<p>Summary of the switches used:
|Switch|Description|
|  —  |  —  |
|–target | -t [hw|hw_emu]|Specifies the build target.|
|–hls.clock | Specifies a frequency in Hz at which the listed kernel(s) should be compiled by Vitis HLS. |
|–platform | -f|Specifies the name of a supported acceleration platform as specified by the $PLATFORM_REPO_PATHS environment variable or the full path to the platform XPFM file.|
|–save-temps | -s|Directs the Vitis compiler command to save intermediate files/directories created during the compilation and link process. Use the <code class="docutils literal notranslate"><span class="pre">--temp_dir</span></code> option to specify a location to write the intermediate files to.|
|–temp_dir <string>|This allows you to manage the location where the tool writes temporary files created during the build process. The temporary results are written by the Vitis compiler, and then removed, unless the <code class="docutils literal notranslate"><span class="pre">--save-temps</span></code> option is also specified.|
|–verbose|Display verbose/debug information.|
| -g | Generates code for debugging the kernel during software emulation. Using this option adds features to facilitate debugging the kernel as it is compiled. |
|–compile | -c|Required for compilation to generate XO files from kernel source files.|
|–kernel &lt;arg&gt;|-k &lt;arg&gt;|Compile only the specified kernel from the input file. Only one -k option is allowed per Vitis compiler command.|
|–output | -o|Specifies the name of the output file generated by the V++ command. The compilation process output name must end with the XO file suffix.|</p>
<p><a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/vitiscommandcompiler.html#wrj1504034328013">Detailed Desicription of All Vitis Compiler Switches</a></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Input</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>fir_dsp.cpp</td>
<td>The FIR filter chain PL kernel source code.</td>
</tr>
<tr>
<td>s2mm.cpp</td>
<td>The stream-to-memory-mapped data-mover PL kernel source code.</td>
</tr>
<tr>
<td>mm2s.cpp</td>
<td>The memory-mapped-to-stream data-mover PL kernel source code.</td>
</tr>
</tbody>
</table><table border="1" class="docutils">
<thead>
<tr>
<th>Output</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>fir_dsp.hw_emu.xo</td>
<td>The FIR filter chain PL kernel object file.</td>
</tr>
<tr>
<td>s2mm.hw_emu.xo</td>
<td>The stream-to-memory-mapped data-mover kernel object file.</td>
</tr>
<tr>
<td>mm2s.hw_emu.xo</td>
<td>The memory-mapped-to-stream data-mover kernel object file.</td>
</tr>
</tbody>
</table></details><details>
<summary>make xclbin: Use Vitis Tools to Link HLS Kernels with the Platform</summary></section>
<section id="make-xclbin-use-vitis-tools-to-link-hls-kernels-with-the-platform">
<h2>make xclbin: Use Vitis Tools to Link HLS Kernels with the Platform<a class="headerlink" href="#make-xclbin-use-vitis-tools-to-link-hls-kernels-with-the-platform" title="Permalink to this heading">¶</a></h2>
<p>After the PL HLS kernels have been compiled, you can use the Vitis compiler to link them with the platform to generate an XCLBIN file.</p>
<p>The Vitis tools allow you to integrate the HLS kernels into an existing extensible platform. This is an automated step from a software developer perspective where the platform chosen is provided by the hardware designer (or you can opt to use one of the many extensible base platforms provided by Xilinx and the Vitis tools build the hardware design and integrate the PL kernels into the design).</p>
<p>To test this feature in this tutorial, use the base VCK190 platform to build the design.</p>
<p>The command to run this step is shown as follows (default TARGET=hw_emu, N_FIR_FILTERS=1, N_FIR_TAPS=15, EN_TRACE=0):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">xclbin</span>
</pre></div>
</div>
<p>The expanded command is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cd ../build/fir_dsp_$(N_FIR_FILTERS)firs_$(N_FIR_TAPS)taps/hw_emu

v++ 	-l 						\
	--platform xilinx_vck190_base_202110_1 		\
	--include ../../../design/pl_src 		\
	--save-temps 					\
	--temp_dir _x 					\
	--verbose 					\
	-g 						\
	--clock.defaultTolerance 0.001 			\
	--clock.freqHz 300000000:mm2s_0 		\
	--clock.freqHz 300000000:s2mm_0 		\
	--clock.freqHz 300000000:fir_dsp_0 		\
	--vivado.synth.jobs 16				\
	--vivado.impl.jobs 16				\
	--config ../../../Makefiles/system.cfg 		\
	-t hw_emu 					\
	-o vck190_dsp_fir.hw_emu.xclbin  		\
	s2mm.hw_emu.xo					\
	mm2s.hw_emu.xo					\
        fir_dsp.hw_emu.xo
</pre></div>
</div>
<p>If EN_TRACE is enabled, the following <code class="docutils literal notranslate"><span class="pre">v++</span></code> flags are also set:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="o">--</span><span class="n">profile</span><span class="o">.</span><span class="n">trace_memory</span> <span class="n">DDR</span>			\
	<span class="o">--</span><span class="n">profile</span><span class="o">.</span><span class="n">data</span> <span class="n">s2mm</span><span class="p">:</span><span class="n">s2mm_0</span><span class="p">:</span><span class="n">s</span>			\
	<span class="o">--</span><span class="n">profile</span><span class="o">.</span><span class="n">data</span> <span class="n">mm2s</span><span class="p">:</span><span class="n">mm2s_0</span><span class="p">:</span><span class="n">s</span>			\
	<span class="o">--</span><span class="n">profile</span><span class="o">.</span><span class="n">data</span> <span class="n">fir_dsp</span><span class="p">:</span><span class="n">dir_dsp_0</span><span class="o">.</span><span class="n">StreamIn</span>	\
	<span class="o">--</span><span class="n">profile</span><span class="o">.</span><span class="n">data</span> <span class="n">fir_dsp</span><span class="p">:</span><span class="n">dir_dsp_0</span><span class="o">.</span><span class="n">StreamOut</span>
</pre></div>
</div>
<p>This will capture trace data for the ports specified.</p>
<p>Summary of the Switches used:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Switch</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>--platform | -f</td>
<td>Specifies the name of a supported acceleration platform as specified by the $PLATFORM_REPO_PATHS environment variable or the full path to the platform XPFM file.</td>
</tr>
<tr>
<td>--save-temps | -s</td>
<td>Directs the <code>v++</code> command to save intermediate files/directories created during the compilation and link process. Use the <code>--temp_dir</code> option to specify a location to write the intermediate files to.</td>
</tr>
<tr>
<td>--temp_dir <string></td>
<td>This allows you to manage the location where the tool writes temporary files created during the build process. The temporary results are written by the Vitis compiler, and then removed, unless the <code>--save-temps</code> option is also specified.</td>
</tr>
<tr>
<td>--verbose</td>
<td>Display verbose/debug information.</td>
</tr>
<tr>
<td>-g</td>
<td>Generates code for debugging the kernel during software emulation. Using this option adds features to facilitate debugging the kernel as it is compiled.</td>
</tr>
<tr>
<td>--clock.freqHz \&lt;freq_in_Hz>:\&lt;cu>[.\&lt;clk_pin>]</td>
<td>Specifies a clock frequency in Hz and assigns it to a list of associated compute units (CUs) and optionally specific clock pins on the CU.</td>
</tr>
<tr>
<td>--config <config_file></td>
<td>Specifies a configuration file containing <code>v++</code> switches.</td>
</tr>
<tr>
<td>--target | -t [hw|hw_emu]</td>
<td>Specifies the build target.</td>
</tr>
<tr>
<td>--output | -o</td>
<td>Specifies the name of the output file generated by the <code>v++</code> command. The linking process output file name must end with the .xclbin suffix</td>
</tr>
<tr>
<td>--profile.data [<kernel_name>|all]:[<cu_name>|all]:[<interface_name>|all](:[counters|all])</td>
<td>Enables monitoring of data ports through the monitor IPs. This option needs to be specified during linking. <a href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/vitiscommandcompiler.html#lpy1600804966354">Detailed Profiling Options</a></td>
</tr>
<tr>
<td>--profile.trace_memory \&lt;FIFO>:\&lt;size>|\&lt;MEMORY>[\&lt;n>]</td>
<td>When building the hardware target (-t=hw), use this option to specify the type and amount of memory to use for capturing trace data. <a href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/vitiscommandcompiler.html#lpy1600804966354">Detailed Profiling Options</a></td>
</tr>
</tbody>
</table><p><a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/vitiscommandcompiler.html#wrj1504034328013">Detailed Desicription of All Vitis Compiler Switches</a>
<a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/buildingdevicebinary.html#mjs1528399150499">Linking the Kernels in Vitis</a></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Inputs Sources</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>s2mm.hw_emu.xo</td>
<td>The stream-to-memory-mapped data-mover kernel object file.</td>
</tr>
<tr>
<td>mm2s.hw_emu.xo</td>
<td>The memory-mapped-to-stream data-mover kernel object file.</td>
</tr>
<tr>
<td>fir_dsp.hw_emu.xo</td>
<td>The FIR filter chain PL kernel object file.</td>
</tr>
</tbody>
</table><table border="1" class="docutils">
<thead>
<tr>
<th>Output Objects</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>vck190_dsp_fir.hw_emu.xclbin</td>
<td>Compiled Platform Binary Container</td>
</tr>
</tbody>
</table></details> <details>
<summary>make application: Compile the Host Application</summary></section>
<section id="make-application-compile-the-host-application">
<h2>make application: Compile the Host Application<a class="headerlink" href="#make-application-compile-the-host-application" title="Permalink to this heading">¶</a></h2>
<p>You can compile the host application by following the typical cross-compilation flow for the Cortex-A72. To build the application run the following command (default TARGET=hw_emu, N_FIR_FILTERS=1, N_FIR_TAPS=15, EN_TRACE=0):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">application</span>
</pre></div>
</div>
<p>The expanded command is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>aarch64-linux-gnu-g++ 	-O 					\
			-c -std=c++14 				\
			-D__linux__ 				\
			-DXAIE_DEBUG				\
			-I$(PLATFORM_REPO_PATHS)/sw/versal/xilinx-versal/sysroots/aarch64-xilinx-linux/usr/include/xrt 		\
			-I$(PLATFORM_REPO_PATHS)/sw/versal/xilinx-versal/sysroots/aarch64-xilinx-linux/usr/include		\
			-I$(PLATFORM_REPO_PATHS)/sw/versal/xilinx-versal/sysroots/aarch64-xilinx-linux/usr/lib			\
			-I../../../design/app_src		\
			-I../../../design/pl_src		\
			../../../design/app_src/fir_aie_app.cpp \
			-o ../fir_aie_app.o 			\
			--sysroot=$(PLATFORM_REPO_PATHS)/sw/versal/xilinx-versal/sysroots/aarch64-xilinx-linux 			\
			-L$(PLATFORM_REPO_PATHS)/sw/versal/xilinx-versal/sysroots/aarch64-xilinx-linux/usr/lib 			\
			-lxrt_coreutil

aarch64-linux-gnu-g++ 	../fir_dsp_app.o			\
			--sysroot=$(PLATFORM_REPO_PATHS)/sw/versal/xilinx-versal/sysroots/aarch64-xilinx-linux			\
			-L$(PLATFORM_REPO_PATHS)/sw/versal/xilinx-versal/sysroots/aarch64-xilinx-linux/usr/lib 			\
			-lxrt_coreutil 				\
			-o fir_dsp_xrt.elf
</pre></div>
</div>
<p>Summary of the Switches used:
|Switch|Description|
|  —  |  —  |
|-O | Optimize| Optimizing compilation takes somewhat more time, and a lot more memory for a large function. With -O, the compiler tries to reduce code size and execution time, without performing any optimizations that can take a great deal of compilation time.|
|-c |Compile or assemble the source files, but do not link.|
|-std=&lt;\standard&gt;|Set the language standard.|
|-D__linux__| |
|-DXAIE_DEBUG|Enable debug interface capabilities where certain core status, event status, or stack trace can be dumped out.|
|-D&lt;Pre-processor Macro String&gt;=&lt;value&gt;|Pass Pre-processor Macro definitions to the cross-compiler.|
|-I &lt;dir&gt;|Add the directory <code class="docutils literal notranslate"><span class="pre">dir</span></code> to the list of directories to be searched for header files.|
|-o &lt;file&gt;|Place output in file <code class="docutils literal notranslate"><span class="pre">&lt;file&gt;</span></code>. This applies regardless of the output being produced, whether it be an executable file, an object file, an assembler file or preprocessed C code.|
|–sysroot=&lt;dir&gt;|Use <code class="docutils literal notranslate"><span class="pre">dir</span></code> as the logical root directory for headers and libraries. For example, if the compiler would normally search for headers in <code class="docutils literal notranslate"><span class="pre">/usr/include</span></code> and libraries in <code class="docutils literal notranslate"><span class="pre">/usr/lib</span></code>, it will instead search <code class="docutils literal notranslate"><span class="pre">dir/usr/include</span></code> and <code class="docutils literal notranslate"><span class="pre">dir/usr/lib</span></code>. This is automatically set by the <code class="docutils literal notranslate"><span class="pre">env_setup.sh</span></code> script|
|-l&lt;library&gt;|Search the library named <code class="docutils literal notranslate"><span class="pre">library</span></code> when linking. The 2D-FFT tutorial requires <code class="docutils literal notranslate"><span class="pre">adf_api_xrt</span></code> and <code class="docutils literal notranslate"><span class="pre">xrt_coreutil</span></code> libraries.|
|-L &lt;dir&gt;|Add directory <code class="docutils literal notranslate"><span class="pre">&lt;dir&gt;</span></code> to the list of directories to be searched for -l.|</p>
<p><a class="reference external" href="https://xilinx.github.io/XRT/2021.1/html/index.html">XRT Documentation</a>
<a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/devhostapp.html#vpy1519742402284">Details of Host Application Programming</a></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Inputs Sources</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>fir_dsp_app.cpp</td>
<td>Host processor application source code file that will run on an A72 processor.</td>
</tr>
</tbody>
</table><table border="1" class="docutils">
<thead>
<tr>
<th>Intermediate Objects</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>fir_dsp_app.o</td>
<td>Compiled host processor application object.</td>
</tr>
</tbody>
</table><table border="1" class="docutils">
<thead>
<tr>
<th>Output Objects</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>fir_dsp_xrt.elf</td>
<td>The executable that will run on an A72 processor.</td>
</tr>
</tbody>
</table></details><details>
<summary>make package: Package the Design</summary></section>
<section id="make-package-package-the-design">
<h2>make package: Package the Design<a class="headerlink" href="#make-package-package-the-design" title="Permalink to this heading">¶</a></h2>
<p>With the HLS kernel outputs created, as well as the new platform, you can now generate the programmable device image (PDI) and a package to be used on an SD card. The PDI contains all executables, bitstreams, configurations of the device. The packaged SD card directory contains everything to boot Linux, the generated applications, and <code class="docutils literal notranslate"><span class="pre">.xclbin</span></code>.</p>
<p>The command to run this step is as follows (default TARGET=hw_emu, N_FIR_FILTERS=1, N_FIR_TAPS=15, EN_TRACE=0):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">package</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cd ../build/fir_dsp_$(N_FIR_FILTERS)firs_$(N_FIR_TAPS)taps/hw_emu

v++	-p  							\
	-t hw_emu						\
	--save-temps						\
	--temp_dir ../build/fir_dsp_$(N_FIR_FILTERS)firs_$(N_FIR_TAPS)taps/hw_emu/_x						\
	-f xilinx_vck190_base_202110_1												\
	--package.sd_dir $(PLATFORM_REPO_PATHS)/sw/versal/xrt 									\
	--package.rootfs $(PLATFORM_REPO_PATHS)/sw/versal/xilinx-versal/rootfs.ext4 						\
	--package.kernel_image $(PLATFORM_REPO_PATHS)/sw/versal/xilinx-versal/Image 						\
	--package.boot_mode=sd													\
	--package.out_dir ../build/fir_dsp_$(N_FIR_FILTERS)firs_$(N_FIR_TAPS)taps/hw_emu/package	        		\
	--package.image_format=ext4												\
	--package.sd_file	../build/fir_dsp_$(N_FIR_FILTERS)firs_$(N_FIR_TAPS)taps/hw_emu/fir_dsp_xrt.elf     		\
				../build/fir_dsp_$(N_FIR_FILTERS)firs_$(N_FIR_TAPS)taps/hw_emu/vck190_dsp_fir.hw_emu.xclbin 	\
</pre></div>
</div>
<p>If EN_TRACE is enabled, the following <code class="docutils literal notranslate"><span class="pre">v++</span></code> flags are also set:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="o">--</span><span class="n">package</span><span class="o">.</span><span class="n">sd_file</span> <span class="o">./</span><span class="n">xrt</span><span class="o">.</span><span class="n">ini</span>
</pre></div>
</div>
<p>This will include the XRT ini file which includes tracing parameters.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Switch</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>--package | -p</td>
<td>Packages the final product at the end of the Vitis compile and link build process.</td>
</tr>
<tr>
<td>--target | -t [hw|hw_emu]</td>
<td>Specifies the build target.</td>
</tr>
<tr>
<td>--save-temps | -s</td>
<td>Directs the V++ command to save intermediate files/directories created during the compilation and link process. Use the <code>--temp_dir</code> option to specify a location to write the intermediate files to.</td>
</tr>
<tr>
<td>--temp_dir <string></td>
<td>This allows you to manage the location where the tool writes temporary files created during the build process. The temporary results are written by the Vitis compiler, and then removed, unless the <code>--save-temps</code> option is also specified.</td>
</tr>
<tr>
<td>--platform | -f</td>
<td>Specifies the name of a supported acceleration platform as specified by the $PLATFORM_REPO_PATHS environment variable or the full path to the platform XPFM file.</td>
</tr>
<tr>
<td>--package.sd_dir \&lt;arg></td>
<td>Where <arg> specifies a folder to package into the sd_card directory/image. The contents of the directory are copied to a sub-folder of the sd_card folder.</td>
</tr>
<tr>
<td>--package.rootfs \&lt;arg></td>
<td>Where \&lt;arg> specifies the absolute or relative path to a processed Linux root file system file. The platform RootFS file is available for download from xilinx.com. Refer to the Vitis Software Platform Installation for more information.</td>
</tr>
<tr>
<td>--package.kernel_image \&lt;arg></td>
<td>Where \&lt;arg> specifies the absolute or relative path to a Linux kernel image file. Overrides the existing image available in the platform. The platform image file is available for download from xilinx.com. Refer to the Vitis Software Platform Installation for more information.</td>
</tr>
<tr>
<td>--package.boot_mode \&lt;arg></td>
<td>Where \&lt;arg> specifies <ospi\|qspi\|sd> Boot mode used for running the application in emulation or on hardware.</td>
</tr>
<tr>
<td>--package.image_format</td>
<td>Where \&lt;arg> specifies \&lt;ext4|fat32> output image file format. <code>ext4</code>: Linux file system and <code>fat32</code>: Windows file system</td>
</tr>
<tr>
<td>--package.sd_file</td>
<td>Where \&lt;arg> specifies an ELF or other data file to package into the <code>sd_card</code> directory/image. This option can be used repeatedly to specify multiple files to add to the <code>sd_card</code>.</td>
</tr>
</tbody>
</table><p><a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/vitiscommandcompiler.html#wrj1504034328013">Detailed Desicription of All Vitis Compiler Switches</a>
<a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/packagesystem1.html#cwq1586366344968">Details of Packaging the System</a></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Inputs Sources</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>$(PLATFORM_REPO_PATHS)/sw/versal/xrt</td>
<td>The PS Host Application needs the XRT headers in this folder to execute.</td>
</tr>
<tr>
<td>$(PLATFORM_REPO_PATHS)/sw/versal/xilinx-versal/rootfs.ext4</td>
<td>The Root Filesystem file for Petalinux.</td>
</tr>
<tr>
<td>$(PLATFORM_REPO_PATHS)/sw/versal/xilinx-versal/Image</td>
<td>The pre-built Petalinux Image the processor boots from.</td>
</tr>
<tr>
<td>$(BUILD_TARGET_DIR)/fir_dsp_xrt.elf</td>
<td>The PS Host Application executables created in the <code>make application</code> step.</td>
</tr>
<tr>
<td>$(BUILD_TARGET_DIR)/vck190_dsp_fir.hw_emu.xclbin</td>
<td>The XCLBIN file created in the <code>make xclbin</code> step.</td>
</tr>
</tbody>
</table><p>The output of the V++ Package step is the package directory that contains the contents to run hardware emulation.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Output Objects</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>$(BUILD_TARGET_DIR)/package</td>
<td>The hardware emulation package that contains the boot file, hardware emulation launch script, the PLM and PMC boot files, the PMC and QEMU command argument specification files, and the Vivado® tools simulation folder.</td>
</tr>
</tbody>
</table></details><details>
<summary>make run_emu: Run Hardware Emulation</summary></section>
<section id="make-run-emu-run-hardware-emulation">
<h2>make run_emu: Run Hardware Emulation<a class="headerlink" href="#make-run-emu-run-hardware-emulation" title="Permalink to this heading">¶</a></h2>
<p>After packaging, everything is set to run emulation or hardware.
To run emulation use the following command (default TARGET=hw_emu, N_FIR_FILTERS=1, N_FIR_TAPS=15, EN_TRACE=0):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">run_emu</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cd ../build/fir_dsp_$(N_FIR_FILTERS)firs_$(N_FIR_TAPS)taps/hw_emu/package
./launch_hw_emu.sh
</pre></div>
</div>
<p>When launched, you will see the QEMU simulator load. Wait for the autoboot countdown to go to zero, and after a few minutes, you will see the root Linux prompt come up:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>root@versal-rootfs-common-2021_1:~#
</pre></div>
</div>
<p>In some cases, the following error might come up on the screen:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">root</span><span class="nd">@versal</span><span class="o">-</span><span class="n">rootfs</span><span class="o">-</span><span class="n">common</span><span class="o">-</span><span class="mi">2021_1</span><span class="p">:</span><span class="o">~</span><span class="c1"># xinit: giving up</span>
<span class="n">xinit</span><span class="p">:</span> <span class="n">unable</span> <span class="n">to</span> <span class="n">connect</span> <span class="n">to</span> <span class="n">X</span> <span class="n">server</span><span class="p">:</span> <span class="n">Connection</span> <span class="n">refused</span>
<span class="n">xinit</span><span class="p">:</span> <span class="n">server</span> <span class="n">error</span>
<span class="n">Enabling</span> <span class="n">notebook</span> <span class="n">extension</span> <span class="n">jupyter</span><span class="o">-</span><span class="n">js</span><span class="o">-</span><span class="n">widgets</span><span class="o">/</span><span class="n">extension</span><span class="o">...</span>
      <span class="o">-</span> <span class="n">Validating</span><span class="p">:</span> <span class="n">OK</span>
<span class="p">[</span><span class="n">C</span> <span class="mi">13</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mf">09.233</span> <span class="n">NotebookApp</span><span class="p">]</span> <span class="n">Bad</span> <span class="n">config</span> <span class="n">encountered</span> <span class="n">during</span> <span class="n">initialization</span><span class="p">:</span>
<span class="p">[</span><span class="n">C</span> <span class="mi">13</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mf">09.239</span> <span class="n">NotebookApp</span><span class="p">]</span> <span class="n">No</span> <span class="n">such</span> <span class="n">notebook</span> <span class="nb">dir</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">share</span><span class="o">/</span><span class="n">example</span><span class="o">-</span><span class="n">notebooks</span><span class="s1">&#39;&#39;</span>
</pre></div>
</div>
<p>The error can be ignored. Press <enter> to return to the root prompt.</p>
<p>After the root prompt comes up, run the following commands to run the design:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mount</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">mmcblk0p1</span> <span class="o">/</span><span class="n">mnt</span>
<span class="n">cd</span> <span class="o">/</span><span class="n">mnt</span>
<span class="n">export</span> <span class="n">XLC_EMULATION_MODE</span><span class="o">=</span><span class="n">hw_emu</span>
<span class="n">export</span> <span class="n">XILINX_XRT</span><span class="o">=/</span><span class="n">usr</span>
<span class="o">./</span><span class="n">fir_dsp_xrt</span><span class="o">.</span><span class="n">elf</span> <span class="n">a</span><span class="o">.</span><span class="n">xclbin</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">fir_dsp_xrt.elf</span></code> should execute, and after a few minutes, you should see the output with <em>TEST PASSED</em> on the console. When this is shown, run the following keyboard command to exit the QEMU instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#To exit QEMU Simulation</span>
<span class="n">Press</span> <span class="n">Ctrl</span><span class="o">-</span><span class="n">A</span><span class="p">,</span> <span class="n">let</span> <span class="n">go</span> <span class="n">of</span> <span class="n">the</span> <span class="n">keyboard</span><span class="p">,</span> <span class="ow">and</span> <span class="n">then</span> <span class="n">press</span> <span class="n">x</span>
</pre></div>
</div>
<p>To run with waveform do the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cd ../build/fir_dsp_$(N_FIR_FILTERS)firs_$(N_FIR_TAPS)taps/hw_emu/package
./launch_hw_emu.sh -graphic -xsim
</pre></div>
</div>
<p>The XSIM Waveform Viewer is launched. Drag and drop the signals into the Viewer and click Play to start the emulation. Go back to the terminal and wait for the Linux prompt to show up.</p>
<p>In the XSIM Waveform Viewer, you will see the signals you added to the waveform adjusting over the execution of the design. Once done, hit the pause button and close the window to end the emulation.</p>
</details><details>
<summary>TARGET=hw: Run on Hardware</summary></section>
<section id="run-on-hardware">
<h2>Run on Hardware<a class="headerlink" href="#run-on-hardware" title="Permalink to this heading">¶</a></h2>
<p>To run the design in hardware, re-run the following “make” steps with TARGET=hw and other applicable options (see the make steps above)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">kernels</span>     <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span>
<span class="n">make</span> <span class="n">xclbin</span>      <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span>
<span class="n">make</span> <span class="n">application</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span>
<span class="n">make</span> <span class="n">package</span>     <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span>
</pre></div>
</div>
<p>this can also be done is a single step as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">build</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span>
</pre></div>
</div>
<p>Now follow <strong>Steps 1-9</strong> to run the <code class="docutils literal notranslate"><span class="pre">lenet_xrt.elf</span></code> executable on your VCK190 board.</p>
<p><strong>Step 1.</strong> Ensure your board is powered OFF.</p>
<p><strong>Step 2.</strong> Use an SD card writer (such as balenaEtcher) to flash the <code class="docutils literal notranslate"><span class="pre">sd_card.img</span></code> file onto an SD card.</p>
<p><strong>Step 3.</strong> Plug the flashed SD card into the top slot of the VCK190 board.</p>
<p><strong>Step 4.</strong> Set the switch SW1 Mode[3:0]=1110 = OFF OFF OFF ON.</p>
<p><strong>Step 5.</strong> Connect your computer to the VCK190 board using the included USB cable.</p>
<p><strong>Step 6.</strong> Open a TeraTerm terminal and select the correct COM port. Set the port settings to the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Port</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">COMMXX</span><span class="o">&gt;</span>
<span class="n">Speed</span><span class="p">:</span> <span class="mi">115200</span>
<span class="n">Data</span><span class="p">:</span> <span class="mi">8</span> <span class="n">bit</span>
<span class="n">Parity</span><span class="p">:</span> <span class="n">none</span>
<span class="n">Stop</span> <span class="n">Bits</span><span class="p">:</span> <span class="mi">1</span> <span class="n">bit</span>
<span class="n">Flow</span> <span class="n">control</span><span class="p">:</span> <span class="n">none</span>
<span class="n">Transmit</span> <span class="n">delay</span><span class="p">:</span> <span class="mi">0</span> <span class="n">msec</span><span class="o">/</span><span class="n">char</span> <span class="mi">0</span> <span class="n">msec</span><span class="o">/</span><span class="n">line</span>
</pre></div>
</div>
<p><strong>Step 7.</strong> Power ON the board.</p>
<p><strong>Step 8.</strong> Wait until you see the <code class="docutils literal notranslate"><span class="pre">root&#64;versal-rootfs-common-2021_1</span></code> Linux command prompt. Press enter a few times to get past any <code class="docutils literal notranslate"><span class="pre">xinit</span></code> errors.</p>
<p><strong>Step 9.</strong> Run the following commands into the TeraTerm terminal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">/</span><span class="n">mnt</span><span class="o">/</span><span class="n">sd</span><span class="o">-</span><span class="n">mmcblk0p1</span>
<span class="n">export</span> <span class="n">XILINX_XRT</span><span class="o">=/</span><span class="n">usr</span>
<span class="o">./</span><span class="n">init</span><span class="o">.</span><span class="n">sh</span>
<span class="o">./</span><span class="n">fir_dsp_xrt</span><span class="o">.</span><span class="n">elf</span> <span class="n">a</span><span class="o">.</span><span class="n">xclbin</span>
</pre></div>
</div>
<p>After execution completes and the testcase passes data integrity check, ‘TEST PASSED’ should appear on the terminal.</p>
</details></section>
</section>
<section id="hardware-design-details">
<h1>Hardware Design Details<a class="headerlink" href="#hardware-design-details" title="Permalink to this heading">¶</a></h1>
<details>
<summary>FIR Filter HLS Implementation Architecture</summary><section id="fir-filter-hls-implementation-architecture">
<h2>FIR Filter HLS Implementation Architecture<a class="headerlink" href="#fir-filter-hls-implementation-architecture" title="Permalink to this heading">¶</a></h2>
<p>The following figure shows a high level block diagram of the design. The test harness consists of the compute kernels, data mover kernels and DDR memory to store input and output vectors. This setup is maintained in the two implementations (using HLS with DSP engines in this section of the tutorial and AI Engine in the other). In this setup, the interface between the data mover kernels and DDR is memory mapped AXI4 and it is AXI4-stream between data mover kernel and the FIR filter chain PL kernel. The mm2s kernel moves data from the DDR memory into the FIR Filter and the s2mm kernel moves the data from FIR filter back to DDR memory. The data widths of both the kernels is 128 bits wide, and they run at 300 MHz, providing a transfer rate of up to 1.2 Gsamples/sec.</p>
<p><img alt="Image of FIR Filter DSP implementation architecture" src="../../../../../_images/fir_dsp_block_diagram.png" /></p>
</details><details>
<summary>Design Details</summary></section>
<section id="design-details">
<h2>Design Details<a class="headerlink" href="#design-details" title="Permalink to this heading">¶</a></h2>
<p>The design in this tutorial starts with a base platform containing the control interface and processing system (CIPS), NoC, and AI Engine and the interfaces among them. The v++ linker step builds on top of the base platform by adding the PL kernels. To add the various functions in a system level design, PL kernels are added to the base platform depending on the application, that is, the PL kernels present in each design may vary. In the design, the components are added by v++ -l step (make XCLBIN in the tool flow section above) and include the following:</p>
<ul class="simple">
<li><p>FIR Filter Chain kernel (<code class="docutils literal notranslate"><span class="pre">fir_dsp.[hw|hw_emu].xo</span></code>)</p></li>
<li><p>data mover kernel (<code class="docutils literal notranslate"><span class="pre">mm2s.[hw|hw_emu].xo</span></code> and <code class="docutils literal notranslate"><span class="pre">s2mm.[hw|hw_emu].xo</span></code>)</p></li>
<li><p>connections interfaces defined in system configuration file (system.cfg)</p></li>
</ul>
<p>To see a schematic view of the design with the extended platform as shown in the following figure, open in Vivado tools:</p>
<p><code class="docutils literal notranslate"><span class="pre">build/fir_dsp_$(N_FIR_FILTERS)firs_$(N_FIR_TAPS)taps/[hw|hw_emu]/_x/link/vivado/vpl/prj/prj.xpr</span></code></p>
<p><img alt="Image of FIR Filter DSP Platform schematic" src="../../../../../_images/fir_dsp_vivado.png" /></p>
<p>The actual FIR filter chain itself is implemented in a HLS PL kernel, which connects the specified number of filters together in a chain.  For purposes of simplicity in comparing the designs, all the filters in the chain are identical, though it is unlikely such a chain would be used in a practical application.</p>
<p>Notice the system debugging and profiling IP (DPA) is added to the PL region of the device to capture AI Engine run-time trace data if the EN_TRACE option is enabled in the design. The mm2s/s2mm kernels and the AI Engine array interface are both operating at 300 MHz.</p>
</details><details>
<summary>HLS PL Kernels</summary></section>
<section id="hls-pl-kernels">
<h2>HLS PL Kernels<a class="headerlink" href="#hls-pl-kernels" title="Permalink to this heading">¶</a></h2>
<p>In the HLS implementation of the FIR Filter design, the AI Engine is not used and therefore there are no AI Engine-related kernels and graphs. The compute and datamover functions are implemented as HLS kernels in the PL region.</p>
<p>The PL kernel <code class="docutils literal notranslate"><span class="pre">fir_dsp</span></code> implements the FIR filter chain.  It contains a single AXI-stream input port and a single AXI-stream output port.  Since the FIR function requires no initialization, no additional control/status ports are required.</p>
<p>The PL-based data movers consist of MM2S and S2MM kernels. The MM2S move data from DDR memory through the NoC to the FIR Filter kernel and the final FIR output is moved back to DDR memory through the NoC by the S2MM kernel. In either data mover kernel, the side facing NoC uses a memory mapped AXI4 interface (MM-AXI4) and the side facing the AI Engine array uses an AXI4-Stream interface.
Some additional details regarding the data mover kernels include:</p>
<p><strong>MM2S</strong></p>
<ul class="simple">
<li><p>The data width is 128 bits</p></li>
<li><p>To avoid bandwidth limitation resulting in back pressure which causes performance degradation, the HLS pragma <code class="docutils literal notranslate"><span class="pre">max_read_burst_length</span></code> is set higher than the default to 256 bits.</p></li>
</ul>
<p><strong>S2MM</strong></p>
<ul class="simple">
<li><p>The data width is 128 bits</p></li>
<li><p>To avoid bandwidth limitation resulting in back pressure which causes performance degradation, the HLS pragma <code class="docutils literal notranslate"><span class="pre">max_write_burst_length</span></code> is set higher than the default to 256 bits.</p></li>
</ul>
</details></section>
</section>
<section id="software-design-details">
<h1>Software Design Details<a class="headerlink" href="#software-design-details" title="Permalink to this heading">¶</a></h1>
<p>The software design in the FIR Filter HLS implementation consists of the following sections:</p>
<details>
<summary>PL Kernels</summary><section id="pl-kernels">
<h2>PL Kernels<a class="headerlink" href="#pl-kernels" title="Permalink to this heading">¶</a></h2>
<p>For the HLS implementation of this design, the data mover kernels and the FIR filter chain are all implmented in HLS.</p>
<section id="fir-dsp-fir-dsp-cpp">
<h3>fir_dsp (fir_dsp.cpp)<a class="headerlink" href="#fir-dsp-fir-dsp-cpp" title="Permalink to this heading">¶</a></h3>
<p>The fir_filter kernel consists of a single AXI-stream input and AXI-stream output.  The kernel makes use of the FIR Compiler IP, the same one that can be instantiated as an IP in Vivado tools. In HLS, it is instantiated as an object in the HLS code, and then cascaded together into a chain by the design.</p>
<p>The following include allows us to utilize the FIR Compiler interface provided in the HLS IP libraries from the Vitis HLS Libraries Reference:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;hls_fir.h&gt;</span>
</pre></div>
</div>
<p>This header files provides a parameterization struct (<code class="docutils literal notranslate"><span class="pre">hls::ip_fir::params_t</span></code>) that sets the static parameters of the filter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">fir_params</span> <span class="p">:</span> <span class="n">hls</span><span class="p">::</span><span class="n">ip_fir</span><span class="p">::</span><span class="n">params_t</span> <span class="p">{</span>
    <span class="n">static</span> <span class="n">const</span> <span class="n">unsigned</span> <span class="n">num_coeffs</span>    <span class="o">=</span> <span class="n">N_FIR_TAPS</span><span class="p">;</span>
    <span class="n">static</span> <span class="n">const</span> <span class="n">double</span>   <span class="n">coeff_vec</span><span class="p">[</span><span class="n">N_FIR_TAPS</span><span class="p">];</span>
    <span class="n">static</span> <span class="n">const</span> <span class="n">unsigned</span> <span class="n">coeff_width</span>   <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
    <span class="n">static</span> <span class="n">const</span> <span class="n">unsigned</span> <span class="n">input_width</span>   <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
    <span class="n">static</span> <span class="n">const</span> <span class="n">unsigned</span> <span class="n">output_width</span>  <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
    <span class="n">static</span> <span class="n">const</span> <span class="n">unsigned</span> <span class="n">output_rounding_mode</span> <span class="o">=</span> <span class="n">hls</span><span class="p">::</span><span class="n">ip_fir</span><span class="p">::</span><span class="n">truncate_lsbs</span><span class="p">;</span>
    <span class="n">static</span> <span class="n">const</span> <span class="n">unsigned</span> <span class="n">input_length</span>  <span class="o">=</span> <span class="n">WINDOW_LENGTH</span><span class="p">;</span>
    <span class="n">static</span> <span class="n">const</span> <span class="n">unsigned</span> <span class="n">output_length</span> <span class="o">=</span> <span class="n">WINDOW_LENGTH</span><span class="p">;</span>
    <span class="n">static</span> <span class="n">const</span> <span class="n">unsigned</span> <span class="n">sample_period</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">static</span> <span class="n">const</span> <span class="n">unsigned</span> <span class="n">coeff_structure</span> <span class="o">=</span> <span class="n">hls</span><span class="p">::</span><span class="n">ip_fir</span><span class="p">::</span><span class="n">symmetric</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Here we set key non-default values for the filter, the number of taps, the tap vectors (in <code class="docutils literal notranslate"><span class="pre">coeff_vec</span></code>), data widths, truncation mode, and filter structure.</p>
<p>Note that the FIR filter wrapper has the concept of an input/output length, which is called WINDOW_LENGTH. This is unrelated to FIR_WINDOW_SIZE in the AI Engine version of the design. In AI Engine graph design, data is processed in fixed size batches (windows), and FIR_WINDOW_SIZE specifies the size of these physical buffers. Here the buffer size will directly impact latency.</p>
<p>In the HLS (DSP) implementation, arrays (windows) are a means of passing data to functions, but these data arrays are ultimately translated into AXI-streams. For this implementation, WINDOW_SIZE is made to be 64k.</p>
<p>The following section instantiates arrays of filter objects (one for real values, one for imaginary):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">hls</span><span class="p">::</span><span class="n">FIR</span><span class="o">&lt;</span><span class="n">fir_params</span><span class="o">&gt;</span> <span class="n">fir_real</span><span class="p">[</span><span class="n">N_FIR_FILTERS</span><span class="p">];</span>
<span class="n">static</span> <span class="n">hls</span><span class="p">::</span><span class="n">FIR</span><span class="o">&lt;</span><span class="n">fir_params</span><span class="o">&gt;</span> <span class="n">fir_imag</span><span class="p">[</span><span class="n">N_FIR_FILTERS</span><span class="p">];</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">complex_split</span></code> function is used to take the incoming array (stream) of 32-bit data, and split each word into two 16-bit word streams:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">complex_split</span> <span class="p">(</span><span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">StreamIn</span><span class="p">,</span>
                    <span class="n">DataWindow_t</span> <span class="n">DataRealIn</span><span class="p">,</span>
                    <span class="n">DataWindow_t</span> <span class="n">DataImagIn</span>
                   <span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">ix</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">WINDOW_LENGTH</span><span class="p">;</span> <span class="n">ix</span><span class="o">++</span><span class="p">)</span>  <span class="p">{</span>
        <span class="c1">#pragma HLS PIPELINE II=1</span>
        <span class="n">ap_axiu</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="n">StreamWord</span> <span class="o">=</span> <span class="n">StreamIn</span><span class="o">.</span><span class="n">read</span><span class="p">();</span>
        <span class="n">uint32_t</span> <span class="n">word</span> <span class="o">=</span> <span class="n">StreamWord</span><span class="o">.</span><span class="n">data</span><span class="p">;</span>
        <span class="n">DataRealIn</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">word</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>
        <span class="n">DataImagIn</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span>  <span class="n">word</span>        <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">complex_merge</span></code> function is the inverse of complex_split, and used to merge the words from wo incoming 16-bit streams into one 32-bit stream:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">complex_merge</span> <span class="p">(</span><span class="n">DataWindow_t</span> <span class="n">DataRealOut</span><span class="p">,</span>
                    <span class="n">DataWindow_t</span> <span class="n">DataImagOut</span><span class="p">,</span>
                    <span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">StreamOut</span>
                <span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">ix</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="n">WINDOW_LENGTH</span><span class="p">;</span> <span class="n">ix</span><span class="o">++</span><span class="p">)</span>  <span class="p">{</span>
        <span class="c1">#pragma HLS PIPELINE II=1</span>
        <span class="n">uint32_t</span> <span class="n">word</span> <span class="o">=</span> <span class="p">(((</span><span class="n">uint32_t</span><span class="p">)</span> <span class="n">DataRealOut</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">DataImagOut</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
        <span class="n">ap_axiu</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="n">StreamWord</span><span class="p">;</span>
        <span class="n">StreamWord</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">word</span><span class="p">;</span>
        <span class="n">StreamOut</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">StreamWord</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">dsp_run</span></code> function takes to two 16-bit streams, and directs them to two FIR filters which are run in parallel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">dsp_run</span> <span class="p">(</span><span class="nb">int</span> <span class="n">N</span><span class="p">,</span>
              <span class="n">DataWindow_t</span> <span class="n">DataRealIn</span><span class="p">,</span>
              <span class="n">DataWindow_t</span> <span class="n">DataImagIn</span><span class="p">,</span>
              <span class="n">DataWindow_t</span> <span class="n">DataRealOut</span><span class="p">,</span>
              <span class="n">DataWindow_t</span> <span class="n">DataImagOut</span>
             <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">#pragma HLS dataflow</span>
    <span class="n">fir_real</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">DataRealIn</span><span class="p">,</span> <span class="n">DataRealOut</span><span class="p">);</span>
    <span class="n">fir_imag</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">DataImagIn</span><span class="p">,</span> <span class="n">DataImagOut</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The #pragma HLS dataflow directive instructs the compile to run the two processes to run in parallel, much as would be done in RTL.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">fir_wrap</span></code> is used to construct the filter chain. It uses a series of #if/#elif preprocessor directives to enable the code, since it was not possible to generate it iteratively using a loop. (The limitation being synthesis of arrays of arrays).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">fir_wrap</span> <span class="p">(</span><span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">StreamIn</span><span class="p">,</span>
               <span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">StreamOut</span>
              <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">#pragma HLS dataflow</span>

    <span class="n">DataWindow_t</span> <span class="n">DataRealIn</span><span class="p">,</span>  <span class="n">DataImagIn</span><span class="p">;</span>
    <span class="n">DataWindow_t</span> <span class="n">DataRealOut</span><span class="p">,</span> <span class="n">DataImagOut</span><span class="p">;</span>
    <span class="c1">#pragma HLS stream variable=DataRealIn   depth=16</span>
    <span class="c1">#pragma HLS stream variable=DataRealOut  depth=16</span>
    <span class="c1">#pragma HLS stream variable=DataImagIn   depth=16</span>
    <span class="c1">#pragma HLS stream variable=DataImagOut  depth=16</span>

    <span class="n">complex_split</span><span class="p">(</span><span class="n">StreamIn</span><span class="p">,</span> <span class="n">DataRealIn</span><span class="p">,</span> <span class="n">DataImagIn</span><span class="p">);</span>

<span class="c1">#if (N_FIR_FILTERS == 1)</span>
    <span class="n">dsp_run</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">DataRealIn</span><span class="p">,</span>  <span class="n">DataImagIn</span><span class="p">,</span>  <span class="n">DataRealOut</span><span class="p">,</span> <span class="n">DataImagOut</span><span class="p">);</span>
<span class="c1">#elif (N_FIR_FILTERS &gt; 1)</span>
    <span class="n">DataWindow_t</span> <span class="n">DataReal_0</span><span class="p">,</span>  <span class="n">DataImag_0</span><span class="p">;</span>
    <span class="c1">#pragma HLS stream variable=DataReal_0  depth=16</span>
    <span class="c1">#pragma HLS stream variable=DataImag_0  depth=16</span>
    <span class="n">dsp_run</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">DataRealIn</span><span class="p">,</span>  <span class="n">DataImagIn</span><span class="p">,</span>  <span class="n">DataReal_0</span><span class="p">,</span> <span class="n">DataImag_0</span><span class="p">);</span>
<span class="c1">#endif</span>

<span class="o">...</span><span class="n">etc</span>
</pre></div>
</div>
<p>Finally, the <code class="docutils literal notranslate"><span class="pre">fir_dsp</span></code> function it a top-level module / kernel available to be linked together to the other HLS kernels.</p>
<section id="arguments">
<h4>Arguments<a class="headerlink" href="#arguments" title="Permalink to this heading">¶</a></h4>
<p>The FIR kernel takes the following arguments:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hls::stream&lt;ap_axiu&lt;32,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0&gt;&gt;</span></code> is a data type defined in <code class="docutils literal notranslate"><span class="pre">ap_axi_sdata.h</span></code>. It is a special data class used for data transfer when using a streaming platform. The parameter <code class="docutils literal notranslate"><span class="pre">&lt;D&gt;</span></code> is the data width of the streaming interface which is set to 32. The remaining three parameters should be set to 0.</p></li>
</ul>
<p>The fir_dsp kernel also specifies the following pragmas to help optimize the kernel code and adhere to interface protocols:</p>
</section>
<section id="pragma-hls-interface-ap-ctrl-none-port-return">
<h4>pragma HLS interface ap_ctrl_none port=return<a class="headerlink" href="#pragma-hls-interface-ap-ctrl-none-port-return" title="Permalink to this heading">¶</a></h4>
<p>This kernel requires no additional control/status interfaces.</p>
</section>
</section>
<section id="mm2s-mm2s-cpp">
<h3>mm2s (mm2s.cpp)<a class="headerlink" href="#mm2s-mm2s-cpp" title="Permalink to this heading">¶</a></h3>
<p>The mm2s kernel reads data from a Memory Mapped AXI4 (MM-AXI4) interface and writes it to an AXI4-Stream Interface</p>
<section id="id1">
<h4>Arguments<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h4>
<p>The mm2s kernel takes the following arguments:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ap_int&lt;N&gt;</span></code> is an arbitrary precision integer data type defined in <code class="docutils literal notranslate"><span class="pre">ap_int.h</span></code> where <code class="docutils literal notranslate"><span class="pre">N</span></code> is a bit-size from 1-1024. In this design, the bit-size is set to 128.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hls::stream&lt;qdma_axis&lt;D,0,0,0&gt;&gt;</span></code> is a data type defined in <code class="docutils literal notranslate"><span class="pre">ap_axi_sdata.h</span></code>. It is a special data class used for data transfer when using a streaming platform. The parameter <code class="docutils literal notranslate"><span class="pre">&lt;D&gt;</span></code> is the data width of the streaming interface which is set to 128. The remaining three parameters should be set to 0.</p></li>
</ul>
<p>The mm2s kernel also specifies the following pragmas to help optimize the kernel code and adhere to interface protocols</p>
</section>
<section id="pragma-hls-interface-s-axilite">
<h4>pragma HLS INTERFACE s_axilite<a class="headerlink" href="#pragma-hls-interface-s-axilite" title="Permalink to this heading">¶</a></h4>
<p>The mm2s kernels has one <code class="docutils literal notranslate"><span class="pre">s_axilite</span></code> interface (specifying a AXI4-Lite slave I/O protocol) with <code class="docutils literal notranslate"><span class="pre">bundle=control</span></code> associated with all the arguments (<code class="docutils literal notranslate"><span class="pre">mem</span></code>,<code class="docutils literal notranslate"><span class="pre">s</span></code>, and <code class="docutils literal notranslate"><span class="pre">size</span></code>). This interface is also associated with <code class="docutils literal notranslate"><span class="pre">return</span></code>.</p>
<section id="pragma-hls-interface-m-axi">
<h5>pragma HLS INTERFACE m_axi<a class="headerlink" href="#pragma-hls-interface-m-axi" title="Permalink to this heading">¶</a></h5>
<p>The mm2s kernel has one <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> interface (specifying a AXI4 master I/O protocol) with <code class="docutils literal notranslate"><span class="pre">offset=slave</span> <span class="pre">bundle=gmem</span></code>. This interface also has <code class="docutils literal notranslate"><span class="pre">max_read_burst_length=256</span></code>. Part of this AXI4 interface is the Read Address Channel containing the signals <code class="docutils literal notranslate"><span class="pre">ARBURST</span></code> and <code class="docutils literal notranslate"><span class="pre">ARLEN</span></code>. This interface has a burst type <code class="docutils literal notranslate"><span class="pre">ARBURST=INCR</span></code> and can support burst length <code class="docutils literal notranslate"><span class="pre">ARLEN</span></code> of 1-256 read transfers. In an incrementing burst, the address for each transfer in the burst is an increment of the previous transfer address. The <code class="docutils literal notranslate"><span class="pre">max_read_burst_length=256</span></code> sets the burst length <code class="docutils literal notranslate"><span class="pre">ARLEN=256</span></code> transfers, meaning that in every transaction (burst), there are 256 transfers of data. The address of each transfer with a size of 16 bytes (128-bits from the <code class="docutils literal notranslate"><span class="pre">mem</span></code> argument) is the previous address plus 16.</p>
</section>
</section>
<section id="pragma-hls-interface-axis">
<h4>pragma HLS INTERFACE axis<a class="headerlink" href="#pragma-hls-interface-axis" title="Permalink to this heading">¶</a></h4>
<p>The mm2s kernel has one <code class="docutils literal notranslate"><span class="pre">axis</span></code> interface (specifying a AXI4-Stream I/O protocol)</p>
</section>
<section id="pragma-hls-pipeline-ii-1">
<h4>pragma HLS PIPELINE II=1<a class="headerlink" href="#pragma-hls-pipeline-ii-1" title="Permalink to this heading">¶</a></h4>
<p>The mm2s kernel has a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop that is a candidate for burst read because the memory addresses per loop iteration is consecutive (<code class="docutils literal notranslate"><span class="pre">ARBURST=INCR</span></code>). To pipeline this <code class="docutils literal notranslate"><span class="pre">for</span></code> loop, you can use this pragma by setting the initiation interval (<code class="docutils literal notranslate"><span class="pre">II</span></code>) = 1.</p>
</section>
</section>
<section id="s2mm-s2mm-cpp">
<h3>s2mm (s2mm.cpp)<a class="headerlink" href="#s2mm-s2mm-cpp" title="Permalink to this heading">¶</a></h3>
<p>The s2mm kernel reads 128 bits of data from an AXI4-Stream interface and writes it to an AXI Memory mapped interface.</p>
<section id="id2">
<h4>Arguments<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h4>
<p>The s2mm kernel takes the following arguments:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ap_int&lt;N&gt;</span></code> is an arbitrary precision integer data type defined in <code class="docutils literal notranslate"><span class="pre">ap_int.h</span></code> where <code class="docutils literal notranslate"><span class="pre">N</span></code> is a bit-size from 1-1024. For the <code class="docutils literal notranslate"><span class="pre">mem</span></code> argument, the bit-size is set to 128.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hls::stream&lt;qdma_axis&lt;D,0,0,0&gt;&gt;</span></code> is a data type defined in <code class="docutils literal notranslate"><span class="pre">ap_axi_sdata.h</span></code>. It is a special data class used for data transfer when using a streaming platform. The parameter <code class="docutils literal notranslate"><span class="pre">&lt;D&gt;</span></code> is the data width of the streaming interface and is set to 128 (same as the <code class="docutils literal notranslate"><span class="pre">mem</span></code> argument). The remaining three parameters should be set to 0.</p></li>
</ul>
<p>The s2mm kernel also specifies the following pragmas to help optimize the kernel code and adhere to interface protocols</p>
</section>
<section id="id3">
<h4>pragma HLS INTERFACE s_axilite<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h4>
<p>The s2mm kernel has one <code class="docutils literal notranslate"><span class="pre">s_axilite</span></code> interface  (specifying a AXI4-Lite slave I/O protocol) with <code class="docutils literal notranslate"><span class="pre">bundle=control</span></code> associated with all the arguments (<code class="docutils literal notranslate"><span class="pre">mem</span></code>,<code class="docutils literal notranslate"><span class="pre">s</span></code>, and <code class="docutils literal notranslate"><span class="pre">size</span></code>). This interface is also associated with <code class="docutils literal notranslate"><span class="pre">return</span></code>.</p>
</section>
<section id="id4">
<h4>pragma HLS INTERFACE m_axi<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h4>
<p>The s2mm kernel has one <code class="docutils literal notranslate"><span class="pre">m_axi</span></code> interface (specifying an AXI4 master I/O protocol) with <code class="docutils literal notranslate"><span class="pre">offset=slave</span> <span class="pre">bundle=gmem</span></code>. This interface also has <code class="docutils literal notranslate"><span class="pre">max_write_burst_length=256</span></code>. Part of this AXI4 interface is the Write Address channel containing the signals <code class="docutils literal notranslate"><span class="pre">AWBURST</span></code> and <code class="docutils literal notranslate"><span class="pre">AWLEN</span></code>. This interface has a burst type <code class="docutils literal notranslate"><span class="pre">AWBURST=INCR</span></code> and can support burst length <code class="docutils literal notranslate"><span class="pre">AWLEN</span></code> of 1-256 read transfers. In an incrementing burst, the address for each transfer in the burst is an increment of the previous transfer address. The <code class="docutils literal notranslate"><span class="pre">max_write_burst_length=256</span></code> sets the burst length <code class="docutils literal notranslate"><span class="pre">AWLEN=256</span></code> transfers, meaning that in every transaction (burst), there are 256 transfers of data. The address of each transfer with a size of 16 bytes (128-bits from the mem argument) is the previous address plus 16.</p>
</section>
<section id="id5">
<h4>pragma HLS INTERFACE axis<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h4>
<p>The s2mm kernel has one <code class="docutils literal notranslate"><span class="pre">axis</span></code> interface (specifying an AXI4-Stream I/O protocol)</p>
</section>
<section id="id6">
<h4>pragma HLS PIPELINE II=1<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h4>
<p>The s2mm kernel has a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop that is a candidate for burst write because the memory addresses (mem[i]) are contiguous (memory accesses across loop iterations are consecutive). To pipeline this <code class="docutils literal notranslate"><span class="pre">for</span></code> loop, you can use this pragma by setting the initiation interval (<code class="docutils literal notranslate"><span class="pre">II</span></code>) = 1.</p>
</details><details>
<summary>PS Host Application</summary></section>
</section>
</section>
<section id="ps-host-application">
<h2>PS Host Application<a class="headerlink" href="#ps-host-application" title="Permalink to this heading">¶</a></h2>
<p>The FIR filter HLS(DSP) tutorial uses the embedded PS as an external controller to control the AI Engine graph and data mover PL kernels. Review <a class="reference external" href="#ai-engine-documentation">Programming the PS Host Application Section in the AI Engine Documentation</a> to understand the process to create a host application. Note that unlike the AI Engine implementation, there are no AI Engine graphs and associated control code.</p>
<p>Within the PS host application, two classes are defined ((mm2s_class and s2mm_class), which defines methods used to control and monitor the corresponding kernels.</p>
<p>The main sections of the PS host application code is described in the following subsections:</p>
<section id="define-input-and-output-files">
<h3>Define Input and Output Files<a class="headerlink" href="#define-input-and-output-files" title="Permalink to this heading">¶</a></h3>
<p>A single data file is provides data to stimulate the filter chain.  However, the output data will depend on the value of the makefile parameters N_FIR_FILTERS and N_FIR_TAPS. Data files have been generated for the four corner cases (1 FILTERS / 15 TAPS, 10 FILTERS / 15 TAPS, 1 FILTERS / 240 TAPS, 10 FILTERS / 240 TAPS).  For other configurations, the data is not checked.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &quot;input_data.h&quot;</span>

<span class="c1">#if (N_FIR_FILTERS == 1) &amp;&amp; (N_FIR_TAPS == 15)</span>
<span class="c1">#include &quot;golden_data_1f_15t.h&quot;</span>
<span class="c1">#elif (N_FIR_FILTERS == 10) &amp;&amp; (N_FIR_TAPS == 15)</span>
<span class="c1">#include &quot;golden_data_10f_15t.h&quot;</span>
<span class="c1">#elif (N_FIR_FILTERS == 1) &amp;&amp; (N_FIR_TAPS == 240)</span>
<span class="c1">#include &quot;golden_data_1f_240t.h&quot;</span>
<span class="c1">#elif (N_FIR_FILTERS == 10) &amp;&amp; (N_FIR_TAPS == 240)</span>
<span class="c1">#include &quot;golden_data_10f_240t.h&quot;</span>
<span class="c1">#else</span>
<span class="c1">#include &quot;golden_data_1f_15t.h&quot;</span>
<span class="c1">#endif</span>
</pre></div>
</div>
</section>
<section id="define-data-sizes">
<h3>Define Data Sizes<a class="headerlink" href="#define-data-sizes" title="Permalink to this heading">¶</a></h3>
<p>To enable comparing of the 2 implementations of this design, i.e. AIE and HLS implementation, it is desirable to have a small data set to be able to run it through simulation, and a large data set to run through hardware to minimize the effects of measurement errors on determining the performance metrics.  This has been done by providing a small 8k sample of input data (I and Q samples) in which the data repeats twice. The application code then copies the data into potentially much larger buffer, using REPEAT_OFFSET to determine where the data begins to repeat itself, and REPETITIONS to copy from this point forward to the end of the buffer the specified number of times.  Having two cycles of data and a fixed offset (REPEAT_OFFSET) is necessary to allow the filter’s start-up transient to settle out and reach a steady state for subsequent cycles. Likewise, FLUSH_SAMPLES specifies the number of zero samples to add to the end of the buffer to clear out the FIR filter, so the application can be run multiple times.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define SAMPLES_PER_WORD   4</span>

<span class="c1">#define REPEAT_OFFSET   4096</span>
<span class="c1">#define REPETITIONS      509</span>
<span class="o">//</span><span class="c1">#define REPETITIONS        3</span>
<span class="c1">#define FLUSH_SAMPLES   4096</span>
</pre></div>
</div>
</section>
<section id="load-xclbin-function">
<h3>load_xclbin Function<a class="headerlink" href="#load-xclbin-function" title="Permalink to this heading">¶</a></h3>
<p>This function is responsible for loading the XCLBIN file into the device.</p>
</section>
<section id="mm2s-class">
<h3>mm2s Class<a class="headerlink" href="#mm2s-class" title="Permalink to this heading">¶</a></h3>
<p>This class provides the following methods for controlling / monitoring this kernel:</p>
<ul class="simple">
<li><p>init(): allocates the input data buffer object (BO), opens the kernel, and sets the kernel parameters (location of the buffer object, and its length).</p></li>
<li><p>run(): starts execution of the mm2s kernel</p></li>
<li><p>run_wait(): waits for the mm2s kernel to finish</p></li>
<li><p>close(): closes the input data buffer object and kernel</p></li>
<li><p>load(): loads data from the input file into the data buffer, using REPEAT_OFFSET, REPETITIONS and FLUSH_SAMPLES to potentially generate a much larger data set than the input file (see #define-data-sizes).</p></li>
</ul>
</section>
<section id="s2mm-class">
<h3>s2mm Class<a class="headerlink" href="#s2mm-class" title="Permalink to this heading">¶</a></h3>
<p>This class provides the following methods for controlling / monitoring this kernel:</p>
<ul class="simple">
<li><p>init(): allocates the output data buffer object (BO), opens the kernel, and sets the kernel parameters (location of the buffer object, and its length).</p></li>
<li><p>run(): starts execution the s2mm kernel</p></li>
<li><p>run_wait(): waits for the s2mm kernel to finish
Note: This call will only return once it receives the number of samples specified computed in the init function. If the application code hangs at this point, it is waiting from data from the filter chain.</p></li>
<li><p>close(): closes the output data buffer object and kernel</p></li>
<li><p>golden_check():  Compare data in the output data buffer object with the data from the output file, using REPEAT_OFFSET and REPETITIONS to compare the data correctly(see #define-data-sizes).</p></li>
</ul>
</section>
<section id="main-function">
<h3>Main Function<a class="headerlink" href="#main-function" title="Permalink to this heading">¶</a></h3>
<p>This is the main PS application code that controls the kernels and runs data through the design. The various steps this code goes through is described in the following subsections.</p>
<section id="check-command-line-argument">
<h4>1. Check Command Line Argument<a class="headerlink" href="#check-command-line-argument" title="Permalink to this heading">¶</a></h4>
<p>The beginning of the A72 application is represented by the main function. It takes in one command line argument: an XCLBIN file.</p>
</section>
<section id="open-xclbin">
<h4>2. Open XCLBIN<a class="headerlink" href="#open-xclbin" title="Permalink to this heading">¶</a></h4>
<p>The A72 application loads the XCLBIN binary file and creates the data mover kernels to be executed on the device.</p>
</section>
<section id="create-and-initialize-data-mover-kernels">
<h4>3. Create and Initialize Data Mover Kernels<a class="headerlink" href="#create-and-initialize-data-mover-kernels" title="Permalink to this heading">¶</a></h4>
<p>Create the kernel objects, initialize them, and load the input data from the constant array into the input buffer.</p>
</section>
<section id="run-data-mover-kernels">
<h4>4. Run Data Mover Kernels<a class="headerlink" href="#run-data-mover-kernels" title="Permalink to this heading">¶</a></h4>
<p>Start execution of the mm2s/s2mm kernels.</p>
</section>
<section id="wait-for-data-mover-kernels-to-complete">
<h4>5. Wait for Data Mover Kernels to Complete<a class="headerlink" href="#wait-for-data-mover-kernels-to-complete" title="Permalink to this heading">¶</a></h4>
<p>Wait for the mm2s and s2mm kernels to complete.</p>
</section>
<section id="verify-output-results">
<h4>6. Verify Output Results<a class="headerlink" href="#verify-output-results" title="Permalink to this heading">¶</a></h4>
<p>Compare data in <code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">buffer</span></code> object with the reference golden data.</p>
</section>
<section id="release-allocated-resources">
<h4>7. Release Allocated Resources<a class="headerlink" href="#release-allocated-resources" title="Permalink to this heading">¶</a></h4>
<p>Close the mm2s and s2mm kernel objects.</p>
</details></section>
</section>
</section>
</section>
<section id="references">
<h1>References<a class="headerlink" href="#references" title="Permalink to this heading">¶</a></h1>
<p>The following documents provide supplemental information for this tutorial.</p>
<section id="ai-engine-documentation">
<h2><a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/yii1603912637443.html">AI Engine Documentation</a><a class="headerlink" href="#ai-engine-documentation" title="Permalink to this heading">¶</a></h2>
<p>Contains sections on how to develop AI Engine graphs, how to use the AI Engine compiler, AI Engine simulation, and performance analysis.</p>
</section>
<section id="vitis-fir-filter-ip-library">
<h2><a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/hls_ip_libraries.html#aqn1539734237760">Vitis FIR Filter IP Library</a><a class="headerlink" href="#vitis-fir-filter-ip-library" title="Permalink to this heading">¶</a></h2>
<p>Describes how to use the FIR Filter IP Library, which is basically a C++ wrapper that instantiates the Xilinx FIR Compiler</p>
</section>
<section id="fir-compiler-v7-2">
<h2><a class="reference external" href="https://www.xilinx.com/support/documentation/ip_documentation/fir_compiler/v7_2/pg149-fir-compiler.pdf"> FIR Compiler v7.2</a><a class="headerlink" href="#fir-compiler-v7-2" title="Permalink to this heading">¶</a></h2>
<p>Describes the FIR Compiler IP describes all of the parameters and settings and how they control the final filter implementation.</p>
</section>
</section>
<section id="revision-history">
<h1>Revision History<a class="headerlink" href="#revision-history" title="Permalink to this heading">¶</a></h1>
<ul class="simple">
<li><p>Jul 2021 - Initial Release</p></li>
</ul>
</section>
<section id="support">
<h1>Support<a class="headerlink" href="#support" title="Permalink to this heading">¶</a></h1>
<p>GitHub issues will be used for tracking requests and bugs. For questions go to <a class="reference external" href="http://forums.xilinx.com/">forums.xilinx.com</a>.</p>
</section>
<section id="license">
<h1>License<a class="headerlink" href="#license" title="Permalink to this heading">¶</a></h1>
<p>Licensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License.</p>
<p>You may obtain a copy of the License at <a class="reference external" href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p align="center"><sup>XD061 | &copy; Copyright 2021 Xilinx, Inc.</sup></p></section>


           </div>
          </div>
          
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
				  
				  <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, Xilinx, Inc. Xilinx is now a part of AMD.
      <span class="lastupdated">Last updated on July 27, 2022.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="https://pages.gitenterprise.xilinx.com/techdocs/Test/vvas/build/html/index.html#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>