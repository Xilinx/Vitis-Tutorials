<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
  <title>Video Convolution Filter: Introduction and Performance Estimation &mdash; Vitis™ Tutorials 2021.1 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../../../../index.html" class="icon icon-home"> Vitis™ Tutorials
            <img src="../../../../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2021.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">日本語版</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/master/docs-jp/index.html">Master</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Getting_Started/Vitis-Getting-Started.html">Getting Started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Acceleration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Hardware-Acceleration.html">Hardware Acceleration</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">AI Engine</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../AI_Engine_Development/AI_Engine_Development.html">AI Engine Development</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Platforms</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Vitis_Platform_Creation/Vitis_Platform_Creation.html">Vitis Platform Creation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/index.html">Main</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2021-2/build/html/index.html">2021.2</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-2/docs/build/html/index.html">2020.2</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-1/docs/build/html/README.html">2020.1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Vitis™ Tutorials</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Video Convolution Filter: Introduction and Performance Estimation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/docs/Hardware_Acceleration/Design_Tutorials/01-convolution-tutorial/lab1_app_introduction_performance_estimation.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>﻿<table class="sphinxhide"></p>
 <tr>
   <td align="center"><img src="https://raw.githubusercontent.com/Xilinx/Image-Collateral/main/xilinx-logo.png" width="30%"/><h1>2021.1 Vitis™ Application Acceleration Development Flow Tutorials</h1>
   <a href="https://github.com/Xilinx/Vitis-Tutorials/tree/2020.2">See 2020.2 Vitis Application Acceleration Development Flow Tutorials</a>
   </td>
 </tr>
 <tr>
 <td>
 </td>
 </tr>
</table><div class="section" id="video-convolution-filter-introduction-and-performance-estimation">
<h1>Video Convolution Filter: Introduction and Performance Estimation<a class="headerlink" href="#video-convolution-filter-introduction-and-performance-estimation" title="Permalink to this heading">¶</a></h1>
<p>This lab will explore a 2D video convolution filter and measure its performance on the host machine. These measurements will establish a performance baseline. The amount of acceleration that should be provided by hardware implementation is calculated based on the required performance constraints. In the next lab, we will estimate the performance of the FPGA accelerator. In a nutshell, during this lab, you will:</p>
<ul class="simple">
<li><p>Learn about video convolution filters</p></li>
<li><p>Measure the performance of software implemented convolution filter</p></li>
<li><p>Calculate required acceleration vs. software implementation for given performance constraints</p></li>
<li><p>Estimate the performance of hardware accelerator before implementation</p></li>
</ul>
<div class="section" id="video-filtering-applications-and-2-d-convolution-filters">
<h2>Video Filtering Applications and 2-D Convolution Filters<a class="headerlink" href="#video-filtering-applications-and-2-d-convolution-filters" title="Permalink to this heading">¶</a></h2>
<p>Video applications use different types of filters extensively for multiple reasons: filter noise, manipulate motion blur, enhance color and contrast, edge detection, creative effects, etc. At its core, a convolution video filter carries out some form of data average around a pixel, which redefines the amount and type of correlation any pixel has to its surrounding area. Such filtering is carried out for all the pixels in a video frame.</p>
<p>A matrix of coefficients defines a convolution filter. The convolution operation is essentially a sum of products performed on a pixel set (a frame/image sub-matrix centered around a given pixel) and a coefficients matrix. The figure below illustrates how convolution is calculated for a pixel; it is highlighted in yellow. Here the filter has a coefficient matrix that is 3x3 in size. The figure also displays how the whole output image is generated during the filtering process. The index of the output pixel being generated is the index of the input pixel highlighted in yellow that is being filtered. In algorithmic terms, the process of filtering consists of:</p>
<ul class="simple">
<li><p>Selecting an input pixel as highlighted in yellow in the figure below</p></li>
<li><p>Extracting a sub-matrix whose size is the same as filter coefficients</p></li>
<li><p>Calculating element-wise sum-of-product of extracted sub-matrix and coefficients matrix</p></li>
<li><p>Placing the sum-of-product as output pixel in output image/frame on the same index as the input pixel</p></li>
</ul>
<p><img alt="Convolution Filter" src="../../../../_images/convolution.jpg" /></p>
<div class="section" id="performance-requirements-for-1080p-hd-video">
<h3>Performance Requirements for 1080p HD Video<a class="headerlink" href="#performance-requirements-for-1080p-hd-video" title="Permalink to this heading">¶</a></h3>
<p>You can easily calculate the application performance requirements given the standard performance specs for 1080p High Definition (HD) video. Then these top-level requirements can be translated into constraints for hardware implementation or software throughput requirements. For 1080p HD video at 60 frames per seconds(FPS) the specs are listed below as well as required throughput in terms of pixels per second is calculated:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Video <span class="nv">Resolution</span>        <span class="o">=</span> <span class="m">1920</span> x <span class="m">1080</span>
Frame Width <span class="o">(</span>pixels<span class="o">)</span>    <span class="o">=</span> <span class="m">1920</span> 
Frame Height <span class="o">(</span>pixels<span class="o">)</span>   <span class="o">=</span> <span class="m">1080</span> 
Frame Rate<span class="o">(</span>FPS<span class="o">)</span>         <span class="o">=</span> <span class="m">60</span> 
Pixel Depth<span class="o">(</span>Bits<span class="o">)</span>       <span class="o">=</span> <span class="m">8</span> 
Color Channels<span class="o">(</span>YUV<span class="o">)</span>     <span class="o">=</span> <span class="m">3</span> 
Throughput<span class="o">(</span>Pixel/s<span class="o">)</span>   <span class="o">=</span> Frame Width * Frame Height * Channels * FPS
Throughput<span class="o">(</span>Pixel/s<span class="o">)</span>   <span class="o">=</span> <span class="m">1920</span>*1080*3*60
Throughput <span class="o">(</span>MB/s<span class="o">)</span>     <span class="o">=</span> <span class="m">373</span> MB/s
</pre></div>
</div>
<p>The required throughput to meet 60 FPS performance turns out to be 373 MB/s ( since each pixel is 8-bits).</p>
</div>
</div>
<div class="section" id="software-implementation">
<h2>Software Implementation<a class="headerlink" href="#software-implementation" title="Permalink to this heading">¶</a></h2>
<p>This section will discuss the baseline software implementation and performance measurements, which will be used to gauge the acceleration requirements given the performance constraints.</p>
<p>The convolution filter is implemented in software using a typical multi-level nested loop structure. Outer two loops define the pixel to be processed(iterating over each pixel). The inner two loops perform the sum-of-product (SOP) operation, actual convolution filtering between the coefficient matrix and the selected sub-matrix from the image centered around the processed pixel.</p>
<p><strong>TIP:</strong> Boundary conditions where it is not possible to center sub-matrix around a given pixel require special processing.  This algorithm assumes all pixels beyond the boundary of the image have zero values.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Filter2D</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">           </span><span class="n">coeffs</span><span class="p">[</span><span class="n">FILTER_V_SIZE</span><span class="p">][</span><span class="n">FILTER_H_SIZE</span><span class="p">],</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w">                </span><span class="n">factor</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">short</span><span class="w">                </span><span class="n">bias</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">       </span><span class="n">width</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">       </span><span class="n">height</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">       </span><span class="n">stride</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">       </span><span class="o">*</span><span class="n">dst</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">&lt;</span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">y</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">&lt;</span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Apply 2D filter to the pixel window</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">row</span><span class="o">&lt;</span><span class="n">FILTER_V_SIZE</span><span class="p">;</span><span class="w"> </span><span class="n">row</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">col</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">col</span><span class="o">&lt;</span><span class="n">FILTER_H_SIZE</span><span class="p">;</span><span class="w"> </span><span class="n">col</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">pixel</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="kt">int</span><span class="w"> </span><span class="n">xoffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">col</span><span class="o">-</span><span class="p">(</span><span class="n">FILTER_H_SIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">                    </span><span class="kt">int</span><span class="w"> </span><span class="n">yoffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">row</span><span class="o">-</span><span class="p">(</span><span class="n">FILTER_V_SIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">                    </span><span class="c1">// Deal with boundary conditions : clamp pixels to 0 when outside of image </span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">xoffset</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">xoffset</span><span class="o">&gt;=</span><span class="n">width</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">yoffset</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">yoffset</span><span class="o">&gt;=</span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="n">pixel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                        </span><span class="n">pixel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">[</span><span class="n">yoffset</span><span class="o">*</span><span class="n">stride</span><span class="o">+</span><span class="n">xoffset</span><span class="p">];</span><span class="w"></span>
<span class="w">                    </span><span class="p">}</span><span class="w"></span>
<span class="w">                    </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">pixel</span><span class="o">*</span><span class="n">coeffs</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">];</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span>
<span class="w">            </span><span class="c1">// Normalize and saturate result</span>
<span class="w">            </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">outpix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MIN</span><span class="p">(</span><span class="n">MAX</span><span class="p">((</span><span class="kt">int</span><span class="p">(</span><span class="n">factor</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sum</span><span class="p">)</span><span class="o">+</span><span class="n">bias</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="mi">255</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="c1">// Write output</span>
<span class="w">            </span><span class="n">dst</span><span class="p">[</span><span class="n">y</span><span class="o">*</span><span class="n">stride</span><span class="o">+</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outpix</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The following snapshot shows how the top-level function calls the convolution filter function for an image with three components or channels. Here OpenMP pragma is used to parallelize software execution using multiple threads. You can open <strong><em>src/host_randomized.cpp</em></strong> and <strong><em>src/filter2d_sw.cpp</em></strong> from tutorial directory to examine all implementation details.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="cp">#pragma omp parallel for num_threads(3)</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">&lt;</span><span class="n">numRunsSW</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Compute reference results</span>
<span class="w">    </span><span class="n">Filter2D</span><span class="p">(</span><span class="n">filterCoeffs</span><span class="p">[</span><span class="n">filterType</span><span class="p">],</span><span class="w"> </span><span class="n">factor</span><span class="p">,</span><span class="w"> </span><span class="n">bias</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">stride</span><span class="p">,</span><span class="w"> </span><span class="n">y_src</span><span class="p">,</span><span class="w"> </span><span class="n">y_ref</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">Filter2D</span><span class="p">(</span><span class="n">filterCoeffs</span><span class="p">[</span><span class="n">filterType</span><span class="p">],</span><span class="w"> </span><span class="n">factor</span><span class="p">,</span><span class="w"> </span><span class="n">bias</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">stride</span><span class="p">,</span><span class="w"> </span><span class="n">u_src</span><span class="p">,</span><span class="w"> </span><span class="n">u_ref</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">Filter2D</span><span class="p">(</span><span class="n">filterCoeffs</span><span class="p">[</span><span class="n">filterType</span><span class="p">],</span><span class="w"> </span><span class="n">factor</span><span class="p">,</span><span class="w"> </span><span class="n">bias</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">stride</span><span class="p">,</span><span class="w"> </span><span class="n">v_src</span><span class="p">,</span><span class="w"> </span><span class="n">v_ref</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="running-the-software-application">
<h3>Running the Software Application<a class="headerlink" href="#running-the-software-application" title="Permalink to this heading">¶</a></h3>
<p>To run the software application, go to the directory called “sw_run” and launch the application as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> <span class="nv">$CONV_TUTORIAL_DIR</span>/sw_run
./run.sh
</pre></div>
</div>
<p>Once the application is launched, it should produce an output similar to the one shown below. The software application will process a randomly generated set of images and report performance. Here you have used randomly generated images to avoid any extra library dependencies such as OpenCV. But in the next labs, while working with the hardware implementation, the option to use the OpenCV library for loading images or use randomly generated images will be provided given the user has OpenCV 2.4 installed on the machine. If another version of OpenCV is needed, the user can modify the host application to use different APIs to load and store images from the disk.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>----------------------------------------------------------------------------
Number of runs    : <span class="m">60</span>
Image width       : <span class="m">1920</span>
Image height      : <span class="m">1080</span>
Filter <span class="nb">type</span>       : <span class="m">6</span>

Generating a random 1920x1080 input image
Running Software version on <span class="m">60</span> images

CPU  Time         :    <span class="m">24</span>.4447 s
CPU  Throughput   :    <span class="m">14</span>.5617 MB/s
----------------------------------------------------------------------------
</pre></div>
</div>
<p>The application run measures performance using high precision timers and reports it as throughput. The machine used for experiments produced a throughput of 14.51 MB/s. The  machine details are listed below:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>    CPU Model : Intel<span class="o">(</span>R<span class="o">)</span> Xeon<span class="o">(</span>R<span class="o">)</span> CPU E5-1650 v2 @ <span class="m">3</span>.50GHz
    RAM       : <span class="m">64</span> GB
</pre></div>
</div>
<p>The measured performance is <strong><em>“2.34 FPS”</em></strong> only, whereas the required throughput is <strong>60 FPS</strong>. The acceleration needed to meet the required performance of 60 FPS:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>   Acceleration <span class="nv">Factor</span> <span class="o">=</span> Throughput <span class="o">(</span>Required<span class="o">)</span>/Throughput<span class="o">(</span>SW only<span class="o">)</span>
   Acceleration <span class="nv">Factor</span> <span class="o">=</span> <span class="m">373</span>/14.56 <span class="o">=</span> <span class="m">25</span>.6X
</pre></div>
</div>
<p>So to meet the required performance of processing 60 frames per second, the software implementation needs to be accelerated by a factor of 26x.</p>
</div>
</div>
<div class="section" id="hardware-implementation">
<h2>Hardware Implementation<a class="headerlink" href="#hardware-implementation" title="Permalink to this heading">¶</a></h2>
<p>To understand what kind of hardware implementation is needed given the performance constraints, you can examine the convolution kernel in some detail:</p>
<ul class="simple">
<li><p>The core compute is done in a 4-level nested loop, but you can break it to the compute per output pixel produced.</p></li>
<li><p>In terms of the output-pixels produced, it is clear from the filter source code that a single output pixel is produced when the inner two loops finish execution once.</p></li>
<li><p>These two loops are essentially doing the sum-of-product on a coefficient matrix and image sub-matrix. The matrix sizes are defined by the coefficient matrix, which is 15x15.</p></li>
<li><p>The inner two loops are performing a dot product of size 225(15x15). In other words, the two inner loops perform 225 multiply-accumulate (MAC) operations for every output pixel produced.</p></li>
</ul>
<div class="section" id="baseline-hardware-implementation-performance">
<h3>Baseline Hardware Implementation Performance<a class="headerlink" href="#baseline-hardware-implementation-performance" title="Permalink to this heading">¶</a></h3>
<p>The simplest and most straightforward hardware implementation can be achieved by passing this current kernel source code through the Vitis HLS tool. It will pipeline the innermost loop with II=1, performing only one multiply-accumulate(MAC) per cycle. The performance can be estimated based on the MACs as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span> MACs per <span class="nv">Cycle</span> <span class="o">=</span> <span class="m">1</span>
 Hardware Fmax<span class="o">(</span>MHz<span class="o">)</span> <span class="o">=</span> <span class="m">300</span>
 <span class="nv">Throughput</span>  <span class="o">=</span> <span class="m">300</span>/225 <span class="o">=</span> <span class="m">1</span>.33 <span class="o">(</span>MPixels/s<span class="o">)</span> <span class="o">=</span>  <span class="m">1</span>.33 MB/s
</pre></div>
</div>
<p>Here the hardware clock frequency is assumed to be 300MHz because, in general, for the U200 Xilinx Alveo Data Center card, this is the maximum supported clock frequency when using Vitis HLS based design flow. The performance turns out to be 1.33 MB/s with baseline hardware implementation. From the convolution filter source code, it can also be estimated how much memory bandwidth is needed at the input and output for achieved throughput. From the convolution filter source code also shown above, it is clear that the inner two loops, while calculating a single output pixel, performs 225(15*15) reads at the input so:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Output Memory <span class="nv">Bandwidth</span> <span class="o">=</span> <span class="nv">Throughput</span> <span class="o">=</span> <span class="m">1</span>.33 MB/s
Input Memory <span class="nv">Bandwidth</span>  <span class="o">=</span> Throughput * <span class="nv">225</span> <span class="o">=</span> <span class="m">300</span> MB/s
</pre></div>
</div>
<p>For the baseline implementation, the memory bandwidth requirements are very trivial, assuming that PCIe and device DDR memory bandwidths on Xilinx Acceleration Cards/Boards are of the order of 10s of GB/s.
As you have seen in previous sections, the throughput required for 60FPS 1080p HD video is 373 MB/s. So it clear that to meet the performance requirement:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Acceleration Factor to Meet 60FPS <span class="nv">Performance</span> <span class="o">=</span> <span class="m">373</span>/1.33 <span class="o">=</span> 280x
Acceleration Factor to Meet SW <span class="nv">Performance</span>    <span class="o">=</span> <span class="m">14</span>.5/1.33 <span class="o">=</span> <span class="m">10</span>.9x
</pre></div>
</div>
</div>
<div class="section" id="performance-estimation-for-optimized-hardware-implementations">
<h3>Performance Estimation for Optimized Hardware Implementations<a class="headerlink" href="#performance-estimation-for-optimized-hardware-implementations" title="Permalink to this heading">¶</a></h3>
<p>From the above calculations, it is clear that you need to improve the performance of a baseline hardware implementation by 280x to process 60 FPS. One of the paths you can take is to start unrolling the inner loops and pipeline. For example, by unrolling the innermost loop, which iterates 15 times, you can improve the performance by 15x. With that one change, the hardware performance will already be better than software-only implementation, but not yet good enough to meet the required video performance. Another approach you can follow is to unroll the inner two loops and gain in performance by 15*15=225, which means a throughput of 1-output pixel per cycle. The performance and memory bandwidth requirements will be as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">Throughput</span>  <span class="o">=</span> Fmax * Pixels produced per <span class="nv">cycle</span> <span class="o">=</span> <span class="m">300</span> * <span class="nv">1</span> <span class="o">=</span> <span class="m">300</span> MB/s
Output Memory <span class="nv">Bandwidth</span> <span class="o">=</span> Fmax * Pixels produced per <span class="nv">cycle</span> <span class="o">=</span>  <span class="m">300</span> MB/s
Input Memory <span class="nv">Bandwidth</span> <span class="o">=</span> Fmax * Input pixels <span class="nb">read</span> per output <span class="nv">pixel</span> <span class="o">=</span> <span class="m">300</span> * <span class="nv">225</span> <span class="o">=</span> <span class="m">67</span>.5 GB/s
</pre></div>
</div>
<p>The required output memory bandwidth scales linearly with throughput, but input memory bandwidth has gone up enormously and might not be sustainable. A closer look at the convolution filter will reveal that it is not required to read all 225(15x15) pixels from the input memory for processing. An innovative caching scheme can be built to avoid such extensive use of input memory bandwidth.</p>
<p>The convolution filter belongs to a class of kernels known as stencil kernels, which can be optimized to increase input data reuse extensively. Which can result in substantially reduced memory bandwidth requirements. With a caching scheme, you can bring the input bandwidth required to be the same as output, which is around 300 MB/s. With the optimized data reuse scheme, when both inner loops are unrolled, it will require that only 1-input pixel is read for producing one output pixel on average and hence input memory bandwidth of 300 MB/s.</p>
<p>Although you can reduce the input bandwidth, the achieved performance will still only be 300 MB/s, which is less than the required 373 MB/s. To deal with this, you can look for other ways to increase the throughput of hardware. One approach is to duplicate kernel instances, also called compute units. In terms of heterogeneous computing, you can increase the number of compute units so that you can process data in parallel. In the convolution filter case, you can process all color channels (YUV) on separate compute units. When using three compute units, one for each color channel, the expected performance summary will be as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span> Throughput<span class="o">(</span>estimated<span class="o">)</span>  <span class="o">=</span> Performance of Single Compute Unit * No. Compute <span class="nv">Units</span> <span class="o">=</span> <span class="m">300</span> x <span class="nv">3</span> <span class="o">=</span> <span class="m">900</span> MB/s
 Acceleration Against Software <span class="nv">Implementation</span> <span class="o">=</span> <span class="m">900</span>/14.5 <span class="o">=</span> 62x
 Kernel Latency <span class="o">(</span> per image on any color channel <span class="o">)</span> <span class="o">=</span> <span class="o">(</span><span class="m">1920</span>*1080<span class="o">)</span> / <span class="nv">300</span> <span class="o">=</span> <span class="m">6</span>.9 ms
 Video Processing <span class="nv">Rate</span> <span class="o">=</span> <span class="o">(</span><span class="m">1</span>/Kernel Latency<span class="o">)</span> <span class="o">=</span> <span class="m">144</span>  FPS   
</pre></div>
</div>
<p>In this lab, you have learned about:</p>
<ul class="simple">
<li><p>Basics of convolution filter</p></li>
<li><p>Profiled the performance of a software-only implementation</p></li>
<li><p>Estimated the performance and requirements for hardware implementations</p></li>
</ul>
<p>Given these performance numbers, architecture selection, and implementation details, the next lab will show how you can design the kernel hardware and end up with an accelerated application that provides performance very close to these estimates.</p>
<hr class="docutils" />
<p align="center"><b>
Next Lab Module: <a href="./lab2_conv_filter_kernel_design.md">Design and Analysis of Hardware Kernel Module for 2-D Video Convolution Filter</a>
<p class="sphinxhide" align="center"><sup>Copyright&copy; 2020-2021 Xilinx</sup></p>
</b></p></div>
</div>
</div>


           </div>
          </div>
          
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
				  
				  <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, Xilinx, Inc. Xilinx is now a part of AMD.
      <span class="lastupdated">Last updated on July 27, 2022.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>