<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" /><!-- OneTrust Cookies Consent Notice start for xilinx.github.io --><script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script><!-- OneTrust Cookies Consent Notice end for xilinx.github.io --><title>ホスト コードの最適化 - Vitis™ チュートリアル 2022.1 の資料</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/_static/custom.css" type="text/css" /><!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]--><script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Using Aurora IP in Alveo with Vitis Flow" href="../08-alveo_aurora_kernel/README.html" />
    <link rel="prev" title="Vitis Hardware Acceleration on Cholesky Algorithm" href="../06-cholesky-accel/README.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"><a href="../../../../index.html" class="icon icon-home">Vitis™ チュートリアル <img src="../../../../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/> </a><div class="version">2022.1</div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">English</span></p><ul><li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/master/docs/index.html">Main</a></li></ul><p class="caption" role="heading"><span class="caption-text">入門</span></p><ul><li class="toctree-l1"><a class="reference internal" href="../../../Getting_Started/Vitis-Getting-Started.html">概要</a></li></ul><p class="caption" role="heading"><span class="caption-text">アクセラレーション</span></p><ul class="current"><li class="toctree-l1 current"><a class="reference internal" href="../../Hardware-Acceleration.html">ハードウェア アクセラレーション</a><ul class="current"><li class="toctree-l2"><a class="reference internal" href="../../Hardware-Acceleration.html#introduction">入門</a></li><li class="toctree-l2 current"><a class="reference internal" href="../../Hardware-Acceleration.html#design-tutorials">設計チュートリアル</a><ul class="current"><li class="toctree-l3"><a class="reference internal" href="../02-bloom/README.html">ブルーム フィルターの例</a></li><li class="toctree-l3"><a class="reference internal" href="../01-convolution-tutorial/README.html">たたみ込みの例</a></li><li class="toctree-l3"><a class="reference internal" href="../03-rtl_stream_kernel_integration/README.html">RTL システム統合の例</a></li><li class="toctree-l3"><a class="reference internal" href="../04-traveling-salesperson/README.html">巡回セールスパーソン問題</a></li><li class="toctree-l3"><a class="reference internal" href="../05-bottom_up_rtl_kernel/README.html">ボトム RTL カーネルのデザイン フローの例</a></li><li class="toctree-l3"><a class="reference internal" href="../06-cholesky-accel/README.html">コレスキー アルゴリズム アクセラレーション</a></li><li class="toctree-l3 current"><a class="current reference internal" href="#">XRT ホスト コードの最適化</a><ul><li class="toctree-l4"><a class="reference internal" href="#入門チュートリアル">入門</a></li><li class="toctree-l4"><a class="reference internal" href="#tutorial-overview">チュートリアルの概要</a></li><li class="toctree-l4"><a class="reference internal" href="#before-you-begin">開始前の確認事項</a></li><li class="toctree-l4"><a class="reference internal" href="#model">モデル</a></li><li class="toctree-l4"><a class="reference internal" href="#building-the-device-binary-xclbin">デバイス バイナリ (xclbin) のビルド</a></li><li class="toctree-l4"><a class="reference internal" href="#host-code">ホスト コード</a></li><li class="toctree-l4"><a class="reference internal" href="#conclusion">まとめ</a></li><li class="toctree-l4"><a class="reference internal" href="#next-steps">再実装手順</a></li></ul></li><li class="toctree-l3"><a class="reference internal" href="../08-alveo_aurora_kernel/README.html">Alveo の Aurora カーネル</a></li></ul></li><li class="toctree-l2"><a class="reference internal" href="../../Hardware-Acceleration.html#feature-tutorials">機能チュートリアル</a></li></ul></li></ul><p class="caption" role="heading"><span class="caption-text">AI エンジン</span></p><ul><li class="toctree-l1"><a class="reference internal" href="../../../AI_Engine_Development/AI_Engine_Development.html">AI エンジン開発</a></li></ul><p class="caption" role="heading"><span class="caption-text">プラットフォーム</span></p><ul><li class="toctree-l1"><a class="reference internal" href="../../../Vitis_Platform_Creation/Vitis_Platform_Creation.html">Vitis プラットフォームの作成</a></li></ul><p class="caption" role="heading"><span class="caption-text">その他のバージョン</span></p><ul><li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2021-2/build/html/index.html">2021.2</a></li><li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2021-1/build/html/index.html">2021.1</a></li><li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-2/docs/build/html/index.html">2020.2</a></li><li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-1/docs/build/html/indexE.html">2020.1</a></li></ul></div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" ><i data-toggle="wy-nav-top" class="fa fa-bars"></i> <a href="../../../../index.html">Vitis™ チュートリアル</a></nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation"><ul class="wy-breadcrumbs"><li><a href="../../../../index.html" class="icon icon-home"></a>&raquo;</li> <li><a href="../../Hardware-Acceleration.html">Vitis ハードウェア アクセラレータ</a> &raquo;</li><li>ホスト コードの最適化</li><li class="wy-breadcrumbs-aside"><a href="../../../../_sources/docs/Hardware_Acceleration/Design_Tutorials/07-host-code-opt/README.md.txt" rel="nofollow">ページ ソースの表示</a></li></ul><hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <table width="100%">
 <tr width="100%">
    <td align="center"><img src="https://raw.githubusercontent.com/Xilinx/Image-Collateral/main/xilinx-logo.png" width="30%"/><h1>Vitis™ ハードウェア アクセラレーション チュートリアル</h1><a href="https://japan.xilinx.com/products/design-tools/vitis.html">xilinx.com の Vitis™ 開発環境を参照</a></td>
 </tr>
</table><div class="section" id="host-code-optimization">
<h1>ホスト コードの最適化<a class="headerlink" href="#host-code-optimization" title="Permalink to this heading">¶</a></h1>
<p><em><strong>バージョン: Vitis 2022.1</strong></em></p>
<div class="section" id="introduction">
<h2>入門チュートリアル<a class="headerlink" href="#入門チュートリアル" title="Permalink to this heading"></a></h2>
<p>このチュートリアルでは、FPGA アクセラレーション アプリケーションに関連するホスト コードのパフォーマンスを調整する方法について説明します。ホスト コードの最適化は、パフォーマンス最適化の 1 つにすぎません。ホスト コードの最適化には、次の最適化が含まれます。</p><ul class="simple"> <li><p>ホスト プログラムの最適化</p></li> <li><p>カーネル コードの最適化</p></li> <li><p>トポロジの最適化</p></li> <li><p>インプリメンテーションの最適化</p></li> </ul>
</div>
<div class="section" id="tutorial-overview">
<h2>チュートリアルの概要<a class="headerlink" href="#tutorial-overview" title="Permalink to this heading">¶</a></h2>
<p>このチュートリアルでは、1 つの単純な C++ カーネル インプリメンテーションを使用することにより、ホスト コード インプリメンテーションの解析からカーネル コードの修正、トポロジの最適化、およびインプリメンテーションの選択に関する要素を取り除いています。</p>
<blockquote>
<div><p><strong>注記:</strong> このチュートリアルでは、ホスト コード最適化手法のアクセラレータの統合を最適化する点についてのみ説明します。複数の CPU コアの使用、ホスト コードでのメモリの管理など、その他のよく使用される手法については説明しません。詳細は、『Vitis 統合ソフトウェア プラットフォームの資料』 (UG1416) のアプリケーション アクセラレーション開発フローの<a class="reference external" href="https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration/Profiling-Optimizing-and-Debugging-the-Application">アプリケーションのプロファイル、最適化、およびデバッグ</a>を参照してください。</p>
</div></blockquote>
<p>次のセクションでは、ホスト コードの最適化に関する次の注意点について説明します。</p><ul class="simple"> <li><p>ソフトウェア パイプライン/イベント キュー</p></li> <li><p>カーネルおよびホスト コードを同期</p></li> <li><p>バッファー サイズ</p></li> </ul>
</div>
<div class="section" id="before-you-begin">
<h2>開始前の確認事項<a class="headerlink" href="#before-you-begin" title="Permalink to this heading">¶</a></h2>
<p>このチュートリアルでは、次を使用します。</p><ul class="simple"> <li><p>BASH Linux シェル コマンド</p></li> <li><p>2022.1 Vitis コア開発キット リリースおよび <em>xilinx_u200_gen3x16_xdma_2_202110_1</em> プラットフォーム。<br />必要であれば、ほかのバージョンおよびプラットフォームを使用するように変更することもできます。</p></li> </ul>
<blockquote>
<div><p><strong>重要:</strong></p><ul class="simple"> <li><p>例を実行する前に、『Vitis 統合ソフトウェア プラットフォームの資料』 (UG1416) のアプリケーション アクセラレーション開発フローの<a class="reference external" href="https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration/Installation">インストール</a>の手順に従って、Vitis コア開発キットをインストールしてください。</p></li> <li><p>ザイリンクス Alveo™ データセンター アクセラレータ カードでアプリケーションを実行する場合は、<a class="reference external" href="https://japan.xilinx.com/products/boards-and-kits/alveo.html">Alveo ポートフォリオ</a> ページの手順に従って、カードとソフトウェア ドライバーを正しくインストールしてください。</p></li> </ul>
</div></blockquote>
<div class="section" id="accessing-the-tutorial-reference-files">
<h3>チュートリアル リファレンス ファイルの入手<a class="headerlink" href="#accessing-the-tutorial-reference-files" title="Permalink to this heading">¶</a></h3>
<ol class="simple"><li><p>リファレンス ファイルを入手するには、ターミナルに <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">clone</span> <span class="pre">https://github.com/Xilinx/Vitis-Tutorials</span></code> と入力します。</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">Hardware_Acceleration/Design_Tutorials/07-host-code-opt</span></code> ディレクトリに移動し、<code class="docutils literal notranslate"><span class="pre">reference-files</span></code> ディレクトリにアクセスします。</p></li></ol>
</div>
</div>
<div class="section" id="model">
<h2>モデル<a class="headerlink" href="#model" title="Permalink to this heading">¶</a></h2>
<p>この例では、カーネルはホスト コードを最適化するためにのみ作成します。ホスト コードの最適化の影響がわかるように、このチュートリアル全体で同じものを使用します。</p><!--this could be better suited as a table--><p>C++ カーネルには、入力ポートと出力ポートが 1 つずつあります。これらのポートの幅は、AXI 帯域幅を最適に使用するため、512 ビットにしています。実行ごとにカーネルで消費される要素数は、<code class="docutils literal notranslate"><span class="pre">numInputs</span></code> パラメーターで設定できます。同様に、<code class="docutils literal notranslate"><span class="pre">processDelay</span></code> パラメーターを使用すると、カーネルのレイテンシを変更できます。このアルゴリズムは、入力値を <code class="docutils literal notranslate"><span class="pre">ProcessDelay</span></code> の値分増加しますが、これは、入力値を 1 回に 1 ずつ、<code class="docutils literal notranslate"><span class="pre">processDelay</span></code> 回増加するループを実行することによりインプリメントされます。このループはカーネル インプリメンテーション内にあるので、反復ごとに一定量のサイクル数が必要で、これを <code class="docutils literal notranslate"><span class="pre">processDelay</span></code>  値で乗算できます。</p>
<p>カーネルでは、AXI バースト転送もイネーブルにできます。カーネルには読み出しおよび書き込みプロセスが含まれ、プロセスの終わりの方で実際のカーネル アルゴリズム (<code class="docutils literal notranslate"><span class="pre">exec</span></code>) と並列に実行されます。読み出しおよび書き込みプロセスは AXI トランザクションを単純なループで開始し、受信した値を内部 FIFO に書き込むか、内部 FIFO から読み出して AXI 出力に書き込みます。これらを含む <code class="docutils literal notranslate"><span class="pre">pass_dataflow</span></code> 関数に DATAFLOW プラグマが設定されているので、Vitis コンパイラでこれらのブロックが同時並列プロセスとしてインプリメントされます。</p>
</div>
<div class="section" id="building-the-device-binary-xclbin">
<h2>デバイス バイナリ (xclbin) のビルド<a class="headerlink" href="#building-the-device-binary-xclbin" title="Permalink to this heading">¶</a></h2>
<blockquote>
<div><p><strong>注記:</strong> このチュートリアルでは、すべての手順を <code class="docutils literal notranslate"><span class="pre">reference-files</span></code> ディレクトリから実行します。</p>
</div></blockquote>
<p>ホスト コードにはハードウェア エミュレーションでうまく実行できるものもありますが、正確なランタイム情報の取得および大型のテスト ベクターの実行には、実際のアクセラレータ カード上でカーネルを実行する必要があります。通常、カーネルはホスト コードの最適化中には変更されないので、このチュートリアルではカーネルをハードウェアにコンパイルする必要があるのは 1 回だけです。</p>
<p>次の make コマンドを実行して、カーネルを特定のアクセラレータ カードにコンパイルします。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span> <span class="n">DEVICE</span><span class="o">=</span><span class="n">xilinx_u200_gen3x16_xdma_2_202110_1</span> <span class="n">xclbin</span></pre></div>
</div>
<blockquote>
<div><p><strong>注記:</strong> このビルド プロセスには数時間かかりますが、ホスト コードの最適化がパフォーマンスにどのように影響するかを解析する前に、カーネルをコンパイルする必要があります。</p>
</div></blockquote>
</div>
<div class="section" id="host-code">
<h2>ホスト コード<a class="headerlink" href="#host-code" title="Permalink to this heading">¶</a></h2>
<p>ホスト コードのさまざまなインプリメンテーション オプションを検証する前に、コードの構造を確認します。ホスト コード ファイルは、ホスト コード最適化の重要な点に集中できるように設計されています。</p>
<p>共通ソース ディレクトリ (<code class="docutils literal notranslate"><span class="pre">srcCommon</span></code>) のヘッダー ファイルには、次の 3 つのクラスが含まれます。</p><ul> <li><p><code class="docutils literal notranslate"><span class="pre">srcCommon/AlignedAllocator.h</span></code>: <code class="docutils literal notranslate"><span class="pre">AlignedAllocator</span></code> は 2 つのメソッドを含む小型の構造体です。この構造体は、テスト ベクターのメモリ アライメントされた割り当てをサポートするヘルパー クラスとして提供されています。Alveo データセンター アクセラレータ カードでは、メモリ アライメントされたデータのブロックは高速に転送でき、送信されたデータがメモリ アライメントされていない場合は OpenCL™ API ライブラリで警告が作成されます。</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">srcCommon/ApiHandle.h</span></code>: 次の主な OpenCL API オブジェクトをカプセル化します。</p><ul class="simple"> <li><p>context</p></li> <li><p>program</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">device_id</span></code></p></li> <li><p>execution kernel</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">command_queue</span></code></p></li> </ul>
<p>これらの構造はコンストラクターで作成され、OpenCL API 関数呼び出しのデフォルト シーケンスを 1 つずつ実行します。コンストラクターには、次の 2 つの設定パラメーターがあります。</p><ul class="simple"> <li><p>FPGA をプログラムするのに使用するビットストリーム (<code class="docutils literal notranslate"><span class="pre">xclbin</span></code>) の名前を含む文字列。</p></li> <li><p>順不同キューを作成するか、順序どおりの実行キューを作成するかを指定するブール値。</p></li> </ul>
<p>このクラスには、バッファーの生成およびアクセラレータでのタスクのスケジューリングに必要なキュー、コンテキスト、カーネルへの補足的な関数が含まれます。また、ApiHandle デストラクターが呼び出されると、自動的に割り当てられた OpenCL API オブジェクトが解放されます。</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">srcCommon/Task.h</span></code>: オブジェクト クラス <code class="docutils literal notranslate"><span class="pre">Task</span></code> は、アクセラレータで実行されるワークロードの 1 つのインスタンスを示します。このクラスのオブジェクトが作成されると、バッファー サイズに基づいて入力および出力ベクターが割り当てられて初期化され、タスク呼び出しごとに転送されます。同様に、デストラクターはタスク実行中に生成されたオブジェクトの割り当てを解除します。</p>
<blockquote>
<div><p><strong>注記:</strong> このように 1 つのモジュールの呼び出しに 1 つのワークロードをカプセル化すると、このクラスに出力検証関数 (<code class="docutils literal notranslate"><span class="pre">outputOk</span></code>) も含めることができます。</p>
</div></blockquote>
<p>このクラスのコンストラクターには、次の 2 つのパラメーターが含まれます。</p><ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">bufferSize</span></code>: このタスクが実行されるときに転送される 512 ビット値の数を指定します。</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">processDelay</span></code>: 同様の名前のカーネル パラメーターを提供します。検証中にも使用されます。</p></li> </ul>
<p>このクラスで最も重要なメンバー関数は、<code class="docutils literal notranslate"><span class="pre">run</span></code> です。この関数は、アルゴリズムを実行するため、次の 3 つの手順をエンキューします。</p>
<ol class="simple"><li><p>FPGA アクセラレータにデータを書き込む</p></li> <li><p>カーネルを設定してアクセラレータを実行</p></li> <li><p>FPGA アクセラレータからデータを戻す</p></li></ol>
<p>これらを実行するため、通信用に DDR 上にバッファーが割り当てられます。また、異なるコマンド間の依存 (実行前に書き込み、読み出し前に実行) を作成するために、イベントが使用されます。</p>
<p><code class="docutils literal notranslate"><span class="pre">run</span></code> 関数には、ApiHandle オブジェクトに加え、1 つの条件引数があります。この引数を使用すると、タスクが前に生成したイベントに依存するようにでき、このチュートリアルの後半で説明するように、ホスト コードでタスク順の依存性を構築できます。</p>
<p>これらのヘッダー ファイルのコードは、このチュートリアルでは変更しません。主な概念は、次のフォルダーに含まれる異なる <code class="docutils literal notranslate"><span class="pre">host.cpp</span></code> ファイルに記述されています。</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">src/pipeline_host.cpp</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">src/sync_host.cpp</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">src/buf_host.cpp</span></code></p></li> </ul>
<p>ただし、<code class="docutils literal notranslate"><span class="pre">host.cpp</span></code> ファイルの main 関数は、次のセクションに説明する特別な構造に従います。</p>
<div class="section" id="host-cpp-main-functions">
<h3>host.cpp の main 関数<a class="headerlink" href="#host-cpp-main-functions" title="Permalink to this heading">¶</a></h3>
<p>main 関数には、次のセクションが含まれます。</p>
<ol class="simple"><li><p><strong>Environment / Usage Check</strong></p></li> <li><p><strong>Common Parameters</strong></p><ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">numBuffers</span></code>: 変更されないパラメーターです。カーネルの実行回数を指定するために使用します。</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">oooQueue</span></code>: ApiHandle 内で生成される OpenCL イベント キューのタイプを宣言するために使用するブール値。</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">processDelay</span></code>: カーネルで必要とされる計算時間を人工的に遅らせます。このパラメーターは、このバージョンのチュートリアルでは使用しません。</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">bufferSize</span></code>: カーネル実行ごとに転送される 512 ビット値の数を宣言します。</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">softwarePipelineInterval</span></code>: 同期の前に前もってスケジュール可能な演算の数を指定します。</p></li> </ul>
</li>
<li><p><strong>Setup</strong>: 設定変数のステータスを通知するため、最終的な設定を表示します。</p></li> <li><p><strong>Execution</strong>: 複数の異なるホスト コードのパフォーマンス問題をモデル化できます。このチュートリアルでは、これらの行について説明します。</p></li> <li><p><strong>Testing</strong>: 実行の完了後、出力で単純なチェックを実行します。</p></li> <li><p><strong>Performance Statistics</strong>: モデルをエミュレーションではなく実際のアクセラレータ カードで実行した場合に、ホスト コードでシステム時間の計測に基づいてパフォーマンス統計が計算され表示されます。</p></li></ol>
<blockquote>
<div><p><strong>注記:</strong> setup セクションだけでなくその他のセクションでも、システム ステータスや、実行の全体的な <code class="docutils literal notranslate"><span class="pre">PASS</span></code> または <code class="docutils literal notranslate"><span class="pre">FAIL</span></code> を記録するメッセージを表示できます。</p>
</div></blockquote>
</div>
<div class="section" id="lab-1-pipelined-kernel-execution-using-out-of-order-event-queue">
<h3>演習 1: 順不同イベント キューを使用してパイプライン処理済みのカーネルを実行<a class="headerlink" href="#lab-1-pipelined-kernel-execution-using-out-of-order-event-queue" title="Permalink to this heading">¶</a></h3>
<p>この演習では、パイプライン処理されたカーネルを実行します。</p>
<p>このビルドでは、カーネルの 1 つのインスタンス、またはハードウェアで実行する 1 つの計算ユニット (CU) のみを処理します。前述のように、カーネルの実行には、CU からデータを送受信する必要もあります。これらの操作をパイプライン処理して、カーネルのアイドル時間を最小限に抑える必要があります。</p>
<p>ホスト コード <code class="docutils literal notranslate"><span class="pre">src/pipeline_host.cpp</span></code> を開き、55 行目から開始する実行ループを見てみます。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// -- Execution -----------------------------------------------------------</span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numBuffers</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">run</span><span class="p">(</span><span class="n">api</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">clFinish</span><span class="p">(</span><span class="n">api</span><span class="p">.</span><span class="n">getQueue</span><span class="p">());</span><span class="w"></span>
</pre></div>
</div>

<p>このコードですべてのバッファーがスケジュールされて実行されます。実際に同期して完了を待つのは最後の行です。</p>
<ol><li><p>次のコマンドを使用して、ホスト コード (<code class="docutils literal notranslate"><span class="pre">srcPipeline/host.cpp</span></code>) をコンパイルして実行します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span> <span class="n">DEVICE</span><span class="o">=</span><span class="n">xilinx_u200_gen3x16_xdma_2_202110_1</span> <span class="n">LAB</span><span class="o">=</span><span class="n">pipeline</span>
</pre></div>
</div>
<p>カーネルのコンパイル時間と比べると、ビルド段階は短時間で実行されます。</p></li> <li><p>アプリケーションを実行する準備が完了しました。</p>
<p><a class="reference external" href="https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration/Enabling-Profiling-in-Your-Application">アプリケーションでのプロファイリングのイネーブル</a>に説明されているように、<code class="docutils literal notranslate"><span class="pre">xrt.ini</span></code> ファイルで指定した設定により、ランタイム データがホスト プログラムで生成されます。このファイルは <code class="docutils literal notranslate"><span class="pre">./reference-files/auxFiles/xrt.ini</span></code> にあり、<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">run</span></code> コマンドで <code class="docutils literal notranslate"><span class="pre">runPipeline</span></code> ディレクトリにコピーされます。</p>
<p><code class="docutils literal notranslate"><span class="pre">xrt.ini</span></code> ファイルには、次の設定が含まれています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span> <span class="n">DEVICE</span><span class="o">=</span><span class="n">xilinx_u200_gen3x16_xdma_2_202110_1</span> <span class="n">LAB</span><span class="o">=</span><span class="n">pipeline</span>
</pre></div>
</div>
<p>次のコマンドを使用してアプリケーションを実行します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">run</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span> <span class="n">DEVICE</span><span class="o">=</span><span class="n">xilinx_u200_gen3x16_xdma_2_202110_1</span> <span class="n">LAB</span><span class="o">=</span><span class="n">pipeline</span>
</pre></div>
</div>
<p>実行が完了したら、Vitis アナライザーの左側のペインで [Application Timeline] を選択してアプリケーション タイムラインを開きます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vitis_analyzer</span> <span class="n">runPipeline</span><span class="o">/</span><span class="k">pass</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">xilinx_u200_gen3x16_xdma_2_202110_1</span><span class="o">.</span><span class="n">xclbin</span><span class="o">.</span><span class="n">run_summary</span>
</pre></div>
</div>
<p>[Application Timeline] ビューには、実行ファイルの実行全体が示されます。このタイムラインには、主に次の 3 つのセクションが含まれます。</p><ul class="simple"> <li><p>[OpenCL API Calls]</p></li> <li><p>[Data Transfer]</p></li> <li><p>[Kernel Enqueues]</p></li> </ul>
</li>
<li><p>実際のアクセラレータ実行を示すセクションを拡大し、<code class="docutils literal notranslate"><span class="pre">Row</span> <span class="pre">0</span></code> にあるカーネル エンキュー ブロックの 1 つを選択します。<img alt="../../../../_images/OrderedQueue_vitis.PNG" src="../../../../_images/OrderedQueue_vitis.PNG" /></p>
<p>青の矢印は依存性を示します。すべての書き込み/実行/読み出しタスクの実行が前の書き込み/実行/読み出し演算セットに依存しており、実行は順次になります。この場合、依存性は順序どおりのキューを使用して作成されます。</p></li> <li><p>テキスト エディターで <code class="docutils literal notranslate"><span class="pre">src/pipeline_host.cpp</span></code> ファイルを開きます。</p>
<p><code class="docutils literal notranslate"><span class="pre">pipeline_host.cpp</span></code> の 27 行目の <strong>Common parameter</strong> セクションでは、<code class="docutils literal notranslate"><span class="pre">oooQueue</span></code> パラメーターが <code class="docutils literal notranslate"><span class="pre">false</span></code> に設定されています。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="kt">bool</span><span class="w">         </span><span class="n">oooQueue</span><span class="w">                 </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>この依存性は、順不同 (`oooQueue`) パラメーターを <code class="docutils literal notranslate"><span class="pre">true</span></code> に変更するとなくなります。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="kt">bool</span><span class="w">         </span><span class="n">oooQueue</span><span class="w">                 </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</li> <li><p>アプリケーションを再コンパイルし、プログラムを再実行して、Vitis アンライザーで run_summary を確認します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">run</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span> <span class="n">DEVICE</span><span class="o">=</span><span class="n">xilinx_u200_gen3x16_xdma_2_202110_1</span> <span class="n">LAB</span><span class="o">=</span><span class="n">pipeline</span>
<span class="n">vitis_analyzer</span> <span class="n">pipeline</span><span class="o">/</span><span class="k">pass</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">xilinx_u200_gen3x16_xdma_2_202110_1</span><span class="o">.</span><span class="n">xclbin</span><span class="o">.</span><span class="n">run_summary</span>
</pre></div>
</div>
<p>[Application Timeline] ビューを拡大してカーネル キューの結果をクリックすると、次の図のような表示になります。<img alt="../../../../_images/OutOfOrderQueue_vitis.PNG" src="../../../../_images/OutOfOrderQueue_vitis.PNG" /></p>
<p>ほかの pass カーネル エンキューを選択すると、10 個すべての依存性が書き込み/実行/読み出しグループ内のみに表示されるようになります。これで読み出しと書き込みをオーバーラップできるようになり、ソフトウェアの書き込み、実行、読み出しが効率的にパイプライン処理されます。通信のオーバーヘッドがアクセラレータの実行と同時に発生するので、全体的なパフォーマンスが大幅に向上します。</p></li></ol>
</div>
<div class="section" id="lab-2-kernel-and-host-code-synchronization">
<h3>演習 2: カーネルおよびホスト コードを同期<a class="headerlink" href="#lab-2-kernel-and-host-code-synchronization" title="Permalink to this heading">¶</a></h3>
<p>ここでは、まず <code class="docutils literal notranslate"><span class="pre">src/sync_host.cpp</span></code> のソース コードの実行ループを確認します (55 行目)。これは、このチュートリアルの前のセクションで使用したのと同じコードです。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// -- Execution -----------------------------------------------------------</span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numBuffers</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">run</span><span class="p">(</span><span class="n">api</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">clFinish</span><span class="p">(</span><span class="n">api</span><span class="p">.</span><span class="n">getQueue</span><span class="p">());</span><span class="w"></span>
</pre></div>
</div>
<p>この例では、フリーランニング パイプラインがインプリメントされます。イベント キューで <code class="docutils literal notranslate"><span class="pre">clFinish</span></code> への呼び出しが実行されるまで、同期は実行されません。これで効率的なパイプラインは作成されますが、インプリメンテーションでバッファーの割り当てと実行順序に関する問題が発生します。これは、バッファーが不要にならないとバッファーを解放できず、これが同期ポイントになるからです。</p>
<p>たとえば、ビデオ ストリームを処理する場合など、<code class="docutils literal notranslate"><span class="pre">numBuffer</span></code> 変数を大きくすると問題となることがあります。この場合、ホスト メモリがあらかじめ割り当てられて FPGA と共有されるので、バッファーの割り当てとメモリ使用量が問題となります。この例ではメモリ不足が発生します。</p>
<p>同様に、アクセラレータを実行する呼び出しがそれぞれ独立していて、同期されていない (順不同キュー) ので、異なる呼び出し間の実行順がエンキューの順序と一致しない可能性があります。この結果、ホスト コードが特定のブロックが終了するのを待つ場合に、実行が予測よりも遅れる可能性があります。これにより、アクセラレータが実行されているときのホスト コードの並列処理が実質的にディスエーブルになります。</p>
<p>この問題を軽減するため、OpenCL フレームワークには 2 つの同期方法があります。</p><ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">clFinish</span></code> 呼び出し</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">clWaitForEvents</span></code> 呼び出し</p></li> </ul>
<ol><li><p><code class="docutils literal notranslate"><span class="pre">src/sync_host.cpp</span></code> ファイルをテキスト エディターで開き、<code class="docutils literal notranslate"><span class="pre">Execution</span></code> 領域を確認します。この動作を確認するため、実行ループを次のように変更します。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// -- Execution -----------------------------------------------------------</span>

<span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numBuffers</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">count</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">run</span><span class="p">(</span><span class="n">api</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">clFinish</span><span class="p">(</span><span class="n">api</span><span class="p">.</span><span class="n">getQueue</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">clFinish</span><span class="p">(</span><span class="n">api</span><span class="p">.</span><span class="n">getQueue</span><span class="p">());</span><span class="w"></span>
</pre></div>
</div>
</li> <li><p>実行が完了したら、Vitis アナライザーの左側のペインで [Application Timeline] を選択してアプリケーション タイムラインを開きます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vitis_analyzer</span> <span class="n">sync</span><span class="o">/</span><span class="k">pass</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">xilinx_u200_gen3x16_xdma_2_202110_1</span><span class="o">.</span><span class="n">xclbin</span><span class="o">.</span><span class="n">run_summary</span></pre></div>
</div>
<p>[Application Timeline] ビューを拡大すると、次のように表示されます。 <img alt="../../../../_images/clFinish_vitis.PNG" src="../../../../_images/clFinish_vitis.PNG" /></p>
<p>この図で、<code class="docutils literal notranslate"><span class="pre">clFinish</span></code> という赤いボックスと、アクセラレータを 3 回呼び出すごとにカーネル エンキュー間のギャップが大きくなっていることに注目してください。</p>
<p><code class="docutils literal notranslate"><span class="pre">clFinish</span></code> への呼び出しにより、全 OpenCL コマンド キューに同期ポイントが作成されます。つまり、指定のキューにエンキューされたコマンドは、<code class="docutils literal notranslate"><span class="pre">clFinish</span></code> がホスト プログラムに制御を戻す前にすべて終了している必要があります。このため、バッファーの通信を含むすべての操作を、次の 3 アクセラレータ呼び出しのセットが再開する前に終了する必要があります。これは実質的にバリア同期です。</p>
<p>これにより、バッファーを解放できる同期ポイントをイネーブルにでき、すべてのプロセスが確実に完了するだけでなく、同期ポイントでのオーバーラップを回避できます。</p></li> <li><p>前のアクセラレータへの呼び出しの終了に基づいて同期を実行する別の同期方法を確認します。<code class="docutils literal notranslate"><span class="pre">sync_host.cpp</span></code> ファイルで実行ループを次のように変更します。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// -- Execution -----------------------------------------------------------</span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numBuffers</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">run</span><span class="p">(</span><span class="n">api</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">run</span><span class="p">(</span><span class="n">api</span><span class="p">,</span><span class="w"> </span><span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="mi">-3</span><span class="p">].</span><span class="n">getDoneEv</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">clFinish</span><span class="p">(</span><span class="n">api</span><span class="p">.</span><span class="n">getQueue</span><span class="p">());</span><span class="w"></span>
</pre></div>
</div>
</li> <li><p>アプリケーションを再コンパイルし、プログラムを再実行して、Vitis アンライザーで run_summary を確認します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">run</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span> <span class="n">DEVICE</span><span class="o">=</span><span class="n">xilinx_u200_gen3x16_xdma_2_202110_1</span> <span class="n">LAB</span><span class="o">=</span><span class="n">sync</span>
<span class="n">vitis_analyzer</span> <span class="n">sync</span><span class="o">/</span><span class="k">pass</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">xilinx_u200_gen3x16_xdma_2_202110_1</span><span class="o">.</span><span class="n">xclbin</span><span class="o">.</span><span class="n">run_summary</span>
</pre></div>
</div>
<p>[Application Timeline] ビューを拡大すると、次のように表示されます。 <img alt="../../../../_images/clEventSync_vitis.PNG" src="../../../../_images/clEventSync_vitis.PNG" /></p>
<p>タイムラインの後半では、不必要な間隔なしに pass が 5 回実行されていますが、さらに注目に値するのがマーカーで示した部分でのデータ転送です。この段階では、3 つのパッケージがアクセラレータで処理されるように送信されており、既に 1 つが戻ってきています。最初のアクセラレータの呼び出しが完了したときに次の書き込み/実行/読み出しが実行されるようにしたので、3 つ目のパスが完了する前に次の書き込みが発生しています。実行がオーバーラップしているのが明確にわかります。</p>
<p>この例では、クラス タスクの <code class="docutils literal notranslate"><span class="pre">run</span></code> メソッドの次のイベント同期を使用して、3 呼び出し前にスケジュールされた実行が完了したときに、次のアクセラレータ全体が実行されるようにしました。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">prevEvent</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">clEnqueueMigrateMemObjects</span><span class="p">(</span><span class="n">api</span><span class="p">.</span><span class="n">getQueue</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_inBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"></span>
<span class="w">                                </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">prevEvent</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_inEv</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="n">clEnqueueMigrateMemObjects</span><span class="p">(</span><span class="n">api</span><span class="p">.</span><span class="n">getQueue</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_inBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"></span>
<span class="w">                                </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m_inEv</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>これは OpenCL のエンキューされたオブジェクト間によく使用される同期化方法ですが、次の API を呼び出してホスト コードを同期化する方法もあります。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="n">clWaitForEvents</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">prevEvent</span><span class="p">);</span><span class="w"></span></pre></div>
</div>
<p>これにより、アクセラレータが前にエンキューされたタスクを実行している間に、追加のホスト コード計算を実行できます。これについては、詳細はここでは説明しません。</p>
<blockquote>
<div><p><strong>注記:</strong> この同期方法では、イベントの完了後にホスト コードが動作できるので、バッファー管理スキームをコード記述できます。これにより、長時間実行されるアプリケーションでメモリ不足が発生しなくなります。</p>
</div></blockquote></li></ol>
</div>
<div class="section" id="lab-3-opencl-api-buffer-size">
<h3>演習 3: OpenCL API バッファー サイズ<a class="headerlink" href="#lab-3-opencl-api-buffer-size" title="Permalink to this heading">¶</a></h3>
<p>このチュートリアルの最後のセクションでは、バッファー サイズが全体的なパフォーマンスにどのように影響するかを調べます。このセクションでは、<code class="docutils literal notranslate"><span class="pre">src/buf_host.cpp</span></code> のホスト コードについて説明します。</p>
<p>実行ループは、前のセクションの最後のものと同じです。ただし、<code class="docutils literal notranslate"><span class="pre">src/buf_host.cpp</span></code> ファイルでは、処理されるタスク数を 100 に増加しています。この変更は、100 個のアクセラレータ呼び出しを取得し、100 個のバッファーを転送して、100 個のバッファーを読み込むために加えられています。これにより、転送ごとの平均スループットをより正確に見積もることができるようになります。</p>
<p>特定の実行でのバッファー サイズを指定するため、2 つ目のコマンド ライン オプション (<code class="docutils literal notranslate"><span class="pre">SIZE=</span></code>) も追加されています。1 つの書き込みまたは読み出し中に転送される実際のバッファー サイズは、指定した引数の 2 のべき乗 (<code class="docutils literal notranslate"><span class="pre">pow(2,</span> <span class="pre">argument)</span></code>) を 512 ビットで乗算して算出されます。</p>
<ol><li><p>ホスト コードをコンパイルして実行します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">run</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span> <span class="n">DEVICE</span><span class="o">=</span><span class="n">xilinx_u200_gen3x16_xdma_2_202110_1</span> <span class="n">SIZE</span><span class="o">=</span><span class="mi">14</span> <span class="n">LAB</span><span class="o">=</span><span class="n">buf</span>
</pre></div>
</div>
<p>引数 <code class="docutils literal notranslate"><span class="pre">SIZE</span></code> は、ホスト実行ファイルへの 2 つ目の引数として使用されます。</p>
<blockquote>
<div><p><strong>注記:</strong> <code class="docutils literal notranslate"><span class="pre">SIZE</span></code> が含まれない場合は、<code class="docutils literal notranslate"><span class="pre">SIZE=14</span></code> に設定されます。</p>
</div></blockquote>
<p>これにより、異なるバッファー サイズを使用してインプリメンテーションを実行でき、計算時間合計を監視することによりスループットを測定できるようになります。この値はテストベンチで計算され、FPGA スループット出力でレポートされます。</p></li> <li><p>実行が完了したら、Vitis アナライザーの左側のペインで [Application Timeline] を選択してアプリケーション タイムラインを開きます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vitis_analyzer</span> <span class="n">buf</span><span class="o">/</span><span class="k">pass</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">xilinx_u200_gen3x16_xdma_2_202110_1</span><span class="o">.</span><span class="n">xclbin</span><span class="o">.</span><span class="n">run_summary</span>
</pre></div>
</div>
<p>タイムラインを見て演算を確認します。</p></li> <li><p>異なるバッファー サイズでのスイープ実行を簡単にするため、別の makefile ターゲットが作成されており、次のコマンドを使用して実行できます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span> <span class="n">DEVICE</span><span class="o">=</span><span class="n">xilinx_u200_gen3x16_xdma_2_202110_1</span> <span class="n">bufRunSweep</span>
</pre></div>
</div>
<blockquote>
<div><p><strong>注記:</strong> スイープ スクリプト (<code class="docutils literal notranslate"><span class="pre">auxFiles/run.py</span></code>) には、ほとんどのシステムで使用可能な Python をインストールする必要があります。</p>
</div></blockquote>
<p>スイープが実行され、バッファーの SIZE 引数 8 ～ 19 の FPGA スループットが記録されます。計測されたスループット値は転送ごとの実際のバイト数と共に <code class="docutils literal notranslate"><span class="pre">buf/results.csv</span></code> に記録され、makefile の実行の最後に表示されます。</p>
<p>これらの値を解析すると、次の図に示すようなステップ関数が表示されます。<br /><img alt="../../../../_images/stepFunc.PNG" src="../../../../_images/stepFunc.PNG" /></p>
<p>この図から、バッファー サイズ (X 軸、転送ごとのバイト数) がパフォーマンス (Y 軸、FPGA スループット (MB/s)) に影響しており、約 2 MB で横ばいになり始めることがわかります。</p>
<blockquote>
<div><p><strong>注記:</strong> この図は、Gnuplot を使用して <code class="docutils literal notranslate"><span class="pre">results.csv</span></code>  ファイルから作成されています。Gnuplot がシステムに含まれている場合、スイープを実行すると自動的に表示されます。</p>
</div></blockquote></li></ol>
<p>ホスト コードのパフォーマンスについては、このステップ関数によりバッファー サイズおよび実行速度合計間の関係がわかります。この例で示すように、デフォルト インプリメンテーションが少量の入力データに基づいている場合、アルゴリズムのバッファー サイズは簡単に変更できます。ここで実行したようにランタイムで動的に決定されるようにする必要はありませんが、原則は同じです。アルゴリズムの 1 回の呼び出しに対して 1 つの値セットを送信するのではなく、複数の入力値を送信して、1 つのアクセラレータ呼び出しでアルゴリズムの実行を繰り返します。</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>まとめ<a class="headerlink" href="#conclusion" title="Permalink to this heading">¶</a></h2>
<p>このチュートリアルでは、ホスト コードの 3 つの最適化方法を説明しました。</p><ul class="simple"> <li><p>順不同イベント キューを使用してパイプライン処理済みのカーネルを実行</p></li> <li><p>カーネルおよびホスト コードを同期</p></li> <li><p>OpenCL API バッファー サイズ</p></li> </ul>
<p>効率的なアクセラレーション インプリメンテーションを作成するには、これらについて考慮してください。このチュートリアルでは、これらのパフォーマンス ボトルネックの解析方法と改善方法の 1 つを示しました。</p>
<p>ホスト コードをインプリメントしてパフォーマンスを改善する方法は多数あります。これは、ホストからアクセラレータのパフォーマンス、バッファー管理などの項目の改善にも当てはまります。このチュートリアルでは、ホスト コードの最適化に関するすべての側面について説明したわけではありません。</p>
</div>
<div class="section" id="next-steps">
<h2>次のステップ<a class="headerlink" href="#next-steps" title="Permalink to this heading">¶</a></h2>
<p>アプリケーション パフォーマンスを解析するのに使用するツールおよびプロセスの詳細は、『Vitis 統合ソフトウェア プラットフォームの資料』 (UG1416) のアプリケーション アクセラレーション開発フローの<a class="reference external" href="https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration/Profiling-Optimizing-and-Debugging-the-Application">アプリケーションのプロファイル、最適化、およびデバッグ</a>を参照してください。 </br></p>
<hr/><p>Apache ライセンス、バージョン 2.0 (以下「ライセンス」) に基づいてライセンス付与されています。本ライセンスに準拠しないと、このファイルを使用することはできません。ライセンスのコピーは、http://www.apache.org/licenses/LICENSE-2.0 から入手できます。</p>
<p>適切な法律で要求されるか、書面で同意された場合を除き、本ライセンスに基づいて配布されるソフトウェアは、明示的または黙示的を問わず、いかなる種類の保証または条件もなく、「現状のまま」配布されます。ライセンスに基づく権限と制限を管理する特定の言語については、ライセンスを参照してください。</p>
<p class="sphinxhide" align="center"><sup>Copyright&copy; 2020-2022 Xilinx</sup><br><sup>XD018</sup></br></p></div>
</div>


           </div>
          </div>
          
                  <style>.footer { position: fixed; left: 0; bottom: 0; width: 100%; }</style>
				  
				  <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer"> <a href="../06-cholesky-accel/README.html" class="btn btn-neutral float-left" title="Vitis Hardware Acceleration on Cholesky Algorithm" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a> <a href="../08-alveo_aurora_kernel/README.html" class="btn btn-neutral float-right" title="Using Aurora IP in Alveo with Vitis Flow" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a> </div>

  <hr/>

  <div role="contentinfo">
    <p>© Copyright 2019-2022, Xilinx, Inc.. <span class="lastupdated">Last updated on May 16, 2022.</span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div> </br> Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>