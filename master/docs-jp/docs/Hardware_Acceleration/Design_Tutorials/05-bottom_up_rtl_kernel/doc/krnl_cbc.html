<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
  <title>RTL Kernel: krnl_cbc &mdash; Vitis™ Tutorials 2022.1 documentation</title>
      <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../../../../../index.html" class="icon icon-home"> Vitis™ Tutorials
            <img src="../../../../../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2022.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">日本語版</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/master/docs-jp/index.html">Main</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Getting_Started/Vitis-Getting-Started.html">Getting Started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Acceleration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware-Acceleration.html">Hardware Acceleration</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">AI Engine</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../AI_Engine_Development/AI_Engine_Development.html">AI Engine Development</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Platforms</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Vitis_Platform_Creation/Vitis_Platform_Creation.html">Vitis Platform Creation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2021-2/build/html/index.html">2021.2</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2021-1/build/html/index.html">2021.1</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-2/docs/index.html">2020.2</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-1/docs/README.html">2020.1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">Vitis™ Tutorials</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>RTL Kernel: krnl_cbc</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../_sources/docs/Hardware_Acceleration/Design_Tutorials/05-bottom_up_rtl_kernel/doc/krnl_cbc.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="rtl-kernel-krnl-cbc">
<h1>RTL Kernel: krnl_cbc<a class="headerlink" href="#rtl-kernel-krnl-cbc" title="Permalink to this heading">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h2>
<p>This part of the tutorial introduces another RTL kernel: <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code>.</p>
<p>This kernel has AXI master interfaces to access input/output data in on-board global memory, and to transmit/receive the data via AXI stream master/slave ports. This kernel is connected with the <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> kernel via AXI stream ports in the Vitis v++ linking stage to implement the complete AES processing function. AES-ECB and AES-CBC modes are supported by <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code>.</p>
<p>Again, you will use command-line Tcl scripts to finish all the steps without GUI support, except for waveform viewing. The <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code> kernel has four internal processing pipes, matching the four AES engines in <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code>, which are transparent to the user. The <code class="docutils literal notranslate"><span class="pre">ap_ctrl_chain</span></code> execution model is supported by <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code>, and the user can fully utilize the hardware parallel acceleration capability without insight knowledge about the number of the internal engines. Note that it is actually not so efficient to realize the connection between the AES core engines and CBC control units with external AXI stream link. We just implement them in this way to show the Vitis capability and design flow.</p>
</div>
<div class="section" id="kernel-feature">
<h2>Kernel Feature<a class="headerlink" href="#kernel-feature" title="Permalink to this heading">¶</a></h2>
<p>Refer to the following block diagram of the <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code> kernel. It has four identical CBC engines, which receive input data from AXI read master via engine control unit. They then send the data to and receive output data from the <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> kernel via the AXI stream port, and send the result to AXI write master via the <code class="docutils literal notranslate"><span class="pre">engine</span> <span class="pre">control</span></code> unit.</p>
<p>An AXI control slave module is used to set the necessary kernel arguments. The <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code> kernel finishes the task with input/output grouped words stored in global memory. Each internal engine will handle one words group at one time. Consecutive input groups are assigned to different internal CBC engines in round-robin fashion by <code class="docutils literal notranslate"><span class="pre">engine</span> <span class="pre">control</span></code> module. The <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code> kernel uses a single kernel clock for all internal modules.</p>
<div align="center">
<img src="./images/krnl_cbc.svg" alt="krnl_cbc Diagram" >
</div>
<br/><p>The <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code> kernel supports the <code class="docutils literal notranslate"><span class="pre">ap_ctrl_chain</span></code> execution model. <code class="docutils literal notranslate"><span class="pre">ap_ctrl_chain</span></code> is an extension to the <code class="docutils literal notranslate"><span class="pre">ap_ctrl_hs</span></code> model; the kernel execution is divided into <code class="docutils literal notranslate"><span class="pre">input</span> <span class="pre">sync</span></code> and <code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">sync</span></code> stage. Control signals <code class="docutils literal notranslate"><span class="pre">ap_start</span></code> and <code class="docutils literal notranslate"><span class="pre">ap_ready</span></code> are used for <code class="docutils literal notranslate"><span class="pre">input</span> <span class="pre">sync</span></code>, while <code class="docutils literal notranslate"><span class="pre">ap_done</span></code> and <code class="docutils literal notranslate"><span class="pre">ap_continue</span></code> are used for <code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">sync</span></code>. Refer to <a class="reference external" href="https://xilinx.github.io/XRT/master/html/xrt_kernel_executions.html">Supported Kernel Execution Models</a> for detailed explanations.</p>
<p>The following figure demonstrates an example waveform of <code class="docutils literal notranslate"><span class="pre">ap_ctrl_chain</span></code> module for two beat input sync and two beat output sync (kernel execute two jobs consecutively).</p>
<div align="center">
<img src="./images/ap_ctrl_chain.svg" alt="ap_ctrl_hs mode" >
</div>
<br/><p>For <code class="docutils literal notranslate"><span class="pre">input</span> <span class="pre">sync</span></code>, at clock edge <strong>a</strong> and <strong>b</strong>, <code class="docutils literal notranslate"><span class="pre">ap_start</span></code> is validated and de-asserted by the <code class="docutils literal notranslate"><span class="pre">ap_ready</span></code> signal, and triggers the kernel execution simultaneously. (This is somewhat similar to <code class="docutils literal notranslate"><span class="pre">TVALID</span></code> validated by <code class="docutils literal notranslate"><span class="pre">TREADY</span></code> in the AXI stream protocol.) The XRT scheduler detects the status of the <code class="docutils literal notranslate"><span class="pre">ap_start</span></code> signal, and asserts <code class="docutils literal notranslate"><span class="pre">ap_start</span></code> when the signal is low, meaning the kernel can accept a new task. The <code class="docutils literal notranslate"><span class="pre">ap_ready</span></code> signal is generated by the kernel, indicating its  status.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">sync</span></code>, at clock edge <strong>c</strong> and <strong>d</strong>, <code class="docutils literal notranslate"><span class="pre">ap_done</span></code> is confirmed and de-asserted by the  <code class="docutils literal notranslate"><span class="pre">ap_continue</span></code> signal, meaning the completion of one kernel job. When the XRT scheduler detects the <code class="docutils literal notranslate"><span class="pre">ap_done</span></code> signal has been asserted, XRT asserts <code class="docutils literal notranslate"><span class="pre">ap_continue</span></code>. Generally, this should be implemented as a self-clear signal, so that it only keeps one cycle.</p>
<p>From the waveform, we can see that before the <code class="docutils literal notranslate"><span class="pre">ap_done</span></code> signal was asserted, the kernel uses the  <code class="docutils literal notranslate"><span class="pre">ap_ready</span></code> signal to tell the XRT that it can accept new input data. This scheme acts as back-pressure on the <code class="docutils literal notranslate"><span class="pre">input</span> <span class="pre">sync</span></code> stage to enable the task pipeline to fully utilize the hardware capability. In the above example waveform, XRT writes <code class="docutils literal notranslate"><span class="pre">ap_start</span></code> bit and <code class="docutils literal notranslate"><span class="pre">ap_continue</span></code> bit twice each in the AXI control slave register.</p>
<p>The following table lists all the control register and kernel arguments included in AXI slave port. There is no interrupt support in this kernel.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Name</th>
<th>Addr Offset</th>
<th>Width (bits)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CTRL</td>
<td>0x000</td>
<td>5</td>
<td>Control Signals.<br>bit 0  - ap_start <br>bit 1  - ap_done <br>bit 2  - ap_idle <br>bit 3  - ap_ready <br>bit 4  - ap_continue</td>
</tr>
<tr>
<td>MODE</td>
<td>0x010</td>
<td>1</td>
<td>Kernel cipher mode:<br> 0 - decryption <br> 1 - encryption</td>
</tr>
<tr>
<td>IV_W3</td>
<td>0x018</td>
<td>32</td>
<td>AES-CBC mode initial vector, Word 3</td>
</tr>
<tr>
<td>IV_W2</td>
<td>0x020</td>
<td>32</td>
<td>AES-CBC mode initial vector, Word 2</td>
</tr>
<tr>
<td>IV_W1</td>
<td>0x028</td>
<td>32</td>
<td>AES-CBC mode initial vector, Word 1</td>
</tr>
<tr>
<td>IV_W0</td>
<td>0x030</td>
<td>32</td>
<td>AES-CBC mode initial vector, Word 0</td>
</tr>
<tr>
<td>WORDS_NUM</td>
<td>0x038</td>
<td>32</td>
<td>Number of 128-bit words to process</td>
</tr>
<tr>
<td>SRC_ADDR_0</td>
<td>0x040</td>
<td>32</td>
<td>Input data buffer address, LSB</td>
</tr>
<tr>
<td>SRC_ADDR_1</td>
<td>0x044</td>
<td>32</td>
<td>Input data buffer address, MSB</td>
</tr>
<tr>
<td>DEST_ADDR_0</td>
<td>0x048</td>
<td>32</td>
<td>Output data buffer address, LSB</td>
</tr>
<tr>
<td>DEST_ADDR_1</td>
<td>0x04C</td>
<td>32</td>
<td>Output data buffer address, MSB</td>
</tr>
<tr>
<td>CBC_MODE</td>
<td>0x050</td>
<td>1</td>
<td>Cipher processing mode:<br> 0 - AES-ECB mode <br> 1 - AES-CBC mode</td>
</tr>
</tbody>
</table></div>
<div class="section" id="ip-generation">
<h2>IP Generation<a class="headerlink" href="#ip-generation" title="Permalink to this heading">¶</a></h2>
<p>This example design does not use design IP. It only uses verification IPs for simulation:</p>
<ul class="simple">
<li><p>AXI Master VIP</p></li>
<li><p>AXI Slave VIP</p></li>
</ul>
<p>These IPs are generated by a Tcl script called <code class="docutils literal notranslate"><span class="pre">~/krnl_cbc/gen_ip.tcl</span></code>.</p>
</div>
<div class="section" id="packing-the-design-into-vivado-ip-and-vitis-kernel">
<h2>Packing the Design into Vivado IP and Vitis Kernel<a class="headerlink" href="#packing-the-design-into-vivado-ip-and-vitis-kernel" title="Permalink to this heading">¶</a></h2>
<p>One key step for the RTL kernel design for Vitis is to package the RTL design into a Vitis kernel file (XO file). You can utilize the RTL Kernel Wizard in the GUI to help to create the Vitis kernel. You can also use the IP Packager in Vivado to package the design into Vivado IP, and then generate the XO file. Vivado also provides a command line flow for Vitis kernel generation, which finishes the same jobs as the GUI version.</p>
<p>In this tutorial, like in the <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> kernel case, we will use the Vivado Tcl command to finish the <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code> IP packaging and XO file generation in batch mode. The complete kernel generation script for this design is in <code class="docutils literal notranslate"><span class="pre">~/krnl_cbc/pack_kernel.tcl</span></code>. The main steps are summarized below; refer to the details in the script.</p>
<p><strong>Note</strong>: Each step in the script has a counterpart tool in the GUI. Refer to <a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/devrtlkernel.html">RTL Kernels</a> for GUI version IP packaging tool usage.</p>
<div class="section" id="create-the-vivado-project-and-add-design-sources">
<h3>1: Create the Vivado project and add design sources<a class="headerlink" href="#create-the-vivado-project-and-add-design-sources" title="Permalink to this heading">¶</a></h3>
<p>First, you must create a Vivado project containing the source files. The script use the Tcl commands <code class="docutils literal notranslate"><span class="pre">create_project</span></code>, <code class="docutils literal notranslate"><span class="pre">add_files</span></code> and <code class="docutils literal notranslate"><span class="pre">update_compiler_order</span></code> to finish this step. For <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code>, only RTL source code files are required to be added to the newly created project.</p>
<p>Next, the <code class="docutils literal notranslate"><span class="pre">ipx::package_project</span></code> Tcl command is used to initialize the IP packaging process, as follows:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>create_project krnl_cbc ./krnl_cbc
add_files -norecurse <span class="o">{</span>
      ../rtl/axi_master_counter.sv       <span class="se">\</span>
      ../rtl/axi_read_master.sv          <span class="se">\</span>
      ... ...
   <span class="o">}</span>
update_compile_order -fileset sources_1
ipx::package_project -root_dir ./krnl_cbc_ip -vendor xilinx.com -library user -taxonomy /UserIP -import_files -set_current <span class="nb">true</span>
</pre></div>
</div>
</div>
<div class="section" id="infer-clock-reset-and-axi-interfaces-and-associate-them-with-the-clock">
<h3>2: Infer clock, reset, and AXI interfaces, and associate them with the clock<a class="headerlink" href="#infer-clock-reset-and-axi-interfaces-and-associate-them-with-the-clock" title="Permalink to this heading">¶</a></h3>
<p>First, use the <code class="docutils literal notranslate"><span class="pre">ipx::infer_bus_interface</span></code> command to infer <code class="docutils literal notranslate"><span class="pre">ap_clk</span></code> and <code class="docutils literal notranslate"><span class="pre">ap_rst_n</span></code> as AXI bus signals. Generally, if <code class="docutils literal notranslate"><span class="pre">ap_clk</span></code> is the only clock used in the RTL kernel, this command can be omitted. If you use more clocks (ap_clk_2, ap_clk_3, etc.) in the design, you must use the <code class="docutils literal notranslate"><span class="pre">ipx::infer_bus_interface</span></code> command to explicitly infer the ports.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ipx</span><span class="p">::</span><span class="n">infer_bus_interface</span> <span class="n">ap_clk</span> <span class="n">xilinx</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="n">signal</span><span class="p">:</span><span class="n">clock_rtl</span><span class="p">:</span><span class="mf">1.0</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">infer_bus_interface</span> <span class="n">ap_rst_n</span> <span class="n">xilinx</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="n">signal</span><span class="p">:</span><span class="n">reset_rtl</span><span class="p">:</span><span class="mf">1.0</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
</pre></div>
</div>
<p>All AXI interfaces will be automatically inferred. In this design, these AXI ports include the following:</p>
<ul class="simple">
<li><p>A control AXI slave port: <code class="docutils literal notranslate"><span class="pre">s_axi_control</span></code></p></li>
<li><p>Four AXIS slave ports: <code class="docutils literal notranslate"><span class="pre">axis_slv0</span> <span class="pre">~</span> <span class="pre">3</span></code></p></li>
<li><p>Four AXIS master ports: <code class="docutils literal notranslate"><span class="pre">axis_mst0</span> <span class="pre">~</span> <span class="pre">3</span></code></p></li>
<li><p>Two AXI master ports: <code class="docutils literal notranslate"><span class="pre">axi_rmst</span></code> and <code class="docutils literal notranslate"><span class="pre">axi_wmst</span></code>.</p></li>
</ul>
<p>Next, use the <code class="docutils literal notranslate"><span class="pre">ipx::associate_bus_interfaces</span></code> command to associate the automatically inferred AXI interfaces and reset signal to <code class="docutils literal notranslate"><span class="pre">ap_clk</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ipx</span><span class="p">::</span><span class="n">associate_bus_interfaces</span> <span class="o">-</span><span class="n">busif</span> <span class="n">s_axi_control</span>  <span class="o">-</span><span class="n">clock</span> <span class="n">ap_clk</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">associate_bus_interfaces</span> <span class="o">-</span><span class="n">busif</span> <span class="n">axi_rmst</span>       <span class="o">-</span><span class="n">clock</span> <span class="n">ap_clk</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">associate_bus_interfaces</span> <span class="o">-</span><span class="n">busif</span> <span class="n">axi_wmst</span>       <span class="o">-</span><span class="n">clock</span> <span class="n">ap_clk</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">associate_bus_interfaces</span> <span class="o">-</span><span class="n">busif</span> <span class="n">axis_mst0</span>      <span class="o">-</span><span class="n">clock</span> <span class="n">ap_clk</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
  <span class="o">...</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">associate_bus_interfaces</span> <span class="o">-</span><span class="n">busif</span> <span class="n">axis_slv0</span>      <span class="o">-</span><span class="n">clock</span> <span class="n">ap_clk</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
  <span class="o">...</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">associate_bus_interfaces</span> <span class="o">-</span><span class="n">clock</span> <span class="n">ap_clk</span> <span class="o">-</span><span class="n">reset</span> <span class="n">ap_rst_n</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="set-the-definition-of-axi-control-slave-registers-including-ctrl-and-user-kernel-arguments">
<h3>3: Set the definition of AXI control slave registers, including CTRL and user kernel arguments<a class="headerlink" href="#set-the-definition-of-axi-control-slave-registers-including-ctrl-and-user-kernel-arguments" title="Permalink to this heading">¶</a></h3>
<p>Here we use the <code class="docutils literal notranslate"><span class="pre">ipx::add_register</span></code> command to add the registers to the inferred <code class="docutils literal notranslate"><span class="pre">s_axi_control</span></code> interface and use the <code class="docutils literal notranslate"><span class="pre">set_property</span></code> command to set the property of the registers. For example, the following shows this process with the kernel argument <code class="docutils literal notranslate"><span class="pre">CBC_MODE</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ipx</span><span class="p">::</span><span class="n">add_register</span> <span class="n">CBC_MODE</span>     <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_address_blocks</span> <span class="n">reg0</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_memory_maps</span> <span class="n">s_axi_control</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]]]</span>
<span class="n">set_property</span> <span class="n">description</span>    <span class="p">{</span><span class="n">cbc</span> <span class="n">mode</span><span class="p">}</span>          <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_registers</span> <span class="n">CBC_MODE</span>  <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_address_blocks</span> <span class="n">reg0</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_memory_maps</span> <span class="n">s_axi_control</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]]]]</span>
<span class="n">set_property</span> <span class="n">address_offset</span> <span class="p">{</span><span class="mh">0x050</span><span class="p">}</span>             <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_registers</span> <span class="n">CBC_MODE</span>  <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_address_blocks</span> <span class="n">reg0</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_memory_maps</span> <span class="n">s_axi_control</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]]]]</span>
<span class="n">set_property</span> <span class="n">size</span>           <span class="p">{</span><span class="mi">32</span><span class="p">}</span>                <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_registers</span> <span class="n">CBC_MODE</span>  <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_address_blocks</span> <span class="n">reg0</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_memory_maps</span> <span class="n">s_axi_control</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]]]]</span>
</pre></div>
</div>
<p>The following are included in the above example case:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">CBC_MODE</span></code> is the kernel argument name</p></li>
<li><p>“cbc mode” is the register description</p></li>
<li><p>“0x050” is the address offset the the register</p></li>
<li><p>“32” is the data width of the register (all scalar kernel arguments should be 32-bit width).</p></li>
</ul>
<p>You can see in the provided Tcl script that all the registers defined in the previous table are added and defined accordingly. Two special kernel arguments here are <code class="docutils literal notranslate"><span class="pre">SRC_ADDR</span></code> and <code class="docutils literal notranslate"><span class="pre">DEST_ADDR</span></code>; these are for AXI master address pointer and are all 64-bit width. We will associate them with the AXI master ports in the next step.</p>
</div>
<div class="section" id="associate-axi-master-port-to-pointer-argument-and-set-data-width">
<h3>4: Associate AXI master port to pointer argument and set data width<a class="headerlink" href="#associate-axi-master-port-to-pointer-argument-and-set-data-width" title="Permalink to this heading">¶</a></h3>
<p>We use the <code class="docutils literal notranslate"><span class="pre">ipx::add_register_parameter</span></code> and <code class="docutils literal notranslate"><span class="pre">set_property</span></code> commands to create connections between the address pointer arguments and the AXI master port, such as the below command lines for AXI read master <code class="docutils literal notranslate"><span class="pre">axi_rmst</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ipx</span><span class="p">::</span><span class="n">add_register_parameter</span> <span class="n">ASSOCIATED_BUSIF</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_registers</span> <span class="n">SRC_ADDR</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_address_blocks</span> <span class="n">reg0</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_memory_maps</span> <span class="n">s_axi_control</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]]]]</span>
<span class="n">set_property</span> <span class="n">value</span>          <span class="p">{</span><span class="n">axi_rmst</span><span class="p">}</span>          <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_register_parameters</span> <span class="n">ASSOCIATED_BUSIF</span>     \
                                    <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_registers</span> <span class="n">SRC_ADDR</span>                      \
                                    <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_address_blocks</span> <span class="n">reg0</span>                      \
                                    <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_memory_maps</span> <span class="n">s_axi_control</span>                 \
                                    <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]]]]]</span>
</pre></div>
</div>
<p>You will use the <code class="docutils literal notranslate"><span class="pre">ipx::add_bus_parameter</span></code> and <code class="docutils literal notranslate"><span class="pre">set_property</span></code> commands to correctly set the AXI master data width, as shown in the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ipx</span><span class="p">::</span><span class="n">add_bus_parameter</span> <span class="n">DATA_WIDTH</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_bus_interfaces</span> <span class="n">axi_wmst</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]]</span>
<span class="n">set_property</span> <span class="n">value</span>          <span class="p">{</span><span class="mi">128</span><span class="p">}</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_bus_parameters</span> <span class="n">DATA_WIDTH</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_bus_interfaces</span> <span class="n">axi_wmst</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]]]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">DATA_WIDTH</span></code> property is written to the generated kernel XML file.</p>
</div>
<div class="section" id="package-the-vivado-ip-and-generate-the-vitis-kernel-file">
<h3>5: Package the Vivado IP and generate the Vitis kernel file<a class="headerlink" href="#package-the-vivado-ip-and-generate-the-vitis-kernel-file" title="Permalink to this heading">¶</a></h3>
<p>In this step, you use the <code class="docutils literal notranslate"><span class="pre">set_property</span></code> command to set two required properties: <code class="docutils literal notranslate"><span class="pre">sdx_kernel</span></code> and <code class="docutils literal notranslate"><span class="pre">sdx_kernel_type</span></code>. Then, issue <code class="docutils literal notranslate"><span class="pre">ipx::update_source_project_archive</span></code> and <code class="docutils literal notranslate"><span class="pre">ipx::save_core</span></code> commands to package the Vivado project into Vivado IP. Finally, use <code class="docutils literal notranslate"><span class="pre">package_xo</span></code> command to generate the Vitis XO file.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">set_property</span> <span class="n">sdx_kernel</span> <span class="n">true</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">set_property</span> <span class="n">sdx_kernel_type</span> <span class="n">rtl</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">update_source_project_archive</span> <span class="o">-</span><span class="n">component</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">save_core</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">package_xo</span> <span class="o">-</span><span class="n">force</span> <span class="o">-</span><span class="n">xo_path</span> <span class="o">../</span><span class="n">krnl_cbc</span><span class="o">.</span><span class="n">xo</span> <span class="o">-</span><span class="n">kernel_name</span> <span class="n">krnl_cbc</span> <span class="o">-</span><span class="n">ctrl_protocol</span> <span class="n">ap_ctrl_chain</span> <span class="o">-</span><span class="n">ip_directory</span> <span class="o">./</span><span class="n">krnl_cbc_ip</span> <span class="o">-</span><span class="n">output_kernel_xml</span> <span class="o">../</span><span class="n">krnl_cbc</span><span class="o">.</span><span class="n">xml</span>
</pre></div>
</div>
<p>Note that in the above <code class="docutils literal notranslate"><span class="pre">package_xo</span></code> command usage, you let the tool to generate the kernel description XML file automatically, and therefore you do not need to manually create it.</p>
<div class="section" id="manually-creating-the-kernel-xml-file">
<h4>Manually creating the kernel XML file<a class="headerlink" href="#manually-creating-the-kernel-xml-file" title="Permalink to this heading">¶</a></h4>
<p>If you have an existing Vitis-compatible Vivado IP and need to generate the XO file from it, you could also manually create the kernel XML file and designate it in the command as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">package_xo</span> <span class="o">-</span><span class="n">xo_path</span> <span class="o">../</span><span class="n">krnl_cbc</span><span class="o">.</span><span class="n">xo</span> <span class="o">-</span><span class="n">kernel_name</span> <span class="n">krnl_cbc</span> <span class="o">-</span><span class="n">ip_directory</span> <span class="o">./</span><span class="n">krnl_cbc_ip</span> <span class="o">-</span><span class="n">kernel_xml</span> <span class="o">../</span><span class="n">krnl_cbc</span><span class="o">.</span><span class="n">xml</span>
</pre></div>
</div>
<p>In this case, the kernel execution model is specified in the XML file with <code class="docutils literal notranslate"><span class="pre">hwControlProtocol</span></code> property instead of in the <code class="docutils literal notranslate"><span class="pre">package_xo</span></code> command line option.</p>
</div>
</div>
</div>
<div class="section" id="testbench">
<h2>Testbench<a class="headerlink" href="#testbench" title="Permalink to this heading">¶</a></h2>
<p>Xilinx provides a simple SystemVerilog testbench for the <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code> module with Xilinx AXI VIPs. The testbench sources are in the <code class="docutils literal notranslate"><span class="pre">~/krnl_cbc/tbench</span></code> directory. The <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> module is instantiated in this testbench to connect with <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code> via AXI stream link. Two AXI slave VIPs are used in memory mode, and two AXI master VIPs are used to configure the arguments and control the kernel execution.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code>, the AXI master VIP emulates the <code class="docutils literal notranslate"><span class="pre">ap_ctrl_hs</span></code> protocol for AES key expansion operation. For <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code>, the AXI master VIP emulates the <code class="docutils literal notranslate"><span class="pre">ap_ctrl_chain</span></code> protocol for consecutive task pushing. In the testbench, the input and output data are divided into groups including a number of words. Both <code class="docutils literal notranslate"><span class="pre">input</span> <span class="pre">sync</span></code> and <code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">sync</span></code> are emulated in the testbench. For more details, refer to the <code class="docutils literal notranslate"><span class="pre">tb_krnl_cbc.sv</span></code> file.</p>
<p>The input random data to the testbench is generated by a perl script <code class="docutils literal notranslate"><span class="pre">~/common/plain_gen.pl</span></code>, and the reference data for output check is generated by OpenSSL tools. The shell script <code class="docutils literal notranslate"><span class="pre">~/krnl_cbc/runsim_krnl_cbc_xsim.sh</span></code> is used to generate the input stimulus and output reference, and to run the simulation with Vivado XSIM.</p>
</div>
<div class="section" id="kernel-test-system-and-overlay-xclbin-generation">
<h2>Kernel Test System and Overlay (XCLBIN) Generation<a class="headerlink" href="#kernel-test-system-and-overlay-xclbin-generation" title="Permalink to this heading">¶</a></h2>
<p>To build a test system overlay for <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code>, you just need to integrate both <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code> and <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> in the system.</p>
</div>
<div class="section" id="host-programming">
<h2>Host Programming<a class="headerlink" href="#host-programming" title="Permalink to this heading">¶</a></h2>
<p>For host programming, use XRT Native C++ APIs to control the kernel execution in FPGA. XRT Native APIs are very straightforward and intuitive. They provide higher efficiency compared to XRT OpenCL, especially in those cases needing very frequent host-kernel interactions. For more details on XRT Native APIs, refer to <a class="reference external" href="https://xilinx.github.io/XRT/master/html/xrt_native_apis.html">XRT Native APIs</a>.</p>
<p>The host program generates the random data as plain input, then uses OpenSSL AES API to generate the reference cipher data. Both AES-ECB and AES-CBC modes are tested. The PCIe data transfer is very low efficient for small blocks of data, so in the host program, we assign a number of 128-bit input data into a group, and transfer a number of groups to/from FPGA at one time. In the code, we create FPGA sub-buffers for each data group for both input and output data. From the hardware limitation, the words number in each group should be multiples of 16 and the maximum allowed value is 1008 (~16KByte).</p>
<p>The host test program supports the hardware emulation (<code class="docutils literal notranslate"><span class="pre">hw_emu</span></code>) flow as well, and will select the correct XCLBIN files for <code class="docutils literal notranslate"><span class="pre">hw</span></code> or <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code> mode.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">ap_ctrl_chain</span></code> execution model, the host program uses multi-threading techniques to simultaneously push multi-tasks to the kernel. In each sub-thread, a <code class="docutils literal notranslate"><span class="pre">run.start()</span></code> function followed by a <code class="docutils literal notranslate"><span class="pre">run.wait()</span></code> function is used. The program also provides a option to emulate the <code class="docutils literal notranslate"><span class="pre">ap_ctrl_hs</span></code> mode execution. You can see the obvious performance difference between these two modes.</p>
</div>
<div class="section" id="tutorial-usage">
<h2>Tutorial usage<a class="headerlink" href="#tutorial-usage" title="Permalink to this heading">¶</a></h2>
<div class="section" id="before-you-begin">
<h3>Before You Begin<a class="headerlink" href="#before-you-begin" title="Permalink to this heading">¶</a></h3>
<p>This tutorial uses files in the <code class="docutils literal notranslate"><span class="pre">~/krnl_cbc</span></code> directory.</p>
<p>All steps except for host program execution in this tutorial are finished by the GNU Make. This example design supports four Alveo cards (U200, U250, U50, U280), and you must make the necessary adjustments to the <code class="docutils literal notranslate"><span class="pre">~/krnl_cbc/Makefile</span></code> for each card by uncommenting the line matching your Alveo card.</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span> <span class="m">41</span> <span class="c1"># PART setting: uncomment the line matching your Alveo card</span>
 <span class="m">42</span> PART :<span class="o">=</span> xcu200-fsgd2104-2-e
 <span class="m">43</span> <span class="c1">#PART := cu250-figd2104-2L-e</span>
 <span class="m">44</span> <span class="c1">#PART := xcu50-fsvh2104-2-e</span>
 <span class="m">45</span> <span class="c1">#PART := xcu280-fsvh2892-2L-e</span>
 <span class="m">46</span>
 <span class="m">47</span> <span class="c1"># PLATFORM setting: uncomment the lin matching your Alveo card</span>
 <span class="m">48</span> PLATFORM :<span class="o">=</span> xilinx_u200_xdma_201830_2
 <span class="m">49</span> <span class="c1">#PLATFORM := xilinx_u250_xdma_201830_2</span>
 <span class="m">50</span> <span class="c1">#PLATFORM := xilinx_u50_gen3x16_xdma_201920_3</span>
 <span class="m">51</span> <span class="c1">#PLATFORM := xilinx_u280_xdma_201920_3</span>
</pre></div>
</div>
<p>As an alternative, instead of making the modification, you can use the command line option to override the default setting. An example is shown in the following steps related to using the make tool for the U50 card:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>make xxx <span class="nv">PART</span><span class="o">=</span>xcu50-fsvh2104-2-e <span class="nv">PLATFORM</span><span class="o">=</span>xilinx_u50_gen3x16_xdma_201920_3
</pre></div>
</div>
<p>Before starting, ensure that you source the setup scripts in XRT and Vitis installation path. For example:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">source</span> /opt/xilinx/xrt/setup.sh
<span class="nb">source</span> /tools/Xilinx/Vitis/2020.2/settings64.sh
</pre></div>
</div>
</div>
<div class="section" id="tutorial-steps">
<h3>Tutorial Steps<a class="headerlink" href="#tutorial-steps" title="Permalink to this heading">¶</a></h3>
<div class="section" id="generate-ips">
<h4>1. Generate IPs<a class="headerlink" href="#generate-ips" title="Permalink to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">gen_ip</span>
</pre></div>
</div>
<p>This starts Vivado in batch mode and calls <code class="docutils literal notranslate"><span class="pre">~/krnl_cbc/gen_ip.tcl</span></code> to generate all needed design and verification IPs.</p>
</div>
<div class="section" id="run-standalone-simulation">
<h4>2. Run Standalone Simulation<a class="headerlink" href="#run-standalone-simulation" title="Permalink to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">runsim</span>
</pre></div>
</div>
<p>This calls <code class="docutils literal notranslate"><span class="pre">~/krnl_cbc/runsim_krnl_cbc_xsim.sh</span></code> to run the simulation with Vivado XSIM.</p>
<p>The following figure shows the control signal waveform of <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code>. You can see that before <code class="docutils literal notranslate"><span class="pre">ap_done</span></code> is asserted, four <code class="docutils literal notranslate"><span class="pre">ap_start</span></code> pulses are issued. Then, four <code class="docutils literal notranslate"><span class="pre">ap_continue</span></code> pulses are issued to confirm the four <code class="docutils literal notranslate"><span class="pre">ap_done</span></code> flags. Because <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code> has four internal processing pipes, it can accept four task requests and process them in parallel.</p>
<div align="center">
<img src="./images/krnl_cbc_sim.png" alt="krnl_cbc waveform" >
</div>
<br/></div>
<div class="section" id="package-vivado-ip-and-generate-vitis-kernel-file">
<h4>3. Package Vivado IP and Generate Vitis Kernel File<a class="headerlink" href="#package-vivado-ip-and-generate-vitis-kernel-file" title="Permalink to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">pack_kernel</span>
</pre></div>
</div>
<p>This starts Vivado in batch mode and calls <code class="docutils literal notranslate"><span class="pre">~/krnl_cbc/pack_kernel.tcl</span></code> to package the RTL sources into Vivado IP. It then generates the Vitis kernel file <code class="docutils literal notranslate"><span class="pre">~/krnl_cbc/krnl_cbc.xo</span></code>.</p>
</div>
<div class="section" id="build-kernel-testing-system-overlay-files">
<h4>4. Build Kernel Testing System Overlay Files<a class="headerlink" href="#build-kernel-testing-system-overlay-files" title="Permalink to this heading">¶</a></h4>
<div class="section" id="for-a-hardware-target">
<h5>For a hardware target<a class="headerlink" href="#for-a-hardware-target" title="Permalink to this heading">¶</a></h5>
<p>For a hardware target, use the following command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">build_hw</span>
</pre></div>
</div>
<p>This builds the total system overlay files <code class="docutils literal notranslate"><span class="pre">~/krnl_cbc/krnl_cbc_test_hw.xclbin</span></code>.</p>
</div>
<div class="section" id="for-a-hardware-emulation-target">
<h5>For a hardware emulation target<a class="headerlink" href="#for-a-hardware-emulation-target" title="Permalink to this heading">¶</a></h5>
<p>For a hardware emulation target, use the following command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">build_hw</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw_emu</span>
</pre></div>
</div>
<p>This builds the total system overlay files <code class="docutils literal notranslate"><span class="pre">~/krnl_cbc/krnl_cbc_test_hw_emu.xclbin</span></code>.</p>
</div>
</div>
<div class="section" id="compile-host-program">
<h4>5. Compile Host Program<a class="headerlink" href="#compile-host-program" title="Permalink to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">build_sw</span>
</pre></div>
</div>
<p>This finishes the compilation of the host C++ program. An executable, <code class="docutils literal notranslate"><span class="pre">~/krnl_cbc/host_krnl_cbc_test</span></code>, is generated for both <code class="docutils literal notranslate"><span class="pre">hw</span></code> and <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code> modules.</p>
<div class="section" id="finding-the-device-id-of-your-target-card">
<h5>Finding the Device ID of Your Target Card<a class="headerlink" href="#finding-the-device-id-of-your-target-card" title="Permalink to this heading">¶</a></h5>
<p>If you have multiple Alveo cards installed on the host machine, use the <code class="docutils literal notranslate"><span class="pre">xbutil</span> <span class="pre">list</span></code> command to find the device ID of your target card. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xbutil</span> <span class="nb">list</span>
<span class="o">...</span>
 <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="mi">0000</span><span class="p">:</span><span class="n">d8</span><span class="p">:</span><span class="mf">00.1</span> <span class="n">xilinx_u250_gen3x16_base_3</span> <span class="n">user</span><span class="p">(</span><span class="n">inst</span><span class="o">=</span><span class="mi">131</span><span class="p">)</span>
 <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="mi">0000</span><span class="p">:</span><span class="n">af</span><span class="p">:</span><span class="mf">00.1</span> <span class="n">xilinx_vck5000</span><span class="o">-</span><span class="n">es1_gen3x16_base_2</span> <span class="n">user</span><span class="p">(</span><span class="n">inst</span><span class="o">=</span><span class="mi">130</span><span class="p">)</span>
 <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="mi">0000</span><span class="p">:</span><span class="mi">5</span><span class="n">e</span><span class="p">:</span><span class="mf">00.1</span> <span class="n">xilinx_u50_gen3x16_xdma_201920_3</span> <span class="n">user</span><span class="p">(</span><span class="n">inst</span><span class="o">=</span><span class="mi">129</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example, if your target card is U50, you can find the device ID is 2. You should modify the linee 32 of <code class="docutils literal notranslate"><span class="pre">~/krnl_cbc/host/host_krnl_cbc_test.cpp</span></code> as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span> 30 // Please use &#39;xbutil list&#39; command to get the device id of the target alveo card if multiple
 31 //   cards are installed in the system.
 32 #define DEVICE_ID   2
</pre></div>
</div>
</div>
</div>
<div class="section" id="run-hardware-emulation">
<h4>6. Run Hardware Emulation<a class="headerlink" href="#run-hardware-emulation" title="Permalink to this heading">¶</a></h4>
<p>When the XCLBIN file for hardware emulation <code class="docutils literal notranslate"><span class="pre">~/krnl_cbc/krnl_cbc_test_hw_emu.xclbin</span></code> is generated, we can run hardware emulation to verify the kernel in the platform environment for debug or details profiling purpose. We also use different option to compare the different behaviors between <code class="docutils literal notranslate"><span class="pre">ap_ctrl_hs</span></code> and <code class="docutils literal notranslate"><span class="pre">ap_ctrl_chain</span></code> modes.</p>
<p>First, use the following command to enable <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code> mode. The PLATFORM_NAME is the Alveo platform you are using, which can be <code class="docutils literal notranslate"><span class="pre">xilinx_u200_xdma_201830_2</span></code> (default), <code class="docutils literal notranslate"><span class="pre">xilinx_u250_xdma_201830_2</span></code>, <code class="docutils literal notranslate"><span class="pre">xilinx_u280_xdma_201920_3</span></code>, or <code class="docutils literal notranslate"><span class="pre">xilinx_u50_gen3x16_xdma_201920_3</span></code>.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">source</span> setup_emu.sh -s  -p PLATFORM_NAME
</pre></div>
</div>
<p>Then, use the following command to run the program with words-per-groups as 64 and group number as 4 in <code class="docutils literal notranslate"><span class="pre">ap_ctrl_chain</span></code> mode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">host_krnl_cbc_test</span> <span class="o">-</span><span class="n">w</span> <span class="mi">64</span> <span class="o">-</span><span class="n">g</span> <span class="mi">4</span>
</pre></div>
</div>
<p>In the generated <code class="docutils literal notranslate"><span class="pre">wdb</span></code> waveform database, you can select the AXI stream slave ports of <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code> to reflect the work status of the kernel. You can also add <code class="docutils literal notranslate"><span class="pre">emu_wrapper.emu_i.krnl_aes_1.inst.krnl_aes_axi_ctrl_slave_inst.status[3:0]</span></code> signals to the waveform window to get the status of the AES engines in <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code>.</p>
<p>The waveform snapshot is as below. You can see that the four AES engines are working in parallel to process the four consecutive input data groups.</p>
<div align="center">
<img src="./images/krnl_cbc_chain.png" alt="krnl_cbc waveform" >
</div>
<br/><p>As a contrast, if you use the following command to run the emulation, <code class="docutils literal notranslate"><span class="pre">ap_ctrl_hs</span></code> execution model will be emulated.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">host_krnl_cbc_test</span> <span class="o">-</span><span class="n">w</span> <span class="mi">64</span> <span class="o">-</span><span class="n">g</span> <span class="mi">4</span> <span class="o">-</span><span class="n">s</span>
</pre></div>
</div>
<p>The following figure shows the waveform. You can see that each time the kernel only processes one input data groups, and there are three processing engines in idle status all the time.</p>
<div align="center">
<img src="./images/krnl_cbc_hs.png" alt="krnl_cbc waveform" >
</div>
<br/><p>The next figure shows the control signals behavior in AXI control slave for <code class="docutils literal notranslate"><span class="pre">ap_ctrl_chain</span></code> mode, which is similar to the waveform in the previous standalone simulation step.</p>
<div align="center">
<img src="./images/ap_ctrl_chain_waveform.png" alt="ap_ctrl_chain waveform" >
</div>
<br/><p>The <code class="docutils literal notranslate"><span class="pre">~/krnl_cbc/xrt.ini</span></code> file is used to control the XRT emulation options, as shown below. In line 3, <code class="docutils literal notranslate"><span class="pre">user_pre_sim_script=/home/workspace/bottom_up_rtl_kernel/krnl_cbc/xsim.tcl</span></code> sets the absolute path to the pre-simulation Tcl script used by XSIM to indicate the tool to dump the waveform for all the signals.</p>
<p><strong>Note</strong>: Make sure to modify the path to match your real path.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="mi">1</span> <span class="p">[</span><span class="n">Emulation</span><span class="p">]</span>
  <span class="mi">2</span> <span class="n">debug_mode</span><span class="o">=</span><span class="n">batch</span>
  <span class="mi">3</span> <span class="n">user_pre_sim_script</span><span class="o">=/</span><span class="n">home</span><span class="o">/</span><span class="n">workspace</span><span class="o">/</span><span class="n">bottom_up_rtl_kernel</span><span class="o">/</span><span class="n">krnl_cbc</span><span class="o">/</span><span class="n">xsim</span><span class="o">.</span><span class="n">tcl</span>
  <span class="mi">4</span>
  <span class="mi">5</span> <span class="p">[</span><span class="n">Debug</span><span class="p">]</span>
  <span class="mi">6</span> <span class="n">profile</span><span class="o">=</span><span class="n">true</span>
  <span class="mi">7</span> <span class="n">timeline_trace</span><span class="o">=</span><span class="n">true</span>
  <span class="mi">8</span> <span class="n">data_transfer_trace</span><span class="o">=</span><span class="n">coarse</span>
</pre></div>
</div>
</div>
<div class="section" id="run-host-program-in-hardware-mode">
<h4>7. Run Host Program in Hardware Mode<a class="headerlink" href="#run-host-program-in-hardware-mode" title="Permalink to this heading">¶</a></h4>
<p>If you have tried hardware emulation in the previous step, you must first run the following command to disable the <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code> mode:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">source</span> setup_emu.sh -s off
</pre></div>
</div>
<p>Next, you can execute the compiled <code class="docutils literal notranslate"><span class="pre">host_krnl_cbc_test</span></code> file to test the system in hardware mode. You can use command option <code class="docutils literal notranslate"><span class="pre">-s</span></code> to disable <code class="docutils literal notranslate"><span class="pre">ap_ctrl_chain</span></code> execution mode and compare the performance difference.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>./host_krnl_cbc_test       <span class="c1"># execute in ap_ctrl_chain mode</span>
./host_krnl_cbc_test -s    <span class="c1"># execute in emulated ap_ctrl_hs mode</span>
</pre></div>
</div>
<p>Note that because the kernel running time is very short, CPU/XRT needs frequent interactions with the kernel. Therefore, the performance data reported by the program might vary between different executions brought by CPU/PCIe latency.</p>
<hr class="docutils" />
<p>Thank you for completing this tutorial.</p>
</div>
</div>
</div>
</div>


           </div>
          </div>
          
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
				  
				  <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, Xilinx, Inc..
      <span class="lastupdated">Last updated on May 16, 2022.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>