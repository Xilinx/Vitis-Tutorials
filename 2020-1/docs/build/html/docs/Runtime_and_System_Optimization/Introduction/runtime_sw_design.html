<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
  <title>Memory Allocation Concepts &mdash; Vitis™ Tutorials 2022.1 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../../../README.html" class="icon icon-home"> Vitis™ Tutorials
            <img src="../../../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2022.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">日本語版</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/master/docs-jp/README.html">Master</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting Started Pathway</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Getting_Started/Vitis/README.html">Vitis Flow 101 Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Getting_Started/Vitis_HLS/README.html">Vitis HLS Analysis and Optimization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Hardware Accelerators</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Hardware_Accelerators/Design_Tutorials/02-bloom/README.html">Optimizing Accelerated FPGA Applications: Bloom Filter Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Hardware_Accelerators/Design_Tutorials/01-convolution-tutorial/README.html">Optimizing Accelerated FPGA Applications: Convolution Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Hardware_Accelerators/Design_Tutorials/03-rtl_stream_kernel_integration/README.html">Mixed Kernels Design Tutorial with AXI Stream and Vitis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Hardware_Accelerators/Feature_Tutorials/01-rtl_kernel_workflow/README.html">Getting Started with RTL Kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Hardware_Accelerators/Feature_Tutorials/02-mixing-c-rtl-kernels/README.html">Mixing C++ and RTL Kernels</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Runtime and System Optimization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Design_Tutorials/01-host-code-opt/README.html">Host Code Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Design_Tutorials/02-ivas-ml/README.html">IVAS ZCU104 ML Acceleration Reference Release</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Feature_Tutorials/01-mult-ddr-banks/README.html">Using Multiple DDR Banks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Feature_Tutorials/02-using-multiple-cu/README.html">Using Multiple Compute Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Feature_Tutorials/03-controlling-vivado-implementation/README.html">Controlling Vivado Implementation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Vitis Platform Creation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Vitis_Platform_Creation/Introduction/01-Overview/README.html">Platform Creation Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Vitis_Platform_Creation/Introduction/02-Edge-AI-ZCU104/README.html">Vitis Custom Embedded Platform Creation Example on ZCU104</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/">Main</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../README.html">Vitis™ Tutorials</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../README.html" class="icon icon-home"></a> &raquo;</li>
      <li>Memory Allocation Concepts</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/docs/Runtime_and_System_Optimization/Introduction/runtime_sw_design.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <table width="100%">
 <tr width="100%">
    <td align="center"><img src="https://www.xilinx.com/content/dam/xilinx/imgs/press/media-kits/corporate/xilinx-logo.png" width="30%"/><h1>2020.1 Vitis™ - Runtime and System Optimization - Runtime SW Design</h1>
    <a href="https://www.xilinx.com/products/design-tools/vitis.html">See Vitis™ Development Environment on xilinx.com</a>
    </td>
 </tr>
</table><div class="section" id="memory-allocation-concepts">
<h1>Memory Allocation Concepts<a class="headerlink" href="#memory-allocation-concepts" title="Permalink to this heading">¶</a></h1>
<p>When you run a program on a CPU, you don’t generally worry about how the underlying hardware manages memory.
There are occasional issues with alignment, etc. on some processor architectures, but largely modern OSes and
compilers abstract these things to a degree where they’re not usually visible unless you deal with a lot of
low-level driver work (or acceleration).</p>
<p>Fundamentally, we can think of memory as broadly having a set of six attributes. Given a pointer to a data
buffer, that data pointer may be <strong>virtual</strong> or <strong>physical</strong>.  The memory to which it points may be <strong>paged</strong>
or <strong>physically contiguous</strong>.  And, finally, from the standpoint of the processor that memory may be
<strong>cacheable</strong> or <strong>non-cacheable</strong>.</p>
<p>Most modern operating systems make use of virtual memory.  There are many reasons for doing so, but to keep
this document from veering off course and morphing into a computer architecture textbook, just know that
Linux, which is likely running your XRT, uses virtual memory.  As a result, when you use a standard C or C++
userspace API function such as malloc() or new, you wind up with a pointer to a virtual memory address, not a
physical one.</p>
<p>You will also likely wind up with a pointer to a block of addresses in memory that is <strong>paged</strong>.  Nearly every
modern OS (again including Linux) divides the address range into pages, typically with each page having a size
of 4 KiB (although this can vary system to system).  Each page is then mapped to a corresponding page in the
physical memory.  And before someone points out that this is an inaccurately simplified generalization, I
would like to respectfully remind you that this isn?t a computer architecture course!</p>
<p>There are two important things to note, though.  The first is that when you allocate a buffer from the heap
with standard C APIs, you?re not getting a physical memory address back.  And second, you’re not getting a
single buffer - you’re getting a collection of N memory pages, each 4 KiB long.  To put that in context, say
we allocate a buffer of 6 MiB.  That would give us:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">1024</span> <span class="n">B</span> <span class="o">*</span> <span class="mi">1024</span> <span class="n">B</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span> <span class="n">B</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">536</span> <span class="n">Pages</span>
</pre></div>
</div>
<p>If you wanted to copy that entire 6 MiB buffer from the host to your Alveo Data Center accelerator card, you
would need to resolve 1536 virtual page addresses to physical memory address.  You would then need to assemble
these physical addresses into a scatter gather list to enqueue to a DMA engine with scatter-gather capability,
which would then copy those pages one-by-one to their destination.  It also works in reverse if you were to
copy a buffer from the Alveo card to a virtual, paged address range in host memory.  Host processors are
generally quite fast, and as a result building this list doesn’t take a huge amount of time.  But given
decently large buffers, this can contribute to the overall system latency, so it’s important to understand the
implications this can have on your overall system performance.</p>
<p>For a simplified graphical view of such a system, refer to the figure below.  In this example we have two
buffers, creatively named A and B.  Both A and B are virtual buffers.  In our example we want to transfer A to
Alveo, do something to it that results in an update to buffer B, and transfer it back.   You can see how the
virtual to physical mapping works.  Within the Alveo card, accelerators operate only on physical memory
addresses and data is always stored contiguously; this is primarily because this configuration generally
provides the best performance.</p>
<p><img alt="Non-Contiguous Memory Transfer to Alveo" src="../../../_images/runtime_virtual_memory.jpg" /></p>
<p>As you can see, our simplified example data flow is already somewhat complex!  Now, imagine that across a
significantly large buffer: one spanning many megabytes (or gigabytes) with thousands and thousands of pages.
You can see how building and managing those scatter gather lists and managing the page tables can become time
consuming even for a fast host processor.  In reality, memory is not usually quite so fragmented as our
example.  But because you don’t usually know the physical addresses of the pages ahead of time, you must treat
them as though each one is unique.</p>
<p>It’s much easier to build a scatter gather list, though, if you know that all of the pages are contiguous in
physical memory.  That is, the data bytes are laid out sequentially, where incrementing the physical address
gives you data[n+1].  In that case, you can build a scatter gather list knowing only the start address of the
buffer and its size.</p>
<p>This is a benefit for many DMA operations, not just DMA to and from  the Alveo card.  Modern operating systems
provide memory allocators (typically through kernel services) for just this purpose.  In Linux this is done
through the Contiguous Memory Allocator subsystem.  This is kernel-space functionality but is exposed to users
through a variety of mechanisms including dmabuf, the XRT API, various graphics drivers, and other things.  If
we allocate the previous buffer contiguously we wind up with a much simpler view of the world, as shown below.</p>
<p><img alt="Contiguous Memory Layout Example" src="../../../_images/runtime_contiguous_memory.jpg" /></p>
<p>You might be wondering what happens if your buffer doesn’t begin on an aligned 4k page boundary.  Good
question!   DMA engines generally require some degree of alignment, and the Alveo DMA is no different.  If
your allocated memory is not aligned to a page boundary the runtime will align it for you.  Although you will
incur a memcpy() operation, which is expensive computationally.  You will also see a warning from the runtime
(assuming you haven?t suppressed them) because this is a problem you’ll want to resolve as quickly as
possible. Identifying and fixing this issue is addressed later on.</p>
<p>Finally, we must understand whether our memory is <strong>cacheable</strong> or <strong>non-cacheable</strong>.  Because external memory
access is expensive, nearly all modern processors maintain an internal cache of data with very low latency.
Depending on the processor architecture, the size of the cache may vary from tens of kilobytes to many
megabytes.  This internal cache memory is synchronized with the external physical memory as needed.  Generally
this cache management is invisible to the software running on the processor - you would see the benefit of
using a cache in your improved execution times, but you don?t have to interact with it from a general
development perspective.</p>
<p>However, when using DMA it?s important to recognize that, absent cache coherency sharing technologies such as
CCIX, you must ensure that any data the processor wants to share with the accelerator is synchronized with the
external memory before it’s transferred.  Before starting a DMA transfer you need to ensure that data resident
in the cache is <strong>flushed</strong> to external memory.  Similarly, once data is transferred back you must ensure that
data resident in the cache is <strong>invalidated</strong> so it will be refreshed from the external memory.
These operations  are very fast for x86-style processors, and are transparently handled by the runtime, but
other architectures  may have performance penalties for cache management.  To mitigate this, the API has
functionality for allocating and working with non-cacheable buffers.  Do keep in mind, though, that a
processor accessing data in a non-cacheable buffer will generally be much slower than just running cache
management operations in the first place.  This is usually used for models where the processor is sequencing buffers but not actually accessing the data they contain.</p>
</div>
<div class="section" id="alveo-guided-software-introduction">
<h1>Alveo Guided Software Introduction<a class="headerlink" href="#alveo-guided-software-introduction" title="Permalink to this heading">¶</a></h1>
<p>Whew, that?s a lot of background! Let?s quickly recap the important points before we jump into the guided software example:</p>
<ul class="simple">
<li><p>Acceleration is generally done on some intersection of two axes: trying to do the same task <strong>faster</strong>
(Amdahl’s Law), or trying to do more tasks in the <strong>same time</strong> (Gustafson’s Law).  Each axis has different
implications on how to optimize, and how impactful that optimization will be.</p></li>
<li><p>Acceleration inherently comes with an ?acceleration tax.?  To achieve acceleration in a real system, the
benefits achieved by acceleration must dominate the extra latency of the data transfers.  You should pick
your battles; focus on the biggest ?bang for the buck? pieces of your algorithms.</p></li>
<li><p>Interaction with the Alveo cards is done through XRT and higher-level API abstractions like OpenCL or the
XRT Native API.  Software-side optimization is done via the library, independent of the optimization of the
hardware kernels.</p></li>
<li><p>Memory allocation and management can have a significant effect on your overall application performance.</p></li>
</ul>
<p>We will explore all of these topics in detail in the examples.</p>
<p>Read <a class="reference internal" href="guided_sw_examples.html"><span class="doc">Next Section: Guided Software Examples</span></a></p>
<p align="center"><sup>Copyright&copy; 2019 Xilinx</sup></p></div>


           </div>
          </div>
          
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
				  
				  <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, Xilinx, Inc. Xilinx is now a part of AMD.
      <span class="lastupdated">Last updated on May 16, 2022.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>