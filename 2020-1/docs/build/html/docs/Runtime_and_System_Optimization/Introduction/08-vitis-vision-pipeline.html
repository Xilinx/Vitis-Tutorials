<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
  <title>Overview &mdash; Vitis™ Tutorials 2022.1 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../../../README.html" class="icon icon-home"> Vitis™ Tutorials
            <img src="../../../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2022.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">日本語版</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/master/docs-jp/README.html">Master</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting Started Pathway</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Getting_Started/Vitis/README.html">Vitis Flow 101 Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Getting_Started/Vitis_HLS/README.html">Vitis HLS Analysis and Optimization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Hardware Accelerators</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Hardware_Accelerators/Design_Tutorials/02-bloom/README.html">Optimizing Accelerated FPGA Applications: Bloom Filter Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Hardware_Accelerators/Design_Tutorials/01-convolution-tutorial/README.html">Optimizing Accelerated FPGA Applications: Convolution Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Hardware_Accelerators/Design_Tutorials/03-rtl_stream_kernel_integration/README.html">Mixed Kernels Design Tutorial with AXI Stream and Vitis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Hardware_Accelerators/Feature_Tutorials/01-rtl_kernel_workflow/README.html">Getting Started with RTL Kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Hardware_Accelerators/Feature_Tutorials/02-mixing-c-rtl-kernels/README.html">Mixing C++ and RTL Kernels</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Runtime and System Optimization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Design_Tutorials/01-host-code-opt/README.html">Host Code Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Design_Tutorials/02-ivas-ml/README.html">IVAS ZCU104 ML Acceleration Reference Release</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Feature_Tutorials/01-mult-ddr-banks/README.html">Using Multiple DDR Banks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Feature_Tutorials/02-using-multiple-cu/README.html">Using Multiple Compute Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Feature_Tutorials/03-controlling-vivado-implementation/README.html">Controlling Vivado Implementation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Vitis Platform Creation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Vitis_Platform_Creation/Introduction/01-Overview/README.html">Platform Creation Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Vitis_Platform_Creation/Introduction/02-Edge-AI-ZCU104/README.html">Vitis Custom Embedded Platform Creation Example on ZCU104</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/">Main</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../README.html">Vitis™ Tutorials</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../README.html" class="icon icon-home"></a> &raquo;</li>
      <li>Overview</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/docs/Runtime_and_System_Optimization/Introduction/08-vitis-vision-pipeline.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <table width="100%">
 <tr width="100%">
    <td align="center"><img src="https://www.xilinx.com/content/dam/xilinx/imgs/press/media-kits/corporate/xilinx-logo.png" width="30%"/><h1>2020.1 Vitis™ - Runtime and System Optimization<br />Example 8: Image Processing Pipeline with Vitis Vision</h1>
    <a href="https://www.xilinx.com/products/design-tools/vitis.html">See Vitis™ Development Environment on xilinx.com</a>
    </td>
 </tr>
</table><div class="section" id="overview">
<h1>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">¶</a></h1>
<p>We looked at a straightforward bilateral resize algorithm in the last example.  While we saw that it wasn’t
an amazing candidate for acceleration, perhaps you might want to simultaneously convert a buffer to a number
of different resolutions (say for different machine learning algorithms).  Or, you might just want to offload
it to save CPU availability for other processing during a frame window.</p>
<p>But, let’s explore the real beauty of FPGAs: streaming.  Remember that going back and forth to memory is
expensive, so instead of doing that let’s just send each pixel of the image along to another image processing
pipeline stage without having to go back to memory by simply streaming from one operation to the next.</p>
<p>In this case, we want to amend our earlier sequence of events to add in a <strong>Gaussian Filter</strong>.  This is a
very common pipeline stage to remove noise in an image before an operation such as edge detection, corner
detection, etc.  We may even intend to add in some 2D filtering afterwards, or some other algorithm.</p>
<p>So, modifying our workflow from before, we now have:</p>
<ol class="simple">
<li><p>Read the pixels of the image from memory.</p></li>
<li><p>If necessary, convert them to the proper format. In our case we’ll be looking at the default format used
by the OpenCV library, BGR. But in a real system where you’d be receiving data from various streams,
cameras, etc. you’d have to deal with formatting, either in software or in the accelerator (where it’s
basically a “free” operation, as we’ll see in the next example).</p></li>
<li><p>For color images, extract each channel.</p></li>
<li><p>Use a bilateral resizing algorithm on each independent channel.</p></li>
<li><p>Perform a Gaussian blur on each channel.</p></li>
<li><p>Recombine the channels and store back in memory.</p></li>
</ol>
<p>So, we now have two “big” algorithms: bilateral resize and Gaussian blur. For a resized image of <code class="docutils literal notranslate"><span class="pre">wout</span> <span class="pre">×</span> <span class="pre">hout</span></code>,
and a square gaussian window of width <code class="docutils literal notranslate"><span class="pre">k</span></code>, our computation time for the entire pipeline would be roughly:</p>
<p><img alt="Image Processing Time" src="../../../_images/08-formula-1.jpg" /></p>
<p>For fun, let’s make <code class="docutils literal notranslate"><span class="pre">k</span></code> relatively large without going overboard: we’ll choose a 7 × 7 window.</p>
</div>
<div class="section" id="key-code">
<h1>Key Code<a class="headerlink" href="#key-code" title="Permalink to this heading">¶</a></h1>
<p>For this algorithm we’ll continue to use of the <strong>Vitis Vision</strong>libraries.</p>
<p>As before, we’ll configure the library (in the hardware, via templates in our hardware source files) to process eight pixels per clock cycle.  Functionally, our hardware algorithm is now equivalent to this in standard software OpenCV:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cv</span><span class="o">::</span><span class="n">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">resize_ocv</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="n">out_width</span><span class="p">,</span><span class="w"> </span><span class="n">out_height</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">CV_INTER_LINEAR</span><span class="p">);</span><span class="w"></span>
<span class="n">cv</span><span class="o">::</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="n">resize_ocv</span><span class="p">,</span><span class="w"> </span><span class="n">result_ocv</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">),</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">BORDER_CONSTANT</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>We’re resizing as in <a class="reference internal" href="07-image-resizing-with-vitis-vision.html"><span class="doc">Example 7</span></a>, and as we mentioned are applying a
7 × 7 window to the Gaussian blur function.  We have also (arbitrarily) selected σx = σy =3.0</p>
</div>
<div class="section" id="running-the-application">
<h1>Running the Application<a class="headerlink" href="#running-the-application" title="Permalink to this heading">¶</a></h1>
<p>With the XRT initialized, run the application by running the following command from the build directory:</p>
<p><code class="docutils literal notranslate"><span class="pre">./08_opencv_resize</span> <span class="pre">alveo_examples</span> <span class="pre">&lt;path_to_image&gt;</span></code></p>
<p>Because of the way we’ve configured the hardware in this example, your image must conform to certain requirements.  Because we’re processing eight pixels per clock, your input width must be a multiple of eight.</p>
<p>If it isn’t then the program will output an error message informing you which condition was not satisfied.  This is of course not a fundamental requirement of the library; we can process images of any resolution and other numbers of pixels per clock.  But, for optimal performance if you can ensure the input image meets certain requirements you can process it significantly faster.  In addition to the resized images from both the hardware and software OpenCV implementations, the program will output messages similar to this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>-- Example 8: OpenCV Image Resize and Blur --

OpenCV conversion done!  Image resized 1920x1080 to 640x360 and blurred 7x7!
Starting Xilinx OpenCL implementation...
Matrix has 3 channels
Found Platform
Platform Name: Xilinx
XCLBIN File Name: alveo_examples
INFO: Importing ./alveo_examples.xclbin
Loading: ’./alveo_examples.xclbin’

OpenCV resize operation:            7.170 ms
OpenCL initialization:              275.349 ms
OCL input buffer initialization:    4.347 ms
OCL output buffer initialization:   0.131 ms
FPGA Kernel resize operation:       4.788 ms
</pre></div>
</div>
<p>In the previous example the CPU and the FPGA were pretty much tied for the small example.  But while we’ve added a significant processing time for the CPU functions, the FPGA runtime hasn’t increased much at all!</p>
<p>Let’s now double the input size, going from a 1080p image to a 4k image.  Change the code for this example, as we did with <a class="reference internal" href="07-image-resizing-with-vitis-vision.html"><span class="doc">Example 7</span></a> and recompile.</p>
<p>Running the example again, we see something very interesting:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>-- Example 8: OpenCV Image Resize and Blur --
OpenCV conversion done!  Image resized 1920x1080 to 3840x2160 and blurred 7x7!
Starting Xilinx OpenCL implementation...
Matrix has 3 channels
Found Platform
Platform Name: Xilinx
XCLBIN File Name: alveo_examples
INFO: Importing ./alveo_examples.xclbin
Loading: ’./alveo_examples.xclbin’

OpenCV resize operation:            102.977 ms
OpenCL initialization:              250.000 ms
OCL input buffer initialization:    3.473 ms
OCL output buffer initialization:   7.827 ms
FPGA Kernel resize operation:       7.069 ms
</pre></div>
</div>
<p>What wizardry is this!? The CPU runtime has increased by nearly 10x, but the FPGA runtime has barely moved at
all!</p>
<p>Like we said, FPGAs are _really+ good at doing things in pipelines.  This algorithm isn’t I/O bound, it’s
processor bound.  We can decompose it to process more data faster (Amdahl’s Law) by calculating multiple
pixels per clock, and by streaming from one operation to the next and doing more operations in parallel
(Gustafson’s Law).  We can even decompose the Gaussian Blur into individual component calculations and run
those in parallel (which wehave done, in the Vitis Vision library).</p>
<p>Now that we’re bound by computation and not bandwidth we can easily see the benefits of acceleration.  If we
put this in terms of FPS, our x86-class CPU instance can now process 9 frames per second while our FPGA card
can handle a whopping 141.  And adding additional operations will continue to bog down the CPU, but so long
as you don’t run out of resources in the FPGA you can effectively continue this indefinitely.  In fact, our
kernels are still quite small compared to the resource availability on the Alveo U200 card.</p>
<p>To compare it to the previous example, again for a 1920x1200 input image, we get the results shown below.
The comparison column will compare the “Scale Up” results from
<a class="reference internal" href="07-image-resizing-with-vitis-vision.html"><span class="doc">Example 7</span></a> with the scaled up results from this example.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Operation</th>
<th align="center">Scale Down</th>
<th align="center">Scale Up</th>
<th align="center">&Delta;7&rarr;8</th>
</tr>
</thead>
<tbody>
<tr>
<td>Software Resize</td>
<td align="center">7.170 ms</td>
<td align="center">102.977 ms</td>
<td align="center">91.285 ms</td>
</tr>
<tr>
<td>Hardware Resize</td>
<td align="center">4.788 ms</td>
<td align="center">7.069 ms</td>
<td align="center">385 &micro;s</td>
</tr>
<tr>
<td>&Delta;Alveo&rarr;CPU</td>
<td align="center">−2.382 ms</td>
<td align="center">−95.908 mss</td>
<td align="center">−90.9 ms</td>
</tr>
</tbody>
</table><p>We hope you can see the advantage!</p>
</div>
<div class="section" id="extra-exercises">
<h1>Extra Exercises<a class="headerlink" href="#extra-exercises" title="Permalink to this heading">¶</a></h1>
<p>Some things to try to build on this experiment:</p>
<ul class="simple">
<li><p>Edit the host code to play with the image sizes.  How does the run time change if you scale up more?  Down
more?  Where is the crossover point where it no longer makes sense to use an accelerator in this case?</p></li>
<li><p>What is the extra hardware latency?</p></li>
</ul>
</div>
<div class="section" id="key-takeaways">
<h1>Key Takeaways<a class="headerlink" href="#key-takeaways" title="Permalink to this heading">¶</a></h1>
<ul class="simple">
<li><p>Pipelining and streaming from one operation to the next in the fabric is beneficial.</p></li>
<li><p>Using FPGA-optimized libraries like xf::OpenCV allows you to easily trade off processing speed vs.
resources, without having to re-implement common algorithms on your own.  Focus on the interesting parts of
your application!</p></li>
<li><p>Some library optimizations you can choose can impose constraints on your design - double check the
documentation for the library function(s) you choose before you implement the hardware!</p></li>
</ul>
<p>That concludes our runtime introductory tutorial! We certainly hope you found it useful! Please
take the opportunity to smash that like button and subscr… wait, wrong venue. But do take the
time to review our <a class="reference internal" href="../README.html"><span class="doc">many other tutorials</span></a>, and thanks for reading!</p>
<p align="center"><sup>Copyright&copy; 2019 Xilinx</sup></p></div>


           </div>
          </div>
          
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
				  
				  <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, Xilinx, Inc. Xilinx is now a part of AMD.
      <span class="lastupdated">Last updated on May 16, 2022.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>