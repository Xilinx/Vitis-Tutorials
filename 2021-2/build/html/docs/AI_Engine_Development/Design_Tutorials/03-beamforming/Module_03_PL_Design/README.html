<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
  <title>Building the Design &mdash; Vitis™ Tutorials 2021.2 documentation</title>
      <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../../../../../index.html" class="icon icon-home"> Vitis™ Tutorials
            <img src="../../../../../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2021.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">日本語版</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/master/docs-jp/index.html">Master</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Getting_Started/Vitis-Getting-Started.html">Getting Started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Acceleration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Hardware_Acceleration/Hardware-Acceleration.html">Hardware Acceleration</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">AI Engine</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../AI_Engine_Development.html">AI Engine Development</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Platforms</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Vitis_Platform_Creation/Vitis_Platform_Creation.html">Vitis Platform Creation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/index.html">Main</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2021-1/build/html/index.html">2021.1</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-2/docs/build/html/index.html">2020.2</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-1/docs/build/html/README.html">2020.1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">Vitis™ Tutorials</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Building the Design</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../_sources/docs/AI_Engine_Development/Design_Tutorials/03-beamforming/Module_03_PL_Design/README.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <table class="sphinxhide" width="100%">
 <tr width="100%">
    <td align="center"><img src="https://raw.githubusercontent.com/Xilinx/Image-Collateral/main/xilinx-logo.png" width="30%"/><h1>AI Engine Development</h1>
    <a href="https://www.xilinx.com/products/design-tools/vitis.html">See Vitis™ Development Environment on xilinx.com</br></a>
    <a href="https://www.xilinx.com/products/design-tools/vitis/vitis-ai.html">See Vitis-AI™ Development Environment on xilinx.com</a>
    </td>
 </tr>
</table><div class="section" id="building-the-design">
<h1>Building the Design<a class="headerlink" href="#building-the-design" title="Permalink to this heading">¶</a></h1>
<p>The next step is to build the PL kernels (XO files). This design requires the creation of seven different RTL PL kernels. Run the following commands to build all of them.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make kernels
</pre></div>
</div>
<p>or</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> dlbf_data
vivado -mode batch -source run_dlbf_data.tcl -tclargs NO_SIM xcvc1902-vsva2197-2MP-e-S

<span class="nb">cd</span> ../dlbf_coeffs
vivado -mode batch -source run_dlbf_coeffs.tcl -tclargs NO_SIM xcvc1902-vsva2197-2MP-e-S

<span class="nb">cd</span> ../dlbf_slave
vivado -mode batch -source run_dlbf_slave.tcl -tclargs NO_SIM xcvc1902-vsva2197-2MP-e-S

<span class="nb">cd</span> ../ulbf_data
vivado -mode batch -source run_ulbf_data.tcl -tclargs NO_SIM xcvc1902-vsva2197-2MP-e-S

<span class="nb">cd</span> ../ulbf_coeffs
vivado -mode batch -source run_ulbf_coeffs.tcl -tclargs NO_SIM xcvc1902-vsva2197-2MP-e-S

<span class="nb">cd</span> ../ulbf_slave
vivado -mode batch -source run_ulbf_slave.tcl -tclargs NO_SIM xcvc1902-vsva2197-2MP-e-S

<span class="nb">cd</span> ../axi4s_regslice_64b
vivado -mode batch -source run_axi4s_regslice_64b.tcl -tclargs NO_SIM xcvc1902-vsva2197-2MP-e-S
</pre></div>
</div>
<p>The above make command creates the xilinx object files (XO) for PL kernels used in the design (highlighted in blue below).</p>
<p><img alt="Beamforming Block Diagram with Emphasis on PL Kernels" src="../../../../../_images/beamforming_block_diagram_pl_emphasis_3.PNG" /></p>
<div class="section" id="dependencies">
<h2>Dependencies<a class="headerlink" href="#dependencies" title="Permalink to this heading">¶</a></h2>
<p>Each PL kernel has <code class="docutils literal notranslate"><span class="pre">run_&lt;kernel_name&gt;.tcl</span></code>, <code class="docutils literal notranslate"><span class="pre">bd_&lt;kernel_name&gt;.tcl</span></code>, <code class="docutils literal notranslate"><span class="pre">kernel_&lt;kernel_name&gt;.xml</span></code>, and <code class="docutils literal notranslate"><span class="pre">hdl/*.v</span></code> RTL code as dependencies.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Filename</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>bd_\&lt;kernel_name>.tcl</td>
<td>The Tcl script that creates the block design in the Vivado project.</td>
</tr>
<tr>
<td>kernel_\&lt;kernel_name>.xml</td>
<td>The XML file that specifies the ports and defines the PL kernel.</td>
</tr>
</tbody>
</table><p>The <code class="docutils literal notranslate"><span class="pre">hdl/</span></code> folder in each PL kernel folder contains the Verilog RTL that is used to create the PL kernels.</p>
<div class="section" id="pl-master-kernels">
<h3>PL Master Kernels<a class="headerlink" href="#pl-master-kernels" title="Permalink to this heading">¶</a></h3>
<p>The PL Master kernels are the <code class="docutils literal notranslate"><span class="pre">dlbf_data</span></code>, <code class="docutils literal notranslate"><span class="pre">dlbf_coeffs</span></code>, <code class="docutils literal notranslate"><span class="pre">ulbf_data</span></code>, and <code class="docutils literal notranslate"><span class="pre">ulbf_coeffs</span></code> kernels. The RTL for these kernels consists of the following modules:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Filename</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>hdl/\&lt;kernel_name>.v</td>
<td><strong>PL Kernel Top-Level Module:</strong> Contains a design_\&lt;kernel_name>_wrapper, multiple data master modules (four for DLBF or eight for ULBF), a control status register module, and a clock domain crossing module.</td>
</tr>
<tr>
<td>hdl/\&lt;kernel_name>_cdc.v</td>
<td><strong>Clock Domain Crossing Module:</strong> Converts 100 MHz control signals from the PS to 400 MHz signals to communicate with data master modules. Converts 400 MHz status/data signals from data master modules to 100 MHz signals to send to the PS.</td>
</tr>
<tr>
<td>hdl/\&lt;kernel_name>_cntrl.v</td>
<td><strong>Control Module:</strong> Used to read the status registers of the data master modules.</td>
</tr>
<tr>
<td>hdl/\&lt;kernel_name>_csr_cntrl.v</td>
<td><strong>Control Status Register Module:</strong> Defines the control/status register mapping of the PL kernel.</td>
</tr>
<tr>
<td>hdl/\&lt;kernel_name>_ram2axis_64b.v</td>
<td><strong>RAM to AXI4-Stream Module:</strong> Communicates with the XPM RAM module to read data using the AXI4-Stream protocol. This module instantiates the XPM RAM module which contains a BRAM instance.</td>
</tr>
<tr>
<td>hdl/\&lt;kernel_name>_xpm_ram.v</td>
<td><strong>XPM RAM Module:</strong> BRAM instance used to store the input data.</td>
</tr>
<tr>
<td>hdl/\&lt;kernel_name>_xpm_sync_fifo.v</td>
<td><strong>XPM Sync FIFO Module:</strong> A FIFO between the XPM RAM module and AI Engine. It stores the input data from XPM RAM module before sending it to AI Engine. It stores 32 words total. Each word is 64 bits.</td>
</tr>
<tr>
<td>hdl/\&lt;kernel_name>_master.v</td>
<td><strong>Data Master Module:</strong> Contains a control module, a RAM to AXI4-Stream module, and an XPM sync FIFO module.</td>
</tr>
</tbody>
</table></div>
<div class="section" id="pl-slave-kernels">
<h3>PL Slave Kernels<a class="headerlink" href="#pl-slave-kernels" title="Permalink to this heading">¶</a></h3>
<p>The PL Slave kernels are the <code class="docutils literal notranslate"><span class="pre">dlbf_slave</span></code> and <code class="docutils literal notranslate"><span class="pre">ulbf_slave</span></code> kernels. The RTL for these kernels consists of the following modules:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Filename</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>hdl/\&lt;kernel_name>.v</td>
<td><strong>PL Kernel Top-Level Module:</strong> Contains a clock domain crossing module, a control module, and a RAM module.</td>
</tr>
<tr>
<td>hdl/\&lt;kernel_name>_cdc.v</td>
<td><strong>Clock Domain Crossing Module:</strong> Clock domain crossing module. Converts 100 MHz control signals from the PS to 400 MHz signals to communicate with the RAM module. Converts 400 MHz status/data signals from the RAM module to 100 MHz signals to send to the PS.</td>
</tr>
<tr>
<td>hdl/\&lt;kernel_name>_cntrl.v</td>
<td><strong>Control Status Register Module:</strong> Defines the control/status register mapping of the PL kernel.</td>
</tr>
<tr>
<td>hdl/\&lt;kernel_name>_ram.v</td>
<td><strong>RAM Module:</strong> URAM instance used to store the output data from AI Engine.</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="build-products">
<h2>Build Products<a class="headerlink" href="#build-products" title="Permalink to this heading">¶</a></h2>
<p>Each PL kernel results in the following build products:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Filename</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>\&lt;kernel_name>.xo</td>
<td>The Xilinx Object file in which the PL kernel is packaged.</td>
</tr>
<tr>
<td>\&lt;kernel_name> directory</td>
<td>Directory containing the Vivado project for the PL kernel.</td>
</tr>
</tbody>
</table></div>
<div class="section" id="pl-kernels-master-and-slaves">
<h2>PL Kernels: Master and Slaves<a class="headerlink" href="#pl-kernels-master-and-slaves" title="Permalink to this heading">¶</a></h2>
<p>Now that you have an AI Engine application, the next step is to find a way to send the input data and store the output data on hardware. This is accomplished by creating PL master kernels that store the input data in block RAM and feed it to the AI Engine. Reference inputs are used in this design to mimic data flow that would come from a radio antenna. PL slave kernels, which receive AI Engine output data and store it into URAM resources, must also be created.</p>
<div class="section" id="id1">
<h3>PL Master Kernels<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h3>
<p>The PL master kernels are the <code class="docutils literal notranslate"><span class="pre">dlbf_data</span></code>, <code class="docutils literal notranslate"><span class="pre">dlbf_coeff</span></code>, <code class="docutils literal notranslate"><span class="pre">ulbf_data</span></code>, and <code class="docutils literal notranslate"><span class="pre">ulbf_coeff</span></code> kernels. A <code class="docutils literal notranslate"><span class="pre">dlbf_data</span></code> PL kernel stores the reference input data matrices for the downlink subgraph in the AI Engine graph. The <code class="docutils literal notranslate"><span class="pre">dlbf_coeff</span></code> PL kernel stores the reference input coefficients for the downlink subgraph. The <code class="docutils literal notranslate"><span class="pre">ulbf_data</span></code> PL kernel stores the input data for the uplink subgraph. The <code class="docutils literal notranslate"><span class="pre">ulbf_coeff</span></code> stores the input coefficient data for the uplink subgraph.</p>
<p>Open the Vivado projects for these PL kernels and review their source code. They are all composed of the same modules: a AXI BRAM Controller IP, a control status register (CSR) module, a clock domain crossing (CDC) module, and multiple data master modules. The data master modules are initialized with the reference input data and input coefficients from <code class="docutils literal notranslate"><span class="pre">*_hex.mem</span></code> files in the <code class="docutils literal notranslate"><span class="pre">data/</span></code> folder.</p>
<p><img alt="PL Master Kernel Vivado Screenshot" src="../../../../../_images/pl_master_data_kernel_vivado.png" /></p>
<p>The <code class="docutils literal notranslate"><span class="pre">*_hex.mem</span></code>files were generated by a python script that converted the decimal data in the <code class="docutils literal notranslate"><span class="pre">*.txt</span></code> files to hexidecimal data. An example conversion is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#Decimal data in dlbf_cin00.txt</span>
<span class="o">-</span><span class="mi">1893</span> <span class="mi">3687</span> <span class="o">-</span><span class="mi">6157</span> <span class="o">-</span><span class="mi">1324</span>

<span class="c1">#Hexidecimal conversion in dlbf_cin00_hex.mem</span>
<span class="n">fad4e7f30e67f89b</span>
</pre></div>
</div>
<p>Where rightmost decimal data (-1893) is converted to leftmost hexidecimal data (f89b).</p>
<p>Below is a block diagram of how data in the PL Master kernels is requested by CIPS and sent out to the AI Engine.</p>
<p><img alt="PL Master Kernel Block Diagram" src="../../../../../_images/pl_master_kernel_block_diagram.png" /></p>
<p>Each PL master kernel hooks up to one of the 16 AXI4-Lite PL interfaces on the custom platform built in Module 01 (Creating a Custom Platform). Through this connection, the CIPS block can send AXI control signals to the data master modules and receive AXI status signals from the data master modules.</p>
<ul class="simple">
<li><p><strong>AXI BRAM Controller:</strong> The AXI BRAM controller writes the control signals to the CSR module and reads the status signals from the CSR module at 100 MHz.</p></li>
<li><p><strong>Control Status Register (CSR) Module</strong>: The CSR module is a register interface that the AXI BRAM controller accesses to access the data masters. Below is the control and status register map for one data master module.</p></li>
</ul>
<p><em>Control and Status Register Address Map</em></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Register Space Offset</th>
<th>Bits and Name</th>
<th>R/W?</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0</td>
<td>[31:0] ID</td>
<td>R</td>
<td>32 bit ID register.</td>
</tr>
<tr>
<td>0x4</td>
<td>[0] RESET</td>
<td>W</td>
<td>1: assert, 0: deassert. Also assigned to the m_axis_rst_bram input in the CSR module.</td>
</tr>
<tr>
<td>0x4</td>
<td>[4] GO</td>
<td>W</td>
<td>1: start PL traffic, 0: stop PL traffic. Also assigned to the go_bram input in the CSR module.</td>
</tr>
<tr>
<td>0x8</td>
<td>[11:0] BLOCK_SIZE</td>
<td>W</td>
<td>Sets the block size of stream frame. Block size is the number of 64-bit TDATA packets to send to the AI Engine. TLAST is asserted for every <BLOCK_SIZE> number of cycles. Also assigned to the block_size_bram input in the CSR module.</td>
</tr>
<tr>
<td>0xC</td>
<td>[11:0] NITER</td>
<td>W</td>
<td>Sets the number of iterations of the data to go through. The number of iterations is the number of <BLOCK_SIZE> data chunks to send to the AI Engine. If this set to 0, data will be transmitted to the AI Engine forever. Also assigned to the niter_bram input in the CSR module.</td>
</tr>
<tr>
<td>0x10</td>
<td>[15:0] ROLLOVER_ADDR</td>
<td>W</td>
<td>When BRAM addresses reach this rollover address, it will reset to address 0. In this design, the rollover address is set to the address of four <BLOCK_SIZE> chunks of data (i.e. 4*<BLOCK_SIZE>). Also assigned to the rollover_addr_bram input in the CSR module.</td>
</tr>
<tr>
<td>0x20</td>
<td>[0] MASTER_DONE</td>
<td>R</td>
<td>When this status register becomes 1'b, the data master is done sending data to AI Engine. Also assigned to the <code>m0_done_bram</code> input in the CSR module.</td>
</tr>
</tbody>
</table><p>The CSR Module RTL definitions are located here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dlbf_data</span><span class="o">/</span><span class="n">hdl</span><span class="o">/</span><span class="n">ulbf_data_csr_cntrl</span><span class="o">.</span><span class="n">v</span>
<span class="n">dlbf_coeffs</span><span class="o">/</span><span class="n">hdl</span><span class="o">/</span><span class="n">dlbf_coeffs_csr_cntrl</span><span class="o">.</span><span class="n">v</span>
<span class="n">ulbf_data</span><span class="o">/</span><span class="n">hdl</span><span class="o">/</span><span class="n">ulbf_data_csr_cntrl</span><span class="o">.</span><span class="n">v</span>
<span class="n">ulbf_coeffs</span><span class="o">/</span><span class="n">hdl</span><span class="o">/</span><span class="n">ulbf_coeffs_csr_cntrl</span><span class="o">.</span><span class="n">v</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Clock Domain Crossing (CDC) Module:</strong> The control and status signals sent to the CSR module sync up with the data master modules through a clock domain crossing (CDC) module. It converts the 100 MHz control and status signals from CIPS to 400 MHz signals. The data master modules operate at 400 MHz. It also works the other way as well (converting 400 MHz signals from the data master modules to 100 MHz signals for CIPS).</p></li>
<li><p><strong>Data Master Modules:</strong> These modules contain BRAM instances that store the input data that is sent to the AI Engine. They are initialized by <code class="docutils literal notranslate"><span class="pre">data/*_hex.mem</span></code> files with input data. There are four data master modules in the <code class="docutils literal notranslate"><span class="pre">dlbf_data</span></code> and <code class="docutils literal notranslate"><span class="pre">dlbf_coeffs</span></code> PL kernels. There are eight data master modules in the <code class="docutils literal notranslate"><span class="pre">ulbf_data</span></code> and <code class="docutils literal notranslate"><span class="pre">ulbf_coeffs</span></code> PL kernels.</p></li>
</ul>
<div class="section" id="pl-master-execution-flow">
<h4>PL Master Execution Flow<a class="headerlink" href="#pl-master-execution-flow" title="Permalink to this heading">¶</a></h4>
<p>Through the control path (highlighted in blue in the block diagram above), CIPS block requests data from specific addresses to be sent from the data master modules to the AI Engine. The data master modules then send out the data at the requested address through an AXI4-Stream interface to the AI Engine. The AI Engine receives its downlink input data matrices, downlink input coefficient data, uplink input data matrices, and uplink input coefficient data this way. The PL masters must follow a certain execution flow to function properly.</p>
<div class="section" id="reset">
<h5>Reset<a class="headerlink" href="#reset" title="Permalink to this heading">¶</a></h5>
<p>First, the PL masters must be reset by asserting their RESET bits to 1’b1 and then deasserting them to 0’b1.</p>
</div>
<div class="section" id="configuration">
<h5>Configuration<a class="headerlink" href="#configuration" title="Permalink to this heading">¶</a></h5>
<p>The PL masters must then have their BLOCK_SIZE, NITER, and ROLLOVER_ADDR registers configured.</p>
<div class="section" id="block-size">
<h6>BLOCK_SIZE<a class="headerlink" href="#block-size" title="Permalink to this heading">¶</a></h6>
<p>The value you set the BLOCK_SIZE register to is determined by the number of 32-bit complex data samples you send to the AI Engine. Because the PL interface to the AI Engine is 64 bit, you can fit two 32-bit complex data samples in a single data packet. The BLOCK_SIZE register for each PL master kernel is as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>PL Kernels</th>
<th>AI Engine Window Size (Bytes)</th>
<th>Number of 32-Bit Complex Data Samples</th>
<th>Number of 64-Bit Data Packets (BLOCK_SIZE)</th>
</tr>
</thead>
<tbody>
<tr>
<td>dlbf_data ulbf_data</td>
<td>3072</td>
<td>768</td>
<td>384</td>
</tr>
<tr>
<td>dlbf_coeffs ulbf_coeffs</td>
<td>2048</td>
<td>512</td>
<td>256</td>
</tr>
</tbody>
</table></div>
<div class="section" id="niter-and-rollover-addr">
<h6>NITER and ROLLOVER_ADDR<a class="headerlink" href="#niter-and-rollover-addr" title="Permalink to this heading">¶</a></h6>
<p>The value of the NITER register determines the number BLOCK_SIZE chunks of input data to send of the AI Engine. Because there is a finite amount of BRAM resources, it is not possible to store a large amount of unique input data. A design choice has been made to store four BLOCK_SIZE chunks of unique data in the PL masters.</p>
<ul class="simple">
<li><p>When NITER &lt;=4, up to four unique BLOCK_SIZE chunks of data are sent to the AI Engine.</p></li>
<li><p>When NITER &gt; 4, the BRAMs send the four unique BLOCK_SIZE chunks of data, then the BRAM addresses roll over to address 0, and they start sending the same data again.</p></li>
</ul>
<p>The NITER register allows you to continuously feed the AI Engine graph input data for any NITER number of data chunks without using an high number of BRAMs.</p>
<p>The ROLLOVER_ADDR register contains the address that tells the BRAMs when to restart (or roll over) to address 0. The ROLLOVER_ADDR is calculated as the BLOCK_SIZE * 4. Four is the number of unique BLOCK_SIZE chunks of input data the PL masters store.</p>
<p>For example, to test the AI Engine graph on a variety of data inputs, set NITER to 4. This configures the PL kernels to send four &lt;BLOCK_SIZE&gt; chunks of unique input data to the AI Engine. To test performance, you can then set NITER to 100, which sends the same four chunks of input data to the AI Engine 25 times (for a total of 25*4 = 100 iterations). You can then average the throughput across the iterations to give a valid performance measurement. The following is a table of the rollover addresses:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>PL Kernels</th>
<th>BLOCK_SIZE</th>
<th>ROLLOVER_ADDR</th>
</tr>
</thead>
<tbody>
<tr>
<td>dlbf_data ulbf_data</td>
<td>384</td>
<td>1536</td>
</tr>
<tr>
<td>dlbf_coeffs ulbf_coeffs</td>
<td>256</td>
<td>1024</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="start">
<h5>Start<a class="headerlink" href="#start" title="Permalink to this heading">¶</a></h5>
<p>After configuration, the PL master kernels are ready to send the data stored in their BRAMs to the AI Engine. When the GO bit is asserted, the PL traffic to the AI Engine starts. Deasserting the GO bit stops PL traffic to the AI Engine.</p>
<p><img alt="PL Master Kernel Data Storage" src="../../../../../_images/PL_master_kernel_data_storage.png" /></p>
</div>
<div class="section" id="done">
<h5>Done<a class="headerlink" href="#done" title="Permalink to this heading">¶</a></h5>
<p>When the PL Master kernels have sent a BLOCK_SIZE number TDATA packets to the AI Engine for NITER number of times, then then they assert their MASTER_DONE bits.</p>
</div>
</div>
<div class="section" id="ip-kernelization">
<h4>IP Kernelization<a class="headerlink" href="#ip-kernelization" title="Permalink to this heading">¶</a></h4>
<p>Take a look at the <code class="docutils literal notranslate"><span class="pre">package_xo</span></code> command, which can be found in the last line of <code class="docutils literal notranslate"><span class="pre">run_*.tcl</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>package_xo -kernel_name ${IP_NAME} -ctrl_protocol user_managed -ip_directory [pwd]/../${IP_REPO}/${IP_NAME} -xo_path [pwd]/../${IP_REPO}/${IP_NAME}.xo -force -output_kernel_xml [pwd]/kernel_${IP_NAME}_auto.xml
</pre></div>
</div>
<p>First, the IP is created. The steps can be seen in <code class="docutils literal notranslate"><span class="pre">run_*.tcl</span></code> until <code class="docutils literal notranslate"><span class="pre">update_ip_catalog</span></code>. The packaged IP is then taken from the IP directory and provided to the <code class="docutils literal notranslate"><span class="pre">package_xo</span></code> command using the <code class="docutils literal notranslate"><span class="pre">-kernel_name</span></code> keyword. When the <code class="docutils literal notranslate"><span class="pre">package_xo</span></code> command kernelizes the IP, it outputs the <code class="docutils literal notranslate"><span class="pre">${IP_NAME}.xo</span></code> in the path provided by the <code class="docutils literal notranslate"><span class="pre">-xo_path</span></code>. The <code class="docutils literal notranslate"><span class="pre">-xo_path</span></code> cannot be the same as the <code class="docutils literal notranslate"><span class="pre">-ip_directory</span></code> path. The argument <code class="docutils literal notranslate"><span class="pre">-force</span></code> overwrites if there is a pre-existing XO file. The intermediate metadata file is generated by this command and is stored as <code class="docutils literal notranslate"><span class="pre">kernel_${IP_NAME}_auto.xml</span></code>.</p>
<p>More information can be found in this <a class="reference external" href="https://github.com/Xilinx/Vitis-Tutorials/blob/master/Hardware_Accelerators/Feature_Tutorials/01-rtl_kernel_workflow/package_ip.md">tutorial</a>.</p>
</div>
</div>
<div class="section" id="id2">
<h3>PL Slave Kernels<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<p>The PL slave kernels are the <code class="docutils literal notranslate"><span class="pre">dlbf_slave</span></code> and the <code class="docutils literal notranslate"><span class="pre">ulbf_slave</span></code> kernels. These kernels store the output data generated from the AI Engine application. Open the Vivado projects for the PL kernels and review their source code.</p>
<p><img alt="PL Slave Kernel Block Diagram" src="../../../../../_images/pl_slave_kernel_block_diagram.png" /></p>
<ul class="simple">
<li><p><strong>AXI BRAM Controller:</strong> The AXI BRAM Controller writes the control signals to the CSR module and reads the status signals from the CSR module at 100MHz.</p></li>
<li><p><strong>CSR Module:</strong> The CSR module is a register interface that the AXI BRAM Controller accesses to access the Slave RAM. Below is the control and status register map for one data master module.</p></li>
</ul>
<p><em>Control and Status Register Address Map</em></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Register Space Offset</th>
<th>Bits and Name</th>
<th>R/W?</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0</td>
<td>[31:0] ID</td>
<td>R</td>
<td>32-bit ID Register.</td>
</tr>
<tr>
<td>0x4</td>
<td>[0] RESET</td>
<td>W</td>
<td>1:assert, 0:de-assert. Also assigned to the <code>slave_rst_bram</code> input in CSR module.</td>
</tr>
<tr>
<td>0xC</td>
<td>[11:0] NITER</td>
<td>W</td>
<td>Sets the number of iterations of the data to receive. The number of iterations is the number of <BLOCK_SIZE> data chunks AI Engine produces and sends to the PL Slave kernels. If this set to 0, data will be transmitted from AI Engine forever. Also assigned to the niter_bram input in the CSR module.</td>
</tr>
<tr>
<td>0x20</td>
<td>[0] SLAVE_DONE</td>
<td>R</td>
<td>When this status register is 1'b, the RAM slave is done receiving data to AI Engine. Also assigned to the rxdone_bram input in the CSR module.</td>
</tr>
</tbody>
</table><ul class="simple">
<li><p><strong>CDC Module:</strong> The control and status signals sent to the CSR module sync up with the slave RAM module through a clock domain crossing (CDC) module. It converts the 100 MHz control and status signals from CIPS to 400 MHz signals. The slave RAM module operate at 400 MHz. It also works the other way as well (converting 400 MHz signals from the slave RAM modules to 100 MHz signals to send to the CIPS).</p></li>
<li><p><strong>Data Slave RAM Module:</strong> Contains the URAM instance that stores the output data produced by the AI Engine. There is one slave RAM module in the <code class="docutils literal notranslate"><span class="pre">dlbf_slave</span></code> and <code class="docutils literal notranslate"><span class="pre">ulbf_slave</span></code> PL kernels.</p></li>
</ul>
<div class="section" id="pl-slave-execution-flow">
<h4>PL Slave Execution Flow<a class="headerlink" href="#pl-slave-execution-flow" title="Permalink to this heading">¶</a></h4>
<p>The control path (highlighted in blue in the preceding block diagram) is the same as the one in the PL master kernels; however, the CSR module syncs with a data slave RAM module. The AI Engine writes its output data to a data slave RAM module through an AXI4-Stream interface. The AI Engine application writes its output data from downlink and uplink subgraphs to the <code class="docutils literal notranslate"><span class="pre">dlbf_slave</span></code> and <code class="docutils literal notranslate"><span class="pre">ulbf_slave</span></code> PL kernels this way. The PL slaves must follow a certain execution flow to function properly.</p>
<div class="section" id="id3">
<h5>Reset<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h5>
<p>Just like the PL masters, the PL slaves must first be reset by asserting their RESET bits to 1’b1 and then deasserting them to 0’b1.</p>
</div>
<div class="section" id="id4">
<h5>Configuration<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h5>
<p>The PL slaves must then have their BLOCK_SIZE, NITER, and ROLLOVER_ADDR registers configured.</p>
<div class="section" id="id5">
<h6>BLOCK_SIZE<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h6>
<p>Although there is no explicit BLOCK_SIZE register, PL slave kernels do receive &lt;BLOCK_SIZE&gt; chunks of data from the AI Engine as follows:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>PL Kernels</th>
<th>AI Engine Window Size (bytes)</th>
<th>Number of 32-Bit Complex Data Samples (BLOCK_SIZE)</th>
</tr>
</thead>
<tbody>
<tr>
<td>dlbf_slave</td>
<td>3072</td>
<td>768</td>
</tr>
<tr>
<td>ulbf_slave</td>
<td>3072</td>
<td>768</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="id6">
<h5>NITER and ROLLOVER_ADDR<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h5>
<p>The NITER register tells the PL slave kernel how many &lt;BLOCK_SIZE&gt; chunks of data to expect and store in their URAMs.</p>
<p>The PL slave kernels do not have a ROLLOVER_ADDR register because the aim is to keep all of the output data for functional verification. Data starts to be overwritten when NITER &gt; 4.</p>
</div>
<div class="section" id="id7">
<h5>Start<a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h5>
<p>The PL slave kernels are slaves to the AI Engine because the AI Engine writes output data to them. Because the PL kernels must wait until the AI Engine fills their URAMs, there is no GO bit on the PL slave kernels.</p>
</div>
<div class="section" id="id8">
<h5>Done<a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h5>
<p>When the PL slave kernels have received the &lt;BLOCK_SIZE&gt; amount of data for NITER number of times, they assert their SLAVE_DONE bits.</p>
</div>
</div>
</div>
<div class="section" id="axi4-stream-register-slice">
<h3>AXI4-Stream Register Slice<a class="headerlink" href="#axi4-stream-register-slice" title="Permalink to this heading">¶</a></h3>
<p>The AXI4-Stream Register Slice IP (axi_register_slice) is available in the IP Catalog. It is a flip-flop that is used to pipeline paths. It is used during timing closure (see Module 04).</p>
</div>
</div>
<div class="section" id="beamforming-design-downlink-ai-engine-graph">
<h2>Beamforming Design: Downlink AI Engine Graph<a class="headerlink" href="#beamforming-design-downlink-ai-engine-graph" title="Permalink to this heading">¶</a></h2>
<p>Each downlink AI Engine graph has four input data ports, 32 input coefficient ports, and eight output ports. A <code class="docutils literal notranslate"><span class="pre">dlbf_data</span></code> PL kernel has four AXI4-Stream output ports to that plug into the four input data ports of the downlink AI Engine graph. A <code class="docutils literal notranslate"><span class="pre">dlbf_coeffs</span></code> PL kernel has four AXI4-Stream output ports. So, eight <code class="docutils literal notranslate"><span class="pre">dlbf_coeffs</span></code> PL kernels are required to plug into the 4*8=32 input coefficient ports. A <code class="docutils literal notranslate"><span class="pre">dlbf_slave</span></code> PL kernel has one AXI4-Stream input port. So, eight <code class="docutils literal notranslate"><span class="pre">dlbf_slave</span></code> PL kernels are required to plug into the eight output ports.</p>
<p>Remember, our system instantiates three downlink graphs, so the total number of DLBF PL kernels becomes: three <code class="docutils literal notranslate"><span class="pre">dlbf_data</span></code>, 24 <code class="docutils literal notranslate"><span class="pre">dlbf_coeffs</span></code>, and 24 <code class="docutils literal notranslate"><span class="pre">dlbfs_slave</span></code> PL kernels.</p>
</div>
<div class="section" id="beamforming-design-uplink-ai-engine-graph">
<h2>Beamforming Design: Uplink AI Engine Graph<a class="headerlink" href="#beamforming-design-uplink-ai-engine-graph" title="Permalink to this heading">¶</a></h2>
<p>Each uplink AI Engine graph has eight input data ports, 32 input coefficient ports, and four output ports. A <code class="docutils literal notranslate"><span class="pre">ulbf_data</span></code> PL kernel has eight AXI4-Stream output ports that plug into the eight input data ports of the uplink AI Engine graph. A <code class="docutils literal notranslate"><span class="pre">ulbf_coeffs</span></code> PL kernel has eight AXI4-Stream output ports. So, four <code class="docutils literal notranslate"><span class="pre">ulbf_coeffs</span></code> PL kernels are required to plug into the 8*4=32 input coefficient ports. A <code class="docutils literal notranslate"><span class="pre">ulbf_slave</span></code> PL kernel has one AXI4-Stream input port. So, four <code class="docutils literal notranslate"><span class="pre">ulbf_slave</span></code> PL kernels are required to plug into the four output ports.</p>
<p>Remember, our system instantiates three uplink graphs, so the total number of ULBF PL kernels becomes: three <code class="docutils literal notranslate"><span class="pre">ulbf_data</span></code>, 12 <code class="docutils literal notranslate"><span class="pre">ulbf_coeffs</span></code>, and 12 <code class="docutils literal notranslate"><span class="pre">ulbf_slaves</span></code>.</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_2/vitis_doc/devrtlkernel.html#qnk1504034323350">Vitis Application Acceleration Development Flow Documentation, Developing Applications, RTL Kernels</a> - This is a reference on how to create your own custom RTL kernels. Please note that the PL kernels in this design do not completely adhere to the recommended guidelines.</p></li>
</ul>
</div>
</div>
<div class="section" id="support">
<h1>Support<a class="headerlink" href="#support" title="Permalink to this heading">¶</a></h1>
<p>GitHub issues will be used for tracking requests and bugs. For questions go to <a class="reference external" href="http://forums.xilinx.com/">forums.xilinx.com</a>.</p>
</div>
<div class="section" id="license">
<h1>License<a class="headerlink" href="#license" title="Permalink to this heading">¶</a></h1>
<p>Licensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License.</p>
<p>You may obtain a copy of the License at <a class="reference external" href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p align="center"> XD016 | &copy; Copyright 2021 Xilinx, Inc.</p></div>


           </div>
          </div>
          
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
				  
				  <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, Xilinx, Inc. Xilinx is now a part of AMD.
      <span class="lastupdated">Last updated on July 27, 2022.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>