<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
  <title>RTL Kernel: krnl_aes &mdash; Vitis™ Tutorials 2021.2 documentation</title>
      <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../../../../../index.html" class="icon icon-home"> Vitis™ Tutorials
            <img src="../../../../../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2021.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">日本語版</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/master/docs-jp/index.html">Master</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Getting_Started/Vitis-Getting-Started.html">Getting Started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Acceleration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware-Acceleration.html">Hardware Acceleration</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">AI Engine</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../AI_Engine_Development/AI_Engine_Development.html">AI Engine Development</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Platforms</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../Vitis_Platform_Creation/Vitis_Platform_Creation.html">Vitis Platform Creation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/index.html">Main</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2021-1/build/html/index.html">2021.1</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-2/docs/build/html/index.html">2020.2</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-1/docs/build/html/README.html">2020.1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">Vitis™ Tutorials</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>RTL Kernel: krnl_aes</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../_sources/docs/Hardware_Acceleration/Design_Tutorials/05-bottom_up_rtl_kernel/doc/krnl_aes.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="rtl-kernel-krnl-aes">
<h1>RTL Kernel: krnl_aes<a class="headerlink" href="#rtl-kernel-krnl-aes" title="Permalink to this heading">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h2>
<p>In this part of the tutorial, you will start with the Aes module you created in <a class="reference internal" href="aes.html"><span class="doc">RTL Module: Aes</span></a>. You will add RTL logics, then pack them into Vivado® IP and Vitis Kernel (XO) file. This Vitis™ Kernel file can be used directly in the Vitis v++ flow to build XCLBIN overlay files, and the user can use the XRT library to realize the kernel control and data transfer between the host and the kernel.</p>
</div>
<div class="section" id="kernel-features">
<h2>Kernel Features<a class="headerlink" href="#kernel-features" title="Permalink to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> kernel includes four Aes modules, each of which are connected outside with AXI stream slave and master ports. There is also an AXI slave port for kernel control. To simplify the design, all Aes modules use the same settings (encrypt/decrypt mode, key length and key value).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> actually uses two clocks inside: one for external AXI ports and the other for internal AXI ports and AES cores. The AES cores run at a higher frequency than the platform AXI interconnections.</p>
<p>There are two methods to get the higher clock for the kernel.
One method is to use the secondary platform clock provided, namely <code class="docutils literal notranslate"><span class="pre">ap_clk_2</span></code> ports. In the Alveo™ Data Center accelerator card, the target platform has provided multiple clocks for the user kernel. For example, for the Alveo U200 <code class="docutils literal notranslate"><span class="pre">xilinx_u200_xdma_201830_2</span></code> platform, two system clocks are provided, <code class="docutils literal notranslate"><span class="pre">ap_clk</span></code> and <code class="docutils literal notranslate"><span class="pre">ap_clk_2</span></code>, whose default frequency is 300 MHz and 500 Mhz, respectively. The frequency can be configured in the Vitis v++ link process. <code class="docutils literal notranslate"><span class="pre">ap_clk_2</span></code> is generated by a standalone MMCM in the static region of the Alveo platform. The second method to get the additional clock is to manually instantiate an MMCM inside the RTL kernel. This might provide additional flexibility for some specific requirements.</p>
<p>The example design provided here uses the second method to generate the required clock. The <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> kernel includes a customized MMCM module to generate a 400 MHz clock from the standard 300 MHz input clock provided by the platform.</p>
<p>The UltraScale+™ Alveo target platform is divided into a static region and a dynamic region. The customer-instantiated MMCMs in the dynamic region are probably driven by an MMCM in the static region, which might be used to drive the platform bus clock. This usually causes big clock skew and makes it difficult for the synchronous design to meet timing. To ease the timing closure, those modules driven by the customer MMCM should operate in asynchronous mode to the platform bus clock. In this example design, the AXI slave control module and the four Aes engines all run in the 400MHz clock domain, while the kernel will be connected to 300MHz standard platform clock domain. So altogether nine AXI/AXIS clock converter IPs are used in the top level of the kernel: one AXI clock converter for AXI control slave, four AXIS clock converters for AXIS slave ports, and four AXIS clock converters for AXIS master ports.</p>
<p>Following is the block diagram of <em>krnl_aes</em> kernel.</p>
<div align="center">
<img src="./images/krnl_aes.svg" alt="krnl_aes Diagram" >
</div>
<br/><p>There are three kernel execution models for Vitis acceleration application supported by XRT: <em>ap_ctrl_none</em>, <em>ap_ctrl_hs</em> and <em>ap_ctrl_chain</em>. You can refer to <a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/managing_interface_synthesis.html?hl=ap_ctrl_chain#qls1539734256651__ae476299">ug1416</a>, <a class="reference external" href="https://xilinx.github.io/XRT/master/html/xrt_kernel_executions.html">Supported Kernel Execution Models</a> for more details. This RTL kernel <em>krnl_aes</em> is the mixing of <em>ap_ctrl_none</em> and <em>ap_ctrl_hs</em> modes: <em>ap_ctrl_hs</em> is used for AES key expansion operation, namely the host will start and wait for the finish of AES key expansion operation; <em>ap_ctrl_none</em> is used for general AES encryption/decryption operation, namely as soon as the kernel receives input data from AXI stream slave port, it will start and finish the encryption/decryption operation automatically and send the output data to AXI stream master port.</p>
<p>In <em>krnl_aes</em>, following control signal waveform is implemented for <em>ap_ctrl_hs</em> mode. XRT will assert <em>ap_start</em> signal to start the kernel execution, then <em>ap_start</em> will keep high and de-asserted by <em>ap_ready</em> signal. <em>ap_ready</em> is actually a copy of <em>ap_done</em> signal. Finally <em>ap_done</em> is cleared by read control register operation on AXI slave port. Please note that the XRT scheduler actually decides when to assert <em>ap_start</em> depending on the status of <em>ap_start</em>, that is, when XRT detects the <em>ap_start</em> is de-assert, it considers the kernel ready to receive new <em>ap_start</em> request.</p>
<div align="center">
<img src="./images/ap_ctrl_hs.svg" alt="ap_ctrl_hs mode" >
</div>
<br/><p>The table below lists all the control register and kernel arguments included in AXI slave port, no interrupt support in this kernel.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Name</th>
<th>Addr Offset</th>
<th>Width (bits)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CTRL</td>
<td>0x000</td>
<td>5</td>
<td>Control Signals.<br>bit 0  - ap_start <br>bit 1  - ap_done <br>bit 2  - ap_idle <br>bit 3  - ap_ready , copy version of ap_done in ap_ctrl_hs mode<br>bit 4  - ap_continue , no use in ap_ctrl_hs mode</td>
</tr>
<tr>
<td>MODE</td>
<td>0x010</td>
<td>1</td>
<td>Kernel cipher mode:<br> 0 - decryption <br> 1 - encryption</td>
</tr>
<tr>
<td>KEY_LEN</td>
<td>0x018</td>
<td>2</td>
<td>AES Key length:<br>2'b00=128bit<br>2'b01=192bit<br>2'b10=256bit</td>
</tr>
<tr>
<td>STATUS</td>
<td>0x020</td>
<td>4</td>
<td>Status of the 4 AES engines:<br>0 - idle<br>1 - busy</td>
</tr>
<tr>
<td>KEY_W7</td>
<td>0x028</td>
<td>32</td>
<td>AES key word 7</td>
</tr>
<tr>
<td>KEY_W6</td>
<td>0x030</td>
<td>32</td>
<td>AES key word 6</td>
</tr>
<tr>
<td>KEY_W5</td>
<td>0x038</td>
<td>32</td>
<td>AES key word 5</td>
</tr>
<tr>
<td>KEY_W4</td>
<td>0x040</td>
<td>32</td>
<td>AES key word 4</td>
</tr>
<tr>
<td>KEY_W3</td>
<td>0x048</td>
<td>32</td>
<td>AES key word 3. When key length is 128, this word is not used</td>
</tr>
<tr>
<td>KEY_W2</td>
<td>0x050</td>
<td>32</td>
<td>AES key word 2. When key length is 128, this word is not used</td>
</tr>
<tr>
<td>KEY_W1</td>
<td>0x058</td>
<td>32</td>
<td>AES key word 1. When key length is 128/192bit, this word is not used</td>
</tr>
<tr>
<td>KEY_W0</td>
<td>0x060</td>
<td>32</td>
<td>AES key word 0. When key length is 128/192bit, this word is not used</td>
</tr>
</tbody>
</table></div>
<div class="section" id="ip-generation">
<h2>IP Generation<a class="headerlink" href="#ip-generation" title="Permalink to this heading">¶</a></h2>
<p>This example design uses three kinds of design IP and two kinds of verification IP:</p>
<ul class="simple">
<li><p>Clock generator MMCM</p></li>
<li><p>AXI clock converter</p></li>
<li><p>AXI stream clock converter</p></li>
<li><p>AXI Master VIP</p></li>
<li><p>AXIS Master VIP</p></li>
<li><p>AXIS Slave VIP</p></li>
</ul>
<p>These IPs are all generated by a Tcl script <strong>~/krnl_aes/gen_ip.tcl</strong>. The script runs in non-project mode and mainly uses three Tcl command <em>create_ip</em>, <em>set_property</em> and <em>generate_target</em> to finish the IP generation. You could refer to the script and relevant IP documents for more details.</p>
</div>
<div class="section" id="pack-the-design-into-vivado-ip-and-vitis-kernel">
<h2>Pack the Design into Vivado IP and Vitis Kernel<a class="headerlink" href="#pack-the-design-into-vivado-ip-and-vitis-kernel" title="Permalink to this heading">¶</a></h2>
<p>One key step for the RTL kernel design for Vitis is to package the RTL design into Vitis kernel file (XO file). The user can utilize the GUI version <em>RTL Kernel Wizard</em> tool to help to create the Vitis kernel. The user can also use GUI version <em>IP Packager</em> in Vivado to package the design into Vivado IP then generate the XO file. Vivado also provides command line flow for Vitis kernel generation which provides the same jobs as GUI version. In this tutorial, we will use the Vivado Tcl command to finish the <em>krnl_aes</em> IP packaging and XO file generation in batch mode. The complete kernel generation script for this design is in <strong>~/krnl_aes/pack_kernel.tcl</strong>, the main steps are explained below and please see the details in the script. Actually each step in the script has its counterpart in GUI tool, refer to <a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/devrtlkernel.html">RTL Kernels</a> for GUI version IP packaging tool usage.</p>
<div class="section" id="step-1-create-vivado-project-and-add-design-sources">
<h3>Step 1: Create Vivado project and add design sources<a class="headerlink" href="#step-1-create-vivado-project-and-add-design-sources" title="Permalink to this heading">¶</a></h3>
<p>Firstly we need to create a Vivado project containing the source files. The script use the Tcl command <em>create_project</em>, <em>add_files</em> and <em>update_compiler_order</em> to finish this step. All RTL source codes, generated IP file (xci file) and XDC file should be added into the newly created project.</p>
<p>Finally the <em>ipx::package_project</em> Tcl command is used to initialize the IP packaging process.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>create_project krnl_aes ./krnl_aes
add_files -norecurse <span class="o">{</span>
        ../rtl/aes_wrapper.sv ... ...              <span class="se">\</span>
        ../ip_generation/clk_gen/clk_gen.xci      <span class="se">\</span>
        ../ip_generation/axi_clock_converter/axi_clock_converter.xci <span class="se">\</span>
        ../ip_generation/axis_clock_converter/axis_clock_converter.xci <span class="se">\</span>
        ../krnl_aes.xdc                     <span class="se">\</span>
       <span class="o">}</span>
update_compile_order -fileset sources_1
ipx::package_project -root_dir ./krnl_aes_ip -vendor xilinx.com -library user -taxonomy /UserIP -import_files -set_current <span class="nb">true</span>
</pre></div>
</div>
<p>In this step, you may see a warning information like: <em>WARNING: [IP_Flow 19-5101] Packaging a component with a SystemVerilog top file is not fully supported. Please refer to UG1118 ‘Creating and Packaging Custom IP’</em>. Currently the Vitis tool chain requires the port definition of the top module be traditional Verilog style. Though the top level module <em>krnl_aes.sv</em> uses some SystemVerilog syntax (SystemVerilog <em>interface</em> objects), but it uses the traditional Verilog style port definition, so you could omit this warning.</p>
</div>
<div class="section" id="step-2-infer-clock-reset-axi-interfaces-and-associate-them-with-clock">
<h3>Step 2: Infer clock, reset, AXI interfaces and associate them with clock<a class="headerlink" href="#step-2-infer-clock-reset-axi-interfaces-and-associate-them-with-clock" title="Permalink to this heading">¶</a></h3>
<p>Here we first use <em>ipx::infer_bus_interface</em> command to infer <em>ap_clk</em> and <em>ap_rst_n</em> as AXI bus signals. Generally if <em>ap_clk</em> is the only clock we used in the RTL kernel, this command can be omitted. If we use more clocks (ap_clk_2, ap_clk_3, …) in the design, we must use the <em>ipx::infer_bus_interface</em> command to infer the ports explicitly.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ipx</span><span class="p">::</span><span class="n">infer_bus_interface</span> <span class="n">ap_clk</span> <span class="n">xilinx</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="n">signal</span><span class="p">:</span><span class="n">clock_rtl</span><span class="p">:</span><span class="mf">1.0</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">infer_bus_interface</span> <span class="n">ap_rst_n</span> <span class="n">xilinx</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="n">signal</span><span class="p">:</span><span class="n">reset_rtl</span><span class="p">:</span><span class="mf">1.0</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
</pre></div>
</div>
<p>All AXI interfaces will be inferred automatically. In this design, these AXI ports include: a control AXI slave port <em>s_axi_control</em>, four AXIS slave ports <em>axis_slv0 ~ 3</em> and four AXIS master ports <em>axis_mst0 ~ 3</em>.</p>
<p>Then we use <em>ipx::associate_bus_interfaces</em> command to associate the automatically inferred AXI interfaces and reset signal to <em>ap_clk</em>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ipx</span><span class="p">::</span><span class="n">associate_bus_interfaces</span> <span class="o">-</span><span class="n">busif</span> <span class="n">s_axi_control</span>  <span class="o">-</span><span class="n">clock</span> <span class="n">ap_clk</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">associate_bus_interfaces</span> <span class="o">-</span><span class="n">busif</span> <span class="n">axis_mst0</span>      <span class="o">-</span><span class="n">clock</span> <span class="n">ap_clk</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
  <span class="o">...</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">associate_bus_interfaces</span> <span class="o">-</span><span class="n">busif</span> <span class="n">axis_slv0</span>      <span class="o">-</span><span class="n">clock</span> <span class="n">ap_clk</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
  <span class="o">...</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">associate_bus_interfaces</span> <span class="o">-</span><span class="n">clock</span> <span class="n">ap_clk</span> <span class="o">-</span><span class="n">reset</span> <span class="n">ap_rst_n</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="step-3-set-the-definition-of-axi-control-slave-registers-including-ctrl-and-user-kernel-arguments">
<h3>Step 3: Set the definition of AXI control slave registers, including CTRL and user kernel arguments<a class="headerlink" href="#step-3-set-the-definition-of-axi-control-slave-registers-including-ctrl-and-user-kernel-arguments" title="Permalink to this heading">¶</a></h3>
<p>Here we use <em>ipx::add_register</em> command to add the registers to inferred <em>s_axi_control</em> interface and use <em>set_property</em> command to set the property of the registers, for example the kernel argument <em>KEY_LEN</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ipx</span><span class="p">::</span><span class="n">add_register</span> <span class="n">KEY_LEN</span>   <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_address_blocks</span> <span class="n">reg0</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_memory_maps</span> <span class="n">s_axi_control</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]]]</span>
<span class="n">set_property</span> <span class="n">description</span>    <span class="p">{</span><span class="n">AES</span> <span class="n">key</span> <span class="n">length</span><span class="p">}</span>    <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_registers</span> <span class="n">KEY_LEN</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_address_blocks</span> <span class="n">reg0</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_memory_maps</span> <span class="n">s_axi_control</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]]]]</span>
<span class="n">set_property</span> <span class="n">address_offset</span> <span class="p">{</span><span class="mh">0x018</span><span class="p">}</span>             <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_registers</span> <span class="n">KEY_LEN</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_address_blocks</span> <span class="n">reg0</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_memory_maps</span> <span class="n">s_axi_control</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]]]]</span>
<span class="n">set_property</span> <span class="n">size</span>           <span class="p">{</span><span class="mi">32</span><span class="p">}</span>                <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_registers</span> <span class="n">KEY_LEN</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_address_blocks</span> <span class="n">reg0</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_memory_maps</span> <span class="n">s_axi_control</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]]]]</span>
</pre></div>
</div>
<p>Here <em>KEY_LEN</em> is the kernel argument name; “AES key length” is the register description; “0x018” is the address offset the the register and “32” is the data width of the register (all scalar kernel arguments should be 32-bit width).</p>
<p>You can see in the provided Tcl script that all the registers defined in the previous table are added and defined accordingly.</p>
<p>Since the <em>krnl_aes</em> kernel doesn’t have AXI master ports, so we don’t need to configure them. The description of setting AXI master can be found in <em>krnl_cbc</em> kernel part next.</p>
</div>
<div class="section" id="step-4-package-vivado-ip-and-generate-vitis-kernel-file">
<h3>Step 4: Package Vivado IP and generate Vitis kernel file<a class="headerlink" href="#step-4-package-vivado-ip-and-generate-vitis-kernel-file" title="Permalink to this heading">¶</a></h3>
<p>Here we use <em>set_property</em> command to set two required property <em>sdx_kernel</em> and <em>sdx_kernel_type</em>. Then we issue <em>ipx::update_source_project_archive</em> and <em>ipx::save_core</em> commands to package the Vivado project into Vivado IP. Finally we use <em>package_xo</em> command to generate the Vitis XO file.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">set_property</span> <span class="n">sdx_kernel</span> <span class="n">true</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">set_property</span> <span class="n">sdx_kernel_type</span> <span class="n">rtl</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">update_source_project_archive</span> <span class="o">-</span><span class="n">component</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">save_core</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">package_xo</span> <span class="o">-</span><span class="n">force</span> <span class="o">-</span><span class="n">xo_path</span> <span class="o">../</span><span class="n">krnl_aes</span><span class="o">.</span><span class="n">xo</span> <span class="o">-</span><span class="n">kernel_name</span> <span class="n">krnl_aes</span> <span class="o">-</span><span class="n">ctrl_protocol</span> <span class="n">ap_ctrl_hs</span> <span class="o">-</span><span class="n">ip_directory</span> <span class="o">./</span><span class="n">krnl_aes_ip</span> <span class="o">-</span><span class="n">output_kernel_xml</span> <span class="o">../</span><span class="n">krnl_aes</span><span class="o">.</span><span class="n">xml</span>
</pre></div>
</div>
<p>Please note in the above <em>package_xo</em> command usage, we let the tool to generate the kernel description XML file automatically, and don’t need to manually create it. If you have an existing Vitis compatible Vivado IP and need to generate XO file from it, you could also manually create the kernel XML file and designate it in the command as below usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">package_xo</span> <span class="o">-</span><span class="n">xo_path</span> <span class="o">../</span><span class="n">krnl_aes</span><span class="o">.</span><span class="n">xo</span> <span class="o">-</span><span class="n">kernel_name</span> <span class="n">krnl_aes</span> <span class="o">-</span><span class="n">ip_directory</span> <span class="o">./</span><span class="n">krnl_aes_ip</span> <span class="o">-</span><span class="n">kernel_xml</span> <span class="o">../</span><span class="n">krnl_aes</span><span class="o">.</span><span class="n">xml</span>
</pre></div>
</div>
<p>In this way, the kernel execution model is specified in the XML file with <em>hwControlProtocol</em> property instead of in <em>package_xo</em> command line option.</p>
</div>
</div>
<div class="section" id="testbench">
<h2>Testbench<a class="headerlink" href="#testbench" title="Permalink to this heading">¶</a></h2>
<p>We provides a simple SystemVerilog testbench for the <em>krnl_aes</em> module with Xilinx AXI VIPs. The testbench sources are in <strong>~/krnl_aes/tbench</strong> directory. Since <em>krnl_aes</em> has four completely identical AES engines, so we only test two of the four engines. Two AXI stream master VIPs are used to send input data to the kernel, two AXI stream slave VIPs are used to receive output data from the kernel, and an AXI master are used to configure the kernel arguments and control the kernel execution in <em>ap_ctrl_hs</em> fashion for AES key expansion operation. You could read the <strong>tb_krnl_aes.sv</strong> file for more details on the usages of AXI VIP to interaction with the kernel.</p>
<p>The input random data to the testbench is generated by a perl script <strong>~/common/plain_gen.pl</strong>, and the reference data for output check is generated by OpenSSL tools. The shell script <strong>~/krnl_aes/runsim_krnl_aes_xsim.sh</strong> is used to generate the input stimulus, output reference and run the simulation with Vivado XSIM.</p>
</div>
<div class="section" id="kernel-test-system-and-overlay-xclbin-generation">
<h2>Kernel Test System and Overlay (XCLBIN) Generation<a class="headerlink" href="#kernel-test-system-and-overlay-xclbin-generation" title="Permalink to this heading">¶</a></h2>
<p>To build a test system overlay for <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code>, we need AXI stream master and AXI stream slave to provide and receive data from <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code>. To do this, we write a simple memory-mapped AXI-to-AXIS kernel and a AXIS-to-AXI memory-mapped kernel with HLS C language. These are located in the <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/hls</span></code> directory, and they are called <code class="docutils literal notranslate"><span class="pre">strm_issue.cpp</span></code> and <code class="docutils literal notranslate"><span class="pre">strm_dump.cpp</span></code>, respectively.</p>
<p>The HLS C implementation of these two kernels is as below. Note that the for-loop with variable <code class="docutils literal notranslate"><span class="pre">j</span></code> is for endian conversion: the input/output data is transferred as little-endian via 128-bit data width AXI bus, and the 128-bit data is considered a integral word in big-endian.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#define PTR_WIDTH 128</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">strm_issue</span><span class="w"> </span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">data_output</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">data_input</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">byte_size</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">byte_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">PTR_WIDTH</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// clang-format off</span>
<span class="w">    </span><span class="cp">#pragma HLS PIPELINE II = 1</span>
<span class="w">    </span><span class="c1">// clang-format on</span>
<span class="w">        </span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data_in</span><span class="p">,</span><span class="w"> </span><span class="n">data_out</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">data_in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_input</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">PTR_WIDTH</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">data_out</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_in</span><span class="p">.</span><span class="n">range</span><span class="p">((</span><span class="n">PTR_WIDTH</span><span class="o">/</span><span class="mi">8-1</span><span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">PTR_WIDTH</span><span class="o">/</span><span class="mi">8-1</span><span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">temp</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_out</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">data_output</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">strm_dump</span><span class="w"> </span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">data_input</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">data_output</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">byte_size</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">byte_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">PTR_WIDTH</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// clang-format off</span>
<span class="w">    </span><span class="cp">#pragma HLS PIPELINE II = 1</span>
<span class="w">    </span><span class="c1">// clang-format on</span>
<span class="w">        </span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_input</span><span class="p">.</span><span class="n">read</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data_in</span><span class="p">,</span><span class="w"> </span><span class="n">data_out</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">data_in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">.</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">PTR_WIDTH</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">data_out</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_in</span><span class="p">.</span><span class="n">range</span><span class="p">((</span><span class="n">PTR_WIDTH</span><span class="o">/</span><span class="mi">8-1</span><span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">PTR_WIDTH</span><span class="o">/</span><span class="mi">8-1</span><span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w">            </span>
<span class="w">        </span><span class="n">data_output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_out</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w">          </span>
</pre></div>
</div>
<p>In total, four <code class="docutils literal notranslate"><span class="pre">strm_issue</span></code> and four <code class="docutils literal notranslate"><span class="pre">strm_dump</span></code> kernels are integrated with <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> in the test system, and the linking operation is scribed in the <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/Makefile</span></code>. The  <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/krnl_aes_test.cfg</span></code> file provides the necessary Vitis linking option for this design. This configuration file includes an additional XDC file, <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/krnl_aes_test.xdc</span></code>, to waive the critical warning encountered in the linking stage for the customized MMCM in the <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> kernel.</p>
</div>
<div class="section" id="host-programming">
<h2>Host Programming<a class="headerlink" href="#host-programming" title="Permalink to this heading">¶</a></h2>
<p>For host programming, you can use XRT Native C++ APIs to control the kernel execution in the FPGA. XRT Native APIs are very straightforward and intuitive. They provide higher efficiency compared to XRT OpenCL, especially in those cases needing very frequent host-kernel interactions. For more details on XRT Native APIs, refer to <a class="reference external" href="https://xilinx.github.io/XRT/master/html/xrt_native_apis.html">XRT Native APIs</a>.</p>
<p>The host program generates the random data as plain input, then uses the OpenSSL AES API to generate the reference cipher data. It supports the hardware emulation (<code class="docutils literal notranslate"><span class="pre">hw_emu</span></code>) flow as well, and will select the correct XCLBIN files for <code class="docutils literal notranslate"><span class="pre">hw</span></code> or <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code> mode.</p>
<p>The host program uses a <code class="docutils literal notranslate"><span class="pre">run.start()</span></code> function followed by a <code class="docutils literal notranslate"><span class="pre">run.wait()</span></code> function in a single thread way; this is the common usage for <em>ap_ctrl_hs</em> execution model.</p>
<p>One special note is that when the kernel <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> is transiting from encryption mode to decryption mode, you must use a kernel argument <code class="docutils literal notranslate"><span class="pre">MODE</span></code> to change the function of the kernel. There are two methods to update the register:</p>
<ol class="simple">
<li><p>Using low-level <code class="docutils literal notranslate"><span class="pre">kernel.write_register()</span></code> API</p></li>
<li><p>Using high-level <code class="docutils literal notranslate"><span class="pre">run.set_arg()</span></code> API followed by <code class="docutils literal notranslate"><span class="pre">run.start()</span></code></p></li>
</ol>
<p>For method 2, the <code class="docutils literal notranslate"><span class="pre">run.set_arg()</span></code> function will not be effective until the <code class="docutils literal notranslate"><span class="pre">run.start()</span></code> function is called, so you must issue <code class="docutils literal notranslate"><span class="pre">run.start()</span></code> to make the register writing operation happen. The key expansion operation doesn’t need to execute again, and the kernel for data encryption/decryption operation works in <code class="docutils literal notranslate"><span class="pre">ap_ctrl_none</span></code> mode.</p>
<p>Here is the code snippet for these two methods:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// Method 1 to configure krnl_aes to decryption mode</span>
<span class="c1">//   use run instance to set kernel argument. The kernel register will not be updated until run()</span>
<span class="w">  </span><span class="n">run_key_exp</span><span class="p">.</span><span class="n">set_arg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="w">                       </span><span class="c1">// index for argument MODE is 0</span>
<span class="w">  </span><span class="n">run_key_exp</span><span class="p">.</span><span class="n">start</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">run_key_exp</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span><span class="w"></span>

<span class="c1">// Method 2 to configrue krnl_aes to decryption mode</span>
<span class="c1">//   use kernel write_register() to access the register directly</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">reg_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_krnl_aes</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">     </span><span class="c1">// reg_offset = 0x10 for krnl_aes kernel register MODE</span>
<span class="w">  </span><span class="n">kernel_krnl_aes</span><span class="p">.</span><span class="n">write_register</span><span class="p">(</span><span class="n">reg_offset</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// set MODE = 0</span>
</pre></div>
</div>
</div>
<div class="section" id="tutorial-usage">
<h2>Tutorial Usage<a class="headerlink" href="#tutorial-usage" title="Permalink to this heading">¶</a></h2>
<div class="section" id="before-you-begin">
<h3>Before You Begin<a class="headerlink" href="#before-you-begin" title="Permalink to this heading">¶</a></h3>
<p>This tutorial uses files in the <code class="docutils literal notranslate"><span class="pre">~/krnl_aes</span></code> directory.</p>
<p>All steps except for host program execution in this tutorial are finished by the GNU Make. This example design supports four Alveo cards (U200, U250, U50, U280), and you must make the necessary adjustments to the <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/Makefile</span></code> for each card by uncommenting the line matching your Alveo card.</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span> <span class="m">41</span> <span class="c1"># PART setting: uncomment the line matching your Alveo card</span>
 <span class="m">42</span> PART :<span class="o">=</span> xcu200-fsgd2104-2-e
 <span class="m">43</span> <span class="c1">#PART := cu250-figd2104-2L-e</span>
 <span class="m">44</span> <span class="c1">#PART := xcu50-fsvh2104-2-e</span>
 <span class="m">45</span> <span class="c1">#PART := xcu280-fsvh2892-2L-e</span>
 <span class="m">46</span>
 <span class="m">47</span> <span class="c1"># PLATFORM setting: uncomment the lin matching your Alveo card</span>
 <span class="m">48</span> PLATFORM :<span class="o">=</span> xilinx_u200_xdma_201830_2
 <span class="m">49</span> <span class="c1">#PLATFORM := xilinx_u250_xdma_201830_2</span>
 <span class="m">50</span> <span class="c1">#PLATFORM := xilinx_u50_gen3x16_xdma_201920_3</span>
 <span class="m">51</span> <span class="c1">#PLATFORM := xilinx_u280_xdma_201920_3</span>
</pre></div>
</div>
<p>As an alternative, instead of making the modification, you can use the command line option to override the default setting. An example is shown in the following steps related to using the make tool for the U50 card:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>make xxx <span class="nv">PART</span><span class="o">=</span>xcu50-fsvh2104-2-e <span class="nv">PLATFORM</span><span class="o">=</span>xilinx_u50_gen3x16_xdma_201920_3
</pre></div>
</div>
<p>Before starting, ensure that you source the setup scripts in XRT and Vitis installation path. For example:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">source</span> /opt/xilinx/xrt/setup.sh
<span class="nb">source</span> /tools/Xilinx/Vitis/2020.2/settings64.sh
</pre></div>
</div>
</div>
<div class="section" id="tutorial-steps">
<h3>Tutorial Steps<a class="headerlink" href="#tutorial-steps" title="Permalink to this heading">¶</a></h3>
<div class="section" id="generate-ips">
<h4>1. Generate IPs<a class="headerlink" href="#generate-ips" title="Permalink to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">gen_ip</span>
</pre></div>
</div>
<p>This starts Vivado in batch mode and calls <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/gen_ip.tcl</span></code> to generate all needed design and verification IPs.</p>
</div>
<div class="section" id="run-standalone-simulation">
<h4>2. Run Standalone Simulation<a class="headerlink" href="#run-standalone-simulation" title="Permalink to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">runsim</span>
</pre></div>
</div>
<p>This calls <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/runsim_krnl_aes_xsim.sh</span></code> to run the simulation with Vivado XSIM.</p>
</div>
<div class="section" id="package-vivado-ip-and-generate-vitis-kernel-file">
<h4>3. Package Vivado IP and Generate Vitis Kernel File<a class="headerlink" href="#package-vivado-ip-and-generate-vitis-kernel-file" title="Permalink to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">pack_kernel</span>
</pre></div>
</div>
<p>This starts Vivado in batch mode and calls <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/pack_kernel.tcl</span></code> to package the RTL sources, generated IP XCI files, and XDC files into Vivado IP. It then generates the Vitis kernel file <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/krnl_aes.xo</span></code>.</p>
</div>
<div class="section" id="build-kernel-testing-system-overlay-files">
<h4>4. Build Kernel Testing System Overlay Files<a class="headerlink" href="#build-kernel-testing-system-overlay-files" title="Permalink to this heading">¶</a></h4>
<p><strong>Note:</strong> If you are using <code class="docutils literal notranslate"><span class="pre">xilinx_u200_xdma_201830_2</span></code>, <code class="docutils literal notranslate"><span class="pre">xilinx_u250_xdma_201830_2</span></code>, or <code class="docutils literal notranslate"><span class="pre">xilinx_u280_xdma_201920_3</span></code> platforms, you must uncomment line 2, line 5, or line 8 in <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/krnl_aes_test.xdc</span></code>, respectively.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>  <span class="m">1</span> <span class="c1"># if you are using xilinx_u200_xdma_201830_2 platform, please uncomment following line</span>
  <span class="m">2</span> <span class="c1"># set_property CLOCK_DEDICATED_ROUTE ANY_CMT_COLUMN [get_nets pfm_top_i/static_region/slr1/base_clocking/clkwiz_kernel/inst/CLK_CORE_DRP_I/clk_inst/clk_out1]</span>
  <span class="m">3</span>
  <span class="m">4</span> <span class="c1"># if you are using xilinx_u250_xdma_201830_2 platform, please uncomment following line</span>
  <span class="m">5</span> <span class="c1"># set_property CLOCK_DEDICATED_ROUTE ANY_CMT_COLUMN [get_nets pfm_top_i/static_region/slr0/base_clocking/clkwiz_kernel2/inst/CLK_CORE_DRP_I/clk_inst/clk_out1]</span>
  <span class="m">6</span>
  <span class="m">7</span> <span class="c1"># if you are using xilinx_u280_xdma_201920_3 platform, please uncomment following line</span>
  <span class="m">8</span> <span class="c1">#set_property CLOCK_DEDICATED_ROUTE ANY_CMT_COLUMN [get_nets pfm_top_i/static_region/base_clocking/clkwiz_kernel/inst/CLK_CORE_DRP_I/clk_inst/clk_out1]</span>
</pre></div>
</div>
<div class="section" id="for-a-hardware-target">
<h5>For a hardware target<a class="headerlink" href="#for-a-hardware-target" title="Permalink to this heading">¶</a></h5>
<p>For a hardware target, use the following command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">build_hw</span>
</pre></div>
</div>
<p>This first compiles the two HLS kernels into XO files, then builds the total system overlay files <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/krnl_aes_test_hw.xclbin</span></code>.</p>
</div>
<div class="section" id="for-a-hardware-emulation-target">
<h5>For a hardware emulation target<a class="headerlink" href="#for-a-hardware-emulation-target" title="Permalink to this heading">¶</a></h5>
<p>For a hardware emulation target, use the following command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">build_hw</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw_emu</span>
</pre></div>
</div>
<p>This first compiles the two HLS kernels into XO files, then builds the total system overlay files <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/krnl_aes_test_hw_emu.xclbin</span></code>.</p>
</div>
</div>
<div class="section" id="compile-host-program">
<h4>5. Compile Host Program<a class="headerlink" href="#compile-host-program" title="Permalink to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">build_sw</span>
</pre></div>
</div>
<p>This finishes the compilation of the host C++ program. An executable,  <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/host_krnl_aes_test</span></code>, is generated for both <code class="docutils literal notranslate"><span class="pre">hw</span></code> and <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code> modules.</p>
<div class="section" id="finding-the-device-id-of-your-target-card">
<h5>Finding the Device ID of Your Target Card<a class="headerlink" href="#finding-the-device-id-of-your-target-card" title="Permalink to this heading">¶</a></h5>
<p>If you have multiple Alveo cards installed on the host machine, use the <code class="docutils literal notranslate"><span class="pre">xbutil</span> <span class="pre">list</span></code> command to find the device ID of your target card. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xbutil</span> <span class="nb">list</span>
<span class="o">...</span>
 <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="mi">0000</span><span class="p">:</span><span class="n">d8</span><span class="p">:</span><span class="mf">00.1</span> <span class="n">xilinx_u250_gen3x16_base_3</span> <span class="n">user</span><span class="p">(</span><span class="n">inst</span><span class="o">=</span><span class="mi">131</span><span class="p">)</span>
 <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="mi">0000</span><span class="p">:</span><span class="n">af</span><span class="p">:</span><span class="mf">00.1</span> <span class="n">xilinx_vck5000</span><span class="o">-</span><span class="n">es1_gen3x16_base_2</span> <span class="n">user</span><span class="p">(</span><span class="n">inst</span><span class="o">=</span><span class="mi">130</span><span class="p">)</span>
 <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="mi">0000</span><span class="p">:</span><span class="mi">5</span><span class="n">e</span><span class="p">:</span><span class="mf">00.1</span> <span class="n">xilinx_u50_gen3x16_xdma_201920_3</span> <span class="n">user</span><span class="p">(</span><span class="n">inst</span><span class="o">=</span><span class="mi">129</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example, if your target card is U50, you can find the device ID is 2. You should modify the line 30 of <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/host/host_krnl_aes_test.cpp</span></code> as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span> 28 // Use &#39;xbutil list&#39; command to get the device id of the target Alveo card if multiple
 29 //   cards are installed in the system.
 30 #define DEVICE_ID   2
</pre></div>
</div>
</div>
</div>
<div class="section" id="run-hardware-emulation-optional">
<h4>6. Run Hardware Emulation (Optional)<a class="headerlink" href="#run-hardware-emulation-optional" title="Permalink to this heading">¶</a></h4>
<p>When the XCLBIN file for hardware emulation (<code class="docutils literal notranslate"><span class="pre">~/krnl_aes/krnl_aes_test_hw_emu.xclbin</span></code>) is generated, you can run hardware emulation to verify the kernel in the platform environment for debug or details profiling purposes. Refer to the following commands.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">source</span> setup_emu.sh -s on -p PLATFORM_NAME
./host_krnl_aes_test -w <span class="m">32</span>
</pre></div>
</div>
<p>The first command calls the script to generate the emulation configuration file and set the necessary environment variables. The PLATFORM_NAME is the Alveo platform you are using, which can be xilinx_u200_xdma_201830_2 (default), xilinx_u250_xdma_201830_2, xilinx_u280_xdma_201920_3 or xilinx_u50_gen3x16_xdma_201920_3.</p>
<p>The second command runs the host program in <em>hw_emu</em> mode. The optional command line parameter <em>-w 32</em> sets the number of 128-bit words to process. The default word number in the program source code is 1048576 (1 million), which is too big for hardware emulation, so you can set it to a smaller value to shorten the emulation run time.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/xrt.ini</span></code> file is used to control the XRT emulation options, as shown below. In line 2, <code class="docutils literal notranslate"><span class="pre">exclusive_cu_context=true</span></code> is necessary if the low-level <code class="docutils literal notranslate"><span class="pre">kernel.write_register()</span></code> function is used. In line 6, <code class="docutils literal notranslate"><span class="pre">user_pre_sim_script=/home/workspace/bottom_up_rtl_kernel/krnl_aes/xsim.tcl</span></code> sets the absolute path to the pre-simulation Tcl script used by XSIM to indicate the tool to dump the waveform for all the signals.</p>
<p><strong>Note</strong>: Make sure to modify the path to match your real path.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="mi">1</span> <span class="p">[</span><span class="n">Runtime</span><span class="p">]</span>
  <span class="mi">2</span> <span class="n">exclusive_cu_context</span><span class="o">=</span><span class="n">true</span>
  <span class="mi">3</span>
  <span class="mi">4</span> <span class="p">[</span><span class="n">Emulation</span><span class="p">]</span>
  <span class="mi">5</span> <span class="n">debug_mode</span><span class="o">=</span><span class="n">batch</span>
  <span class="mi">6</span> <span class="n">user_pre_sim_script</span><span class="o">=/</span><span class="n">home</span><span class="o">/</span><span class="n">workspace</span><span class="o">/</span><span class="n">bottom_up_rtl_kernel</span><span class="o">/</span><span class="n">krnl_aes</span><span class="o">/</span><span class="n">xsim</span><span class="o">.</span><span class="n">tcl</span>
  <span class="mi">7</span>
  <span class="mi">8</span> <span class="p">[</span><span class="n">Debug</span><span class="p">]</span>
  <span class="mi">9</span> <span class="n">profile</span><span class="o">=</span><span class="n">true</span>
 <span class="mi">10</span> <span class="n">timeline_trace</span><span class="o">=</span><span class="n">true</span>
 <span class="mi">11</span> <span class="n">data_transfer_trace</span><span class="o">=</span><span class="n">fine</span>
</pre></div>
</div>
<p>After the hardware emulation run finishes, you can open the generated <code class="docutils literal notranslate"><span class="pre">xilinx_xxx-0-krnl_aes_test_hw_emu.wdb</span></code> file in Vivado to analyze the waveform. The following figure shows the waveform for the behavior of eight AXI stream ports of <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code>.</p>
<div align="center">
<img src="./images/krnl_aes_waveform.png" alt="krnl_aes waveform" >
</div>
<br/><p>The next figure shows the control signals behavior in AXI control slave for <code class="docutils literal notranslate"><span class="pre">ap_ctrl_hs</span></code> mode.</p>
<div align="center">
<img src="./images/ap_ctrl_hs_waveform.png" alt="ap_ctrl_hs waveform" >
</div>
<br/></div>
<div class="section" id="run-host-program-in-hardware-mode">
<h4>7. Run Host Program in Hardware Mode<a class="headerlink" href="#run-host-program-in-hardware-mode" title="Permalink to this heading">¶</a></h4>
<p>If you have tried hardware emulation in the previous step, you must run the following command to disable the <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code> mode:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">source</span> setup_emu.sh -s off
</pre></div>
</div>
<p>Now, you can run the compiled <code class="docutils literal notranslate"><span class="pre">host_krnl_aes_test</span></code> file to test the system in hardware mode. The default words number to process is 1M 128-bit words, which is 16 MBytes. Because of the data transfer efficiency between host and FPGA via PCIe, you can peak processing throughput with big-enough input data.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">host_krnl_aes_test</span>

<span class="o">------------------------</span> <span class="n">krnl_aes</span> <span class="n">test</span> <span class="n">program</span> <span class="o">------------------------</span>
 <span class="mi">128</span><span class="o">-</span><span class="n">bit</span> <span class="n">words</span> <span class="n">number</span> <span class="p">:</span> <span class="mi">1048576</span>
           <span class="n">Key</span> <span class="n">length</span> <span class="p">:</span> <span class="mi">256</span><span class="o">-</span><span class="n">bit</span>
                  <span class="n">Key</span> <span class="p">:</span> <span class="mi">123456789</span><span class="n">ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0</span>

<span class="n">Generating</span> <span class="n">plain</span> <span class="n">data</span>
<span class="p">[</span><span class="n">MESSAGE</span><span class="p">]</span> <span class="n">Program</span> <span class="n">running</span> <span class="ow">in</span> <span class="n">hardware</span> <span class="n">mode</span>
<span class="n">Load</span> <span class="n">krnl_aes_test_hw</span><span class="o">.</span><span class="n">xclbin</span>
<span class="n">Create</span> <span class="n">kernels</span>
<span class="n">Create</span> <span class="nb">input</span> <span class="ow">and</span> <span class="n">output</span> <span class="n">device</span> <span class="n">buffers</span>
<span class="n">Run</span> <span class="n">krnl_aes</span> <span class="k">for</span> <span class="n">AES</span> <span class="n">key</span> <span class="n">expansion</span>
<span class="n">Kernel</span> <span class="n">run</span> <span class="n">finish</span>

<span class="o">--------------</span> <span class="n">AES</span> <span class="n">Encryption</span> <span class="n">Test</span>
<span class="n">Transfer</span> <span class="n">plain</span> <span class="n">data</span> <span class="n">into</span> <span class="n">device</span> <span class="n">buffer</span>
<span class="n">Start</span> <span class="n">strm_issue</span> <span class="ow">and</span> <span class="n">strm_dump</span> <span class="n">kernels</span>
<span class="n">Kernel</span> <span class="n">run</span> <span class="n">finish</span>
<span class="n">AES</span> <span class="n">engines</span> <span class="n">execution</span> <span class="n">time</span> <span class="o">=</span> <span class="mf">170.820007</span> <span class="n">ms</span>
<span class="n">Transfer</span> <span class="n">cipher</span> <span class="n">data</span> <span class="kn">from</span> <span class="nn">device</span> <span class="n">buffer</span> <span class="ow">and</span> <span class="n">verification</span>
<span class="o">--</span> <span class="n">AES</span> <span class="n">Engine</span> <span class="mi">0</span>
   <span class="n">SUCCESS</span>
<span class="o">--</span> <span class="n">AES</span> <span class="n">Engine</span> <span class="mi">1</span>
   <span class="n">SUCCESS</span>
<span class="o">--</span> <span class="n">AES</span> <span class="n">Engine</span> <span class="mi">2</span>
   <span class="n">SUCCESS</span>
<span class="o">--</span> <span class="n">AES</span> <span class="n">Engine</span> <span class="mi">3</span>
   <span class="n">SUCCESS</span>
<span class="n">AES</span> <span class="n">total</span> <span class="n">encryption</span> <span class="n">throughput</span> <span class="o">=</span> <span class="mf">392.857971</span> <span class="n">MB</span><span class="o">/</span><span class="n">s</span>

<span class="o">--------------</span> <span class="n">AES</span> <span class="n">Decryption</span> <span class="n">Test</span>
<span class="n">Transfer</span> <span class="n">cipher</span> <span class="n">data</span> <span class="n">into</span> <span class="n">device</span> <span class="n">buffer</span>
<span class="n">Start</span> <span class="n">strm_issue</span> <span class="ow">and</span> <span class="n">strm_dump</span> <span class="n">kernels</span>
<span class="n">Kernel</span> <span class="n">run</span> <span class="n">finish</span>
<span class="n">AES</span> <span class="n">engines</span> <span class="n">execution</span> <span class="n">time</span> <span class="o">=</span> <span class="mf">170.800995</span> <span class="n">ms</span>
<span class="n">Transfer</span> <span class="n">plain</span> <span class="n">data</span> <span class="kn">from</span> <span class="nn">device</span> <span class="n">buffer</span> <span class="ow">and</span> <span class="n">verification</span>
<span class="o">--</span> <span class="n">AES</span> <span class="n">Engine</span> <span class="mi">0</span>
   <span class="n">SUCCESS</span>
<span class="o">--</span> <span class="n">AES</span> <span class="n">Engine</span> <span class="mi">1</span>
   <span class="n">SUCCESS</span>
<span class="o">--</span> <span class="n">AES</span> <span class="n">Engine</span> <span class="mi">2</span>
   <span class="n">SUCCESS</span>
<span class="o">--</span> <span class="n">AES</span> <span class="n">Engine</span> <span class="mi">3</span>
   <span class="n">SUCCESS</span>
<span class="n">AES</span> <span class="n">total</span> <span class="n">decryption</span> <span class="n">throughput</span> <span class="o">=</span> <span class="mf">392.901703</span> <span class="n">MB</span><span class="o">/</span><span class="n">s</span>
</pre></div>
</div>
<hr class="docutils" />
<p>Now you have a Vitis RTL kernel file, <code class="docutils literal notranslate"><span class="pre">krnl_aes.xo</span></code>, with <code class="docutils literal notranslate"><span class="pre">ap_ctrl_hs</span></code> execution model. In the next session, you will learn about another RTL kernel, <code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code>, which supports <code class="docutils literal notranslate"><span class="pre">ap_ctrl_chain</span></code> model, and integrates these two kernel into a hardware overlay (XCLBIN) to form a complete AES-CBC acceleration application. This is described in the next section: <a class="reference internal" href="krnl_cbc.html"><span class="doc">RTL Kernel: krnl_cbc</span></a>.</p>
</div>
</div>
</div>
</div>


           </div>
          </div>
          
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
				  
				  <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, Xilinx, Inc. Xilinx is now a part of AMD.
      <span class="lastupdated">Last updated on July 27, 2022.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>