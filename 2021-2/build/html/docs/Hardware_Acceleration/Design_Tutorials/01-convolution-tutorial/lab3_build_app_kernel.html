<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
  <title>Building the 2-D Convolution Kernel and Host Application &mdash; Vitis™ Tutorials 2021.2 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../../../../index.html" class="icon icon-home"> Vitis™ Tutorials
            <img src="../../../../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2021.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">日本語版</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/master/docs-jp/index.html">Master</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Getting_Started/Vitis-Getting-Started.html">Getting Started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Acceleration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Hardware-Acceleration.html">Hardware Acceleration</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">AI Engine</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../AI_Engine_Development/AI_Engine_Development.html">AI Engine Development</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Platforms</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Vitis_Platform_Creation/Vitis_Platform_Creation.html">Vitis Platform Creation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/index.html">Main</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2021-1/build/html/index.html">2021.1</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-2/docs/build/html/index.html">2020.2</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-1/docs/build/html/README.html">2020.1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Vitis™ Tutorials</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Building the 2-D Convolution Kernel and Host Application</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/docs/Hardware_Acceleration/Design_Tutorials/01-convolution-tutorial/lab3_build_app_kernel.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <table class="sphinxhide" width="100%">
 <tr width="100%">
    <td align="center"><img src="https://raw.githubusercontent.com/Xilinx/Image-Collateral/main/xilinx-logo.png" width="30%"/><h1>Vitis Hardware Acceleration</h1>
    <a href="https://www.xilinx.com/products/design-tools/vitis.html">See Vitis™ Development Environment on xilinx.com</br></a>
    </td>
 </tr>
</table><div class="section" id="building-the-2-d-convolution-kernel-and-host-application">
<h1>Building the 2-D Convolution Kernel and Host Application<a class="headerlink" href="#building-the-2-d-convolution-kernel-and-host-application" title="Permalink to this heading">¶</a></h1>
<p>This lab will focus on building a hardware kernel using the Vitis application acceleration development flow, targeting the Xilinx Alveo U200 accelerator card. A host-side application will be implemented to coordinate all the data movements and execution triggers for invoking the kernel. During this lab, real performance measurements will be taken and compared to estimated performance and the CPU-only performance.</p>
<div class="section" id="host-application">
<h2>Host Application<a class="headerlink" href="#host-application" title="Permalink to this heading">¶</a></h2>
<p>This section briefly discusses how the host application is written to orchestrate the execution of a convolution kernel. It was estimated in the previous lab that multiple compute units will be needed to meet the 60 FPS performance target for processing 1080p HD Video. The host application is designed to be agnostic to the number of compute units. More specifically, if the compute units are symmetric ( instance of the same kernel and memory connectivity to device DDR banks is identical), the host application can deal with any number of compute units.</p>
<p><strong>TIP:</strong> Additional <a class="reference external" href="https://github.com/Xilinx/Vitis-Tutorials">tutorials</a> and <a class="reference external" href="https://github.com/Xilinx/Vitis_Accel_Examples">examples</a> about host programming and Vitis tools are available.</p>
<div class="section" id="host-application-variants">
<h3>Host Application Variants<a class="headerlink" href="#host-application-variants" title="Permalink to this heading">¶</a></h3>
<p>Please go to the top-level folder for the convolution tutorial and change the directory to <code class="docutils literal notranslate"><span class="pre">src</span></code>, and list the files:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span>  <span class="nv">$CONV_TUTORIAL_DIR</span>/src
ls
</pre></div>
</div>
<p>There are two files namely “<strong>host.cpp</strong>” and “<strong>host_randomized.cpp</strong>”. They can be used to build two different versions of the host application. The way they interact with the kernel compute unit is exactly the same except that one uses the <strong>pgm</strong> image file as input. This file is repeated multiple times to emulate an image sequence(video). The randomized host uses a randomly generated image sequence. The host with random input image generation has no dependencies. In contrast, the host code in “<strong>host.cpp</strong>” uses OpenCV libraries, specifically using <strong>OpenCV 2.4</strong> libraries to load, unload and convert between raw image formats.</p>
</div>
<div class="section" id="host-application-details">
<h3>Host Application Details<a class="headerlink" href="#host-application-details" title="Permalink to this heading">¶</a></h3>
<p>The host application starts by parsing command line arguments. Following are the command-line options provided by the host that takes the input image and uses OpenCV (in source file <code class="docutils literal notranslate"><span class="pre">src/host.cpp</span></code>):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">CmdLineParser</span><span class="w"> </span><span class="n">parser</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">parser</span><span class="p">.</span><span class="n">addSwitch</span><span class="p">(</span><span class="s">&quot;--nruns&quot;</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;-n&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Number of times the image is processed&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;1&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">parser</span><span class="p">.</span><span class="n">addSwitch</span><span class="p">(</span><span class="s">&quot;--fpga&quot;</span><span class="p">,</span><span class="w">    </span><span class="s">&quot;-x&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;FPGA binary (xclbin) file to use&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">parser</span><span class="p">.</span><span class="n">addSwitch</span><span class="p">(</span><span class="s">&quot;--input&quot;</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;-i&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Input image file&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">parser</span><span class="p">.</span><span class="n">addSwitch</span><span class="p">(</span><span class="s">&quot;--filter&quot;</span><span class="p">,</span><span class="w">  </span><span class="s">&quot;-f&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Filter type (0-6)&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;0&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">parser</span><span class="p">.</span><span class="n">addSwitch</span><span class="p">(</span><span class="s">&quot;--maxreqs&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;-r&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Maximum number of outstanding requests&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;3&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">parser</span><span class="p">.</span><span class="n">addSwitch</span><span class="p">(</span><span class="s">&quot;--compare&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;-c&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Compare FPGA and SW performance&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;false&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">host_randomized.cpp</span></code> file has all those options, and adds <code class="docutils literal notranslate"><span class="pre">width</span></code> and <code class="docutils literal notranslate"><span class="pre">height</span></code> options:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">parser</span><span class="p">.</span><span class="n">addSwitch</span><span class="p">(</span><span class="s">&quot;--width&quot;</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;-w&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Image width&quot;</span><span class="p">,</span><span class="w">  </span><span class="s">&quot;1920&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">parser</span><span class="p">.</span><span class="n">addSwitch</span><span class="p">(</span><span class="s">&quot;--height&quot;</span><span class="p">,</span><span class="w">  </span><span class="s">&quot;-h&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Image height&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;1080&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Different options can be used to launch the application and for performance measurements. In this lab, you will set most of these command-line inputs to the application using a makefile, <code class="docutils literal notranslate"><span class="pre">make_options.mk</span></code> in the top-level directory. This file lets you set most of these options.</p>
<p>After parsing the command-line options, the host application creates an OpenCL context, reads and loads the <code class="docutils literal notranslate"><span class="pre">.xclbin</span></code>, and creates a command queue with out-of-order execution and profiling enabled. After that, memory allocation is done, and the input image is read (or randomly generated).</p>
<p>After the setup is complete, the application creates a <code class="docutils literal notranslate"><span class="pre">Filter2DDispatcher</span></code> object and uses it to dispatch filtering requests on several images. Timers are used to capture execution time measurements for both software and hardware execution. Finally, the host application prints the summary of performance results. Most of the heavy lifting is done by <code class="docutils literal notranslate"><span class="pre">Filter2DDispatcher</span></code> and <code class="docutils literal notranslate"><span class="pre">Filter2DRequest</span></code>. These classes manage and coordinate the execution of filtering operations on multiple compute units. Both versions of the host application are based on these classes.</p>
</div>
<div class="section" id="d-filtering-requests">
<h3>2D Filtering Requests<a class="headerlink" href="#d-filtering-requests" title="Permalink to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Filter2DRequest</span></code> class is used by the filtering request dispatcher class. An object of this class encapsulates a single request to process a single color channel (YUV) for a given image. It essentially allocates and holds handles to OpenCL resources needed for enqueueing 2-D convolution filtering requests. These resources include OpenCL buffers, event lists, and handles to kernel and command queue. The application creates a single command queue that is passed down to enqueue every kernel enqueue command.</p>
<p>After an object of the <code class="docutils literal notranslate"><span class="pre">Filter2DRequest</span></code> class is created, it can be used to make a call to the <code class="docutils literal notranslate"><span class="pre">Filter2D</span></code> method. This call will enqueue all the operations, moving input data or filter coefficients, kernel calls, and reading of output data back to the host. The same API call will create a list of dependencies between these transfers and also creates an output event that signals the completion of output data transfer to the host.</p>
</div>
<div class="section" id="d-filter-dispatcher">
<h3>2D Filter Dispatcher<a class="headerlink" href="#d-filter-dispatcher" title="Permalink to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Filter2DDispatcher</span></code> class is the top-level class that provides an end-user API to schedule kernel calls. Every call schedules a kernel enqueue and related data transfers using the <code class="docutils literal notranslate"><span class="pre">Filter2DRequest</span></code> object, as explained previously.  The <code class="docutils literal notranslate"><span class="pre">Filter2DDispatcher</span></code> is a container class that essentially holds a vector of request objects. The number of <code class="docutils literal notranslate"><span class="pre">Filter2DRequest</span></code> objects that are instantiated is defined as the <strong>max</strong> parameter for the dispatcher class at construction time. This parameter’s minimum value can be as small as the number of compute units to allow at least one kernel enqueue call per compute unit to happen in parallel. But a larger value is desired since it will allow overlap between input and output data transfers happening between host and device.</p>
</div>
</div>
<div class="section" id="building-the-application">
<h2>Building the Application<a class="headerlink" href="#building-the-application" title="Permalink to this heading">¶</a></h2>
<p>The host application can be built using the <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> that is provided with the tutorial. As mentioned earlier, the host application has two versions: the first version takes input images to process, the second can generate random data that will be processed as images.</p>
<p>The top-level <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> includes a file called <code class="docutils literal notranslate"><span class="pre">make_options.mk</span></code>. This file provides most of the options that can be used to generate different host builds and kernel versions for emulation modes. It also provides a way to launch emulation with a specific number of test images. The details of the options provided by this file are as follows:</p>
<div class="section" id="kernel-build-options">
<h3>Kernel Build Options<a class="headerlink" href="#kernel-build-options" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>TARGET: selects build target; the choices are <code class="docutils literal notranslate"><span class="pre">hw</span></code>, <code class="docutils literal notranslate"><span class="pre">sw_emu</span></code>, <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code>.</p></li>
<li><p>PLATFORM: target Xilinx platform used for the build</p></li>
<li><p>ENABLE_STALL_TRACE : enables the kernel to generate stall data. Choices are: <code class="docutils literal notranslate"><span class="pre">yes</span></code>, <code class="docutils literal notranslate"><span class="pre">no</span></code>.</p></li>
<li><p>TRACE_DDR: select the memory bank to store trace data. Choices are DDR[0]-DDR[3] for u200 card.</p></li>
<li><p>KERNEL_CONFIG_FILE: kernel configuration file</p></li>
<li><p>VPP_TEMP_DIRS: temporary log directory for the Vitis kernel compiler (<code class="docutils literal notranslate"><span class="pre">v++</span></code>)</p></li>
<li><p>VPP_LOG_DIRS: log directory for <code class="docutils literal notranslate"><span class="pre">v++</span></code>.</p></li>
<li><p>USE_PRE_BUILT_XCLBIN: enables the use of pre-built FPGA binary file to speed the use of this tutorial</p></li>
</ul>
</div>
<div class="section" id="host-build-options">
<h3>Host Build Options<a class="headerlink" href="#host-build-options" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>ENABLE_PROF: Enables OpenCL profiling for the host application</p></li>
<li><p>OPENCV_INCLUDE: OpenCV include directory path</p></li>
<li><p>OPENCV_LIB: OpenCV lib directory path</p></li>
</ul>
</div>
<div class="section" id="application-runtime-options">
<h3>Application Runtime Options<a class="headerlink" href="#application-runtime-options" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>FILTER_TYPE: selects between 6 different filter types: choices are 0-6(Identity, Blur, Motion Blur, Edges, Sharpen, Gaussian, Emboss)</p></li>
<li><p>PARALLEL_ENQ_REQS: application command-line argument for parallel enqueued requests</p></li>
<li><p>NUM_IMAGES: number of images to process</p></li>
<li><p>IMAGE_WIDTH: image width to use</p></li>
<li><p>IMAGE_HEIGHT: image height to use</p></li>
<li><p>INPUT_TYPE: selects between host versions</p></li>
<li><p>INPUT_IMAGE: path and name of image file</p></li>
<li><p>PROFILE_ALL_IMAGES: while comparing CPU vs. FPGA, use all images or not</p></li>
<li><p>NUM_IMAGES_SW_EMU: sets no. of images to use for sw_emu</p></li>
<li><p>NUM_IMAGES_HW_EMU: sets no. of images to use for hw_emu</p></li>
</ul>
<p>To build the host application with randomized data please follow these steps:</p>
<ol class="simple">
<li><p>Edit the Makefile options:</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span>  <span class="nv">$CONV_TUTORIAL_DIR</span>/
vim make_options.mk
</pre></div>
</div>
<ol class="simple">
<li><p>Make sure <strong>INPUT_TYPE</strong> option is set to <code class="docutils literal notranslate"><span class="pre">random</span></code>. This will build the <code class="docutils literal notranslate"><span class="pre">host_randomized.cpp</span></code> application:</p></li>
</ol>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="c">############## Host Application Options</span>
<span class="nv">INPUT_TYPE</span> <span class="o">:=</span>random
</pre></div>
</div>
<p><strong>TIP:</strong> To build the <code class="docutils literal notranslate"><span class="pre">host.cpp</span></code> you must include the following two variables that point to <strong>OpenCV 2.4</strong> install path in <code class="docutils literal notranslate"><span class="pre">make_options.mk</span></code> file:</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="c">############## OpenCV Installation Paths</span>
<span class="nv">OPENCV_INCLUDE</span> <span class="o">:=</span>/**OpenCV2.4 User Install Path**/include
<span class="nv">OPENCV_LIB</span> <span class="o">:=</span>/**OpenCV2.4 User Install Path**/lib
</pre></div>
</div>
<ol class="simple">
<li><p>Source the install specific scripts for setting up the Vitis application acceleration development flow and the Xilinx RunTime Library:</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">source</span> /**User XRT Install Path**/setup.sh
<span class="nb">source</span> /**User Vitis Install Path**/settings64.sh
</pre></div>
</div>
<ol class="simple">
<li><p>After setting the appropriate paths, build the host application using the makefile command as follows:</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make host
</pre></div>
</div>
<p>It will build <code class="docutils literal notranslate"><span class="pre">host.exe</span></code> inside a <code class="docutils literal notranslate"><span class="pre">build</span></code> folder. By building the host application separate from the kernel code, you can make sure the host code compiles correctly and all library paths have been set.</p>
</div>
<div class="section" id="running-software-emulation">
<h3>Running Software Emulation<a class="headerlink" href="#running-software-emulation" title="Permalink to this heading">¶</a></h3>
<p>To build and run the kernel in software emulation mode, please run the following bash command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make run <span class="nv">TARGET</span><span class="o">=</span>sw_emu
</pre></div>
</div>
<p>It will build an xclbin file to be used in software emulation mode only and launch an emulation run. Once the emulation finishes, you should get a console output similar to the one below. The output given below is for random input image case:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>----------------------------------------------------------------------------

Xilinx 2D Filter Example Application <span class="o">(</span>Randomized Input Version<span class="o">)</span>

FPGA binary       : ./fpgabinary.sw_emu.xclbin
Number of runs    : <span class="m">1</span>
Image width       : <span class="m">1920</span>
Image height      : <span class="m">1080</span>
Filter <span class="nb">type</span>       : <span class="m">5</span>
Max requests      : <span class="m">12</span>
Compare perf.     : <span class="m">1</span>

Programming FPGA device
Generating a random 1920x1080 input image
Running FPGA accelerator on <span class="m">1</span> images
  finished Filter2DRequest
  finished Filter2DRequest
  finished Filter2DRequest
Running Software version
Comparing results

Test PASSED: Output matches reference
----------------------------------------------------------------------------
</pre></div>
</div>
<p>If the input image is to be used for processing, please set OpenCV paths and INPUT_TYPE as an empty string in <code class="docutils literal notranslate"><span class="pre">make_options.mk</span></code> file and run it again. Following is the expected console output:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>----------------------------------------------------------------------------

Xilinx 2D Filter Example Application

FPGA binary       : ./fpgabinary.sw_emu.xclbin
Input image       : ../test_images/picadilly_1080p.bmp
Number of runs    : <span class="m">1</span>
Filter <span class="nb">type</span>       : <span class="m">3</span>
Max requests      : <span class="m">12</span>
Compare perf.     : <span class="m">1</span>

Programming FPGA device
Running FPGA accelerator on <span class="m">1</span> images
  finished Filter2DRequest
  finished Filter2DRequest
  finished Filter2DRequest
Running Software version
Comparing results

Test PASSED: Output matches reference
----------------------------------------------------------------------------
</pre></div>
</div>
<p>The input and the output images are shown below for filter type selection set to 3 which performs edge detection:</p>
<p><img alt="missing image" src="../../../../_images/inputImage50.jpg" />
<img alt="missing image" src="../../../../_images/outputImage.jpg" /></p>
</div>
<div class="section" id="running-hardware-emulation">
<h3>Running Hardware Emulation<a class="headerlink" href="#running-hardware-emulation" title="Permalink to this heading">¶</a></h3>
<p>The application can be run in hardware emulation mode in a similar way as software emulation. The only change needed is TARGET, which should be set to  <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code>.</p>
<p><strong>NOTE</strong>: Hardware Emulation may take a long time. The <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> default setting will make sure it simulates only a single image, but it is recommended in case of the random input image that image size be set smaller by keeping image height in the range of 30-100 pixels. The height and width of the image can be specified in the <code class="docutils literal notranslate"><span class="pre">make_options.mk</span></code> file.</p>
<ol class="simple">
<li><p>Launch hardware emulation using the following command:</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make run <span class="nv">TARGET</span><span class="o">=</span>hw_emu
</pre></div>
</div>
<p>It will build the hardware kernel in emulation mode and then launch the host application. The output printed in the console window will be similar to the <code class="docutils literal notranslate"><span class="pre">sw_emu</span></code> case. But after hardware emulation, you can analyze different synthesis reports and view different waveforms using Vitis Analyzer.</p>
</div>
</div>
<div class="section" id="system-run">
<h2>System Run<a class="headerlink" href="#system-run" title="Permalink to this heading">¶</a></h2>
<p>In this section, you will run the host application using FPGA hardware and analyze the overall system’s performance using Vitis Analyzer and host application console output.</p>
<div class="section" id="building-the-hardware-xclbin">
<h3>Building the Hardware xclbin<a class="headerlink" href="#building-the-hardware-xclbin" title="Permalink to this heading">¶</a></h3>
<p>Once the kernel functionality is verified, and its resource usage is satisfactory, the hardware kernel build process can be started. The kernel build process will create an xclbin file targetting the actual accelerator card. It is an FPGA executable file that can be read and loaded by the host onto the FPGA card. Building xclbin takes a few hours, and is built as shown below:</p>
<ol class="simple">
<li><p>You can enable the performance profiling by setting “ENABLE_PROF?=yes” in <code class="docutils literal notranslate"><span class="pre">make_options.mk</span></code> file as shown below:</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span> ENABLE_PROF?<span class="o">=</span>yes
</pre></div>
</div>
<ol>
<li><p>Launch the hardware run using the following comand:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>  make build <span class="nv">TARGET</span><span class="o">=</span>hw
</pre></div>
</div>
</li>
</ol>
<blockquote>
<div><p><strong>TIP</strong>: You can use a prebuilt xclbin file if one is available by setting <strong>USE_PRE_BUILT_XCLBIN := 1</strong>  in the  <code class="docutils literal notranslate"><span class="pre">make_options.mk</span></code> file.</p>
</div></blockquote>
</div>
<div class="section" id="application-run-using-fpga-kernel">
<h3>Application Run Using FPGA Kernel<a class="headerlink" href="#application-run-using-fpga-kernel" title="Permalink to this heading">¶</a></h3>
<ol class="simple">
<li><p>To run the application, please proceed as follows:</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make run <span class="nv">TARGET</span><span class="o">=</span>hw
</pre></div>
</div>
<p>It should produce a console log similar to the one shown below:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>----------------------------------------------------------------------------

Xilinx 2D Filter Example Application <span class="o">(</span>Randomized Input Version<span class="o">)</span>

FPGA binary       : ../xclbin/fpgabinary.hw.xclbin
Number of runs    : <span class="m">60</span>
Image width       : <span class="m">1920</span>
Image height      : <span class="m">1080</span>
Filter <span class="nb">type</span>       : <span class="m">3</span>
Max requests      : <span class="m">12</span>
Compare perf.     : <span class="m">1</span>

Programming FPGA device
Generating a random 1920x1080 input image
Running FPGA accelerator on <span class="m">60</span> images
Running Software version
Comparing results

Test PASSED: Output matches reference

FPGA Time         :     <span class="m">0</span>.4240 s
FPGA Throughput   :   <span class="m">839</span>.4765 MB/s
CPU  Time         :    <span class="m">28</span>.9083 s
CPU  Throughput   :    <span class="m">12</span>.3133 MB/s
FPGA Speedup      :    <span class="m">68</span>.1764 x
----------------------------------------------------------------------------
</pre></div>
</div>
<p>From the console output, it is clear that acceleration achieved when compared to CPU is 68x. The achieved throughput is 839 MB/s, which is close to the estimated throughput of 900 MB/s; it only differs by 6.66 percent.</p>
</div>
<div class="section" id="profile-summary">
<h3>Profile Summary<a class="headerlink" href="#profile-summary" title="Permalink to this heading">¶</a></h3>
<p>This section will analyze the system performance using Vitis Analyzer by looking at different performance parameters and traces.</p>
<p>When the application is run, whether in emulation mode or on actual hardware, a trace file of runtime activities can be generated. This trace file can be viewed within Vitis Analyzer. For additional details, refer to <a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/jfn1567005096685.html">Using Vitis Analyzer</a>.</p>
<p>The trace information generated during the application run can be controlled by specifying different options inside the <code class="docutils literal notranslate"><span class="pre">xrt.ini</span></code> file placed in the same directory as the host application. Refer to <a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/xrtini.html#tpi1504034339424">xrt.ini File</a> for more information. You can examine the <code class="docutils literal notranslate"><span class="pre">xrt.ini</span></code> file used for this exercise, which is found in this tutorial’s top-level folder.</p>
<ol class="simple">
<li><p>After the design has been run; you can open the run time profile summary report using the following steps:</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>vitis_analyzer ./build/fpgabinary.xclbin.run_summary
</pre></div>
</div>
<ol>
<li><p>After the Vitis Analyzer tool opens, select <strong>Profile Summary</strong> from the left-side menu, and then select <strong>Compute Unit Utilization</strong> from the window displayed on the right-hand side.</p>
<p>The report will display stats about the measured performance of the compute units. You have built the <code class="docutils literal notranslate"><span class="pre">.xclbin</span></code> with three compute units, so the display will appear as shown below:</p>
<p><img alt="Compute Unit Utilization" src="../../../../_images/cuPerf.jpg" /></p>
<p>From this table, it can be seen that the kernel compute time as displayed in the <strong>Avg Time</strong> column is about 7 ms, almost equal to the estimated kernel latency in the previous lab.</p>
<p>Another important measurement is the <strong>CU Utilization</strong> column, which is very close to 100 percent. This means the host was able to feed data to compute units through PCIe continuously. In other words, the host PICe bandwidth was sufficient, and compute units never saturated it. This can also be observed by examining the host bandwidth utilization. To see this, select <strong>Host Data Transfers</strong> in the report, and a table similar to the figure below will be displayed. From this table, it is clear that the host bandwidth is not fully utilized.</p>
<p><img alt="missing image" src="../../../../_images/bwUtil.jpg" /></p>
<p>Similarly, by selecting <strong>Kernel Data Transfers</strong> in the report, you can see how much bandwidth is utilized between the kernel and the device DDR memory. You have used a single memory bank (DDR[1]) for all the compute units, as shown below.</p>
</li>
</ol>
<p><img alt="missing image" src="../../../../_images/bwKernel.jpg" /></p>
</div>
<div class="section" id="application-timeline">
<h3>Application Timeline<a class="headerlink" href="#application-timeline" title="Permalink to this heading">¶</a></h3>
<p>The Application Timeline can also be used to examine performance parameters like CU latency per invocation and bandwidth utilization.</p>
<ol>
<li><p>Select <strong>Application Timeline</strong> from the left-side menu.</p>
<p>This will display the Application Timeline in the right side window, as shown below.</p>
<p><img alt="missing image" src="../../../../_images/cuTime.jpg" /></p>
<p>Zoom appropriately and go to device-side trace. For any CU, hover your mouse on any transaction in “Row 0” and a tooltip will show compute start and end times and also the latency. This should be similar to what you saw in the last section.</p>
</li>
</ol>
<p>Another important thing to observe is the host data transfer trace as shown below. From this report, it can be seen that the host read and write bandwidth is not fully utilized as there are gaps, showing times when there are no read/write transactions occurring. You can see that these gaps are significant, highlighting the fact that only a fraction of host PCIe bandwidth is utilized.</p>
<p><img alt="missing image" src="../../../../_images/hostTrace.jpg" /></p>
<p>From this discussion, and knowing that the Alveo U200 accelerator card has multiple DDR banks, it should be clear that you can improve the application’s overall throughput even further. You can use additional compute units that can accelerate a single video stream to increase throughput or can be used to process multiple video streams at the same time.</p>
<p>In this lab, you have learned:</p>
<ul class="simple">
<li><p>How to build, run and analyze the performance of a video filter</p></li>
<li><p>How to write an optimized host-side application for multi CU designs</p></li>
<li><p>How to estimate kernel performance and compare it with measured performance</p></li>
</ul>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this heading">¶</a></h2>
<p>Congratulations! You have successfully completed the tutorial. In this tutorial, you have learned how to estimate the performance and acceleration requirements for the hardware implementation of a Vitis Kernel. You have analyzed kernel performance using different tools and compared measured and estimated performance, to see how close both performance number are. You have also seen that you can create an optimized memory cache or hierarchy for FPGA based implementation easily that significantly boost application performance. Finally you have learnt how to write optimized host code to get best performance out of multiple CUs for a given kernel.</p>
<hr class="docutils" />
<p align="center"><sup>Copyright&copy; 2021 Xilinx</sup></p>
</b></p></div>
</div>


           </div>
          </div>
          
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
				  
				  <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, Xilinx, Inc. Xilinx is now a part of AMD.
      <span class="lastupdated">Last updated on July 27, 2022.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>