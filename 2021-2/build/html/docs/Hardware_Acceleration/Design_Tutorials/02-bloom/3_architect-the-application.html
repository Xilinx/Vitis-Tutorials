<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
  <title>Architect a Device-Accelerated Application &mdash; Vitis™ Tutorials 2021.2 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../../../../index.html" class="icon icon-home"> Vitis™ Tutorials
            <img src="../../../../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2021.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">日本語版</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/master/docs-jp/index.html">Master</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Getting_Started/Vitis-Getting-Started.html">Getting Started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Acceleration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Hardware-Acceleration.html">Hardware Acceleration</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">AI Engine</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../AI_Engine_Development/AI_Engine_Development.html">AI Engine Development</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Platforms</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Vitis_Platform_Creation/Vitis_Platform_Creation.html">Vitis Platform Creation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2021-1/build/html/index.html">2021.1</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-2/docs/index.html">2020.2</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-1/docs/README.html">2020.1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Vitis™ Tutorials</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Architect a Device-Accelerated Application</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/docs/Hardware_Acceleration/Design_Tutorials/02-bloom/3_architect-the-application.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <table class="sphinxhide" width="100%">
 <tr width="100%">
    <td align="center"><img src="https://raw.githubusercontent.com/Xilinx/Image-Collateral/main/xilinx-logo.png" width="30%"/><h1>Vitis Hardware Acceleration</h1>
    <a href="https://www.xilinx.com/products/design-tools/vitis.html">See Vitis™ Development Environment on xilinx.com</br></a>
    </td>
 </tr>
</table><section id="architect-a-device-accelerated-application">
<h1>Architect a Device-Accelerated Application<a class="headerlink" href="#architect-a-device-accelerated-application" title="Permalink to this heading">¶</a></h1>
<p>In this lab, you evaluate the available functions or loops from the original C code, and identify which functions to target for FPGA acceleration. You must manually review the code, loop structure, and access patterns before actually running any tool.</p>
<section id="identify-functions-to-accelerate-on-the-fpga">
<h2>Identify Functions to Accelerate on the FPGA<a class="headerlink" href="#identify-functions-to-accelerate-on-the-fpga" title="Permalink to this heading">¶</a></h2>
<p>In the <code class="docutils literal notranslate"><span class="pre">02-bloom/cpu_src</span></code> directory, the main function calls the <code class="docutils literal notranslate"><span class="pre">runOnCPU</span></code> function. This function is implemented in the <code class="docutils literal notranslate"><span class="pre">02-bloom/cpu_src/compute_score_host.cpp</span></code> file.</p>
<p>The algorithm can be divided into two sections:</p>
<ul class="simple">
<li><p>Computing output flags created from the hash function of every word in all documents.</p></li>
<li><p>Computing document score based on output flags created in the previous section.</p></li>
</ul>
<p>You will evaluate which of these sections are a good fit for the FPGA.</p>
<section id="evaluate-the-murmurhash2-function">
<h3>Evaluate the MurmurHash2 Function<a class="headerlink" href="#evaluate-the-murmurhash2-function" title="Permalink to this heading">¶</a></h3>
<ol>
<li><p>Navigate to the <code class="docutils literal notranslate"><span class="pre">$LAB_WORK_DIR/cpu_src</span></code> directory for the original source code.</p></li>
<li><p>With a file editor, open the <code class="docutils literal notranslate"><span class="pre">MurmurHash2.c</span></code> file.</p></li>
<li><p>Review the following <code class="docutils literal notranslate"><span class="pre">MurmurHash2</span></code> hash function code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">MurmurHash2</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">seed</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x5bd1e995</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Initialize the hash to a &#39;random&#39; value</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seed</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Mix 4 bytes at a time into the hash</span>
<span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">key</span><span class="p">;</span><span class="w"></span>

<span class="k">switch</span><span class="p">(</span><span class="n">len</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">h</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Do a few final mixes of the hash to ensure the last few</span>
<span class="c1">// bytes are well-incorporated.</span>
<span class="n">h</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">13</span><span class="p">;</span><span class="w"></span>
<span class="n">h</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"></span>
<span class="n">h</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">15</span><span class="p">;</span><span class="w"></span>

<span class="k">return</span><span class="w"> </span><span class="n">h</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The <em>computational complexity</em> is the number of basic computing operations required to execute the function.</p>
<ul>
<li><p>The compute of the hash for a single word ID consists of four XORs, three arithmetic shifts, and two multiplication operations.</p></li>
<li><p>A shift of 1-bit in an arithmetic shift operation takes one clock cycle on the CPU.</p></li>
<li><p>The three arithmetic operations shift a total of 44-bits (when <code class="docutils literal notranslate"><span class="pre">len=3</span></code> in the above code) to compute the hash that requires 44 clock cycles just to shift the bits on the host CPU.</p></li>
<li><p>On the FPGA, you can create custom architectures, and therefore, create an accelerator that will shift the data by an arbitrary number of bits in a single clock cycle.</p></li>
<li><p>The FPGA also has dedicated DSP units that perform multiplications faster than the CPU. Even though the CPU runs at a frequency eight times higher than the FPGA, the arithmetic shift and multiplication operations can perform faster on the FPGA because of the customizable hardware architecture.</p>
<p>Therefore, this function is a good candidate for FPGA acceleration.</p>
</li>
</ul>
</li>
</ol>
</section>
<section id="evaluate-the-first-for-loop-in-the-runcpu-function-hash-functionality">
<h3>Evaluate the First “for” Loop in the runCPU Function—”Hash” Functionality<a class="headerlink" href="#evaluate-the-first-for-loop-in-the-runcpu-function-hash-functionality" title="Permalink to this heading">¶</a></h3>
<ol>
<li><p>Open <code class="docutils literal notranslate"><span class="pre">compute_score_host.cpp</span></code> file in the file editor.</p></li>
<li><p>Look at the following code at lines 32 through 58 that computes the output flags.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Compute output flags based on hash function output for the words in all documents</span>
<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">doc</span><span class="o">&lt;</span><span class="n">total_num_docs</span><span class="p">;</span><span class="n">doc</span><span class="o">++</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">profile_score</span><span class="p">[</span><span class="n">doc</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">doc_sizes</span><span class="p">[</span><span class="n">doc</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">curr_entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_doc_words</span><span class="p">[</span><span class="n">size_offset</span><span class="o">+</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">word_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr_entry</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">hash_pu</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">MurmurHash2</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">word_id</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">hash_lu</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">MurmurHash2</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">word_id</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">doc_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">word_id</span><span class="o">==</span><span class="n">docTag</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">hash1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash_pu</span><span class="o">&amp;</span><span class="n">hash_bloom</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">inh1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doc_end</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">bloom_filter</span><span class="p">[</span><span class="w"> </span><span class="n">hash1</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">hash1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x1f</span><span class="p">)));</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">hash2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">hash_pu</span><span class="o">+</span><span class="n">hash_lu</span><span class="p">)</span><span class="o">&amp;</span><span class="n">hash_bloom</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">inh2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doc_end</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">bloom_filter</span><span class="p">[</span><span class="w"> </span><span class="n">hash2</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">hash2</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x1f</span><span class="p">)));</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">inh1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">inh2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">inh_flags</span><span class="p">[</span><span class="n">size_offset</span><span class="o">+</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">inh_flags</span><span class="p">[</span><span class="n">size_offset</span><span class="o">+</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">size_offset</span><span class="o">+=</span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>From this code, you can see:</p>
<ul class="simple">
<li><p>You are computing two hash outputs for each word in all the documents and creating output flags accordingly.</p></li>
<li><p>You already determined that the hash function(<code class="docutils literal notranslate"><span class="pre">MurmurHash2()</span></code>) is a good candidate for acceleration on the FPGA.</p></li>
<li><p>The hash (<code class="docutils literal notranslate"><span class="pre">MurmurHash2()</span></code>) function with one word is independent of other words and can be done in parallel which improves the execution time.</p></li>
<li><p>The algorithm sequentially accesses to the <code class="docutils literal notranslate"><span class="pre">input_doc_words</span></code> array. This is an important property because when implemented in the FPGA, it allows for very efficient accesses to the DDR.</p></li>
</ul>
<p>This code section is a good candidate for FPGA acceleration because the hash function can run faster on the FPGA, and you can compute hashes for multiple words in parallel by reading multiple words from the DDR in burst mode.</p>
<p>Now, you are ready to review the second for loop.</p>
</li>
<li><p>Keep <code class="docutils literal notranslate"><span class="pre">compute_score_host.cpp</span></code> open in the file editor.</p></li>
</ol>
</section>
<section id="evaluate-the-second-for-loop-in-the-runoncpu-function-profile-compute-score-functionality">
<h3>Evaluate the Second “for” Loop in the runOnCPU Function—”Profile Compute Score” Functionality<a class="headerlink" href="#evaluate-the-second-for-loop-in-the-runoncpu-function-profile-compute-score-functionality" title="Permalink to this heading">¶</a></h3>
<ol>
<li><p>Look at the following code that computes the document score.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">doc</span><span class="o">&lt;</span><span class="n">total_num_docs</span><span class="p">;</span><span class="n">doc</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">profile_score</span><span class="p">[</span><span class="n">doc</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">doc_sizes</span><span class="p">[</span><span class="n">doc</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="n">n</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">inh_flags</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">curr_entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_doc_words</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">frequency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr_entry</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x00ff</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">word_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr_entry</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">profile_score</span><span class="p">[</span><span class="n">doc</span><span class="p">]</span><span class="o">+=</span><span class="w"> </span><span class="n">profile_weights</span><span class="p">[</span><span class="n">word_id</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">frequency</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ul>
<li><p>The compute score requires one memory access to <code class="docutils literal notranslate"><span class="pre">profile_weights</span></code>, one accumulation, and one multiplication operation.</p></li>
<li><p>The memory accesses are random because they depend on the <code class="docutils literal notranslate"><span class="pre">word_id</span></code> and therefore, the content of each document.</p></li>
<li><p>The size of the <code class="docutils literal notranslate"><span class="pre">profile_weights</span></code> array is 128 MB and must be stored in the DDR memory connected to the FPGA. Non-sequential accesses to DDR are big performance bottlenecks. Because accesses to the <code class="docutils literal notranslate"><span class="pre">profile_weights</span></code> array are random, implementing this function on the FPGA would not provide much performance benefit, and because the function takes only about 11% of the total running time, you can keep this function on the host CPU.</p>
<p>Based on this analysis, it is only beneficial to accelerate the Compute Output Flags from the Hash section on the FPGA. The execution of the Compute Document Score section can be kept on the host CPU.</p>
</li>
</ul>
</li>
<li><p>Close the file editor.</p></li>
</ol>
</section>
</section>
<section id="establish-the-realistic-goal-for-the-overall-application">
<h2>Establish the Realistic Goal for the Overall Application<a class="headerlink" href="#establish-the-realistic-goal-for-the-overall-application" title="Permalink to this heading">¶</a></h2>
<p>The Compute Score function is calculated on the CPU. Based on your calculations in the previous lab, it takes about 380 ms. You cannot accelerate the function further for a given CPU. Even if the FPGA can compute the hash function in zero time, the application will still take at the minimum of 380 ms, but running the FPGA in no time is also not realistic. You also need to account for sending the data from the CPU to the FPGA and retrieving it back to the CPU from the FPGA which will also add a delay.</p>
<ol>
<li><p>Set the goal for the application such that the Compute Hash function (in Hardware) should run as fast as the Compute Score on the CPU so that the hash function does not become the bottleneck.</p>
<ol class="simple">
<li><p>Use 100,000 input documents for your calculations. This is the equivalent of 350M words with approximately 3,500 words per document.</p></li>
<li><p>Keep only the compute hash function in the FPGA. In software, this function takes about 2569 ms.</p></li>
</ol>
<p>The goal of application has been established to compute the hashes and overall score of the 10,000 documents in about 380 ms.</p>
</li>
</ol>
<section id="determine-the-maximum-achievable-throughput">
<h3>Determine the Maximum Achievable Throughput<a class="headerlink" href="#determine-the-maximum-achievable-throughput" title="Permalink to this heading">¶</a></h3>
<p>In most FPGA-accelerated systems, the maximum achievable throughput is limited by the PCIe® bus. The PCIe bus performance is influenced by many different aspects, such as the motherboard, drivers, targeted shell, and transfer sizes. The Vitis core development kit provides a utility, <code class="docutils literal notranslate"><span class="pre">xbutil</span></code>.</p>
<p>Run the <code class="docutils literal notranslate"><span class="pre">xbutil</span> <span class="pre">validate</span></code> command to measure the maximum PCIe bandwidth that can be achieved. The throughput on your design target cannot exceed this upper limit.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">xbutil</span> <span class="pre">validate</span></code> command produces the following output.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">Host</span> <span class="o">-&gt;</span> <span class="n">PCIe</span> <span class="o">-&gt;</span> <span class="n">FPGA</span> <span class="n">write</span> <span class="n">bandwidth</span> <span class="o">=</span> <span class="mf">8485.43</span> <span class="n">MB</span><span class="o">/</span><span class="n">s</span>
  <span class="n">Host</span> <span class="o">&lt;-</span> <span class="n">PCIe</span> <span class="o">&lt;-</span> <span class="n">FPGA</span> <span class="n">read</span> <span class="n">bandwidth</span> <span class="o">=</span> <span class="mf">12164.4</span> <span class="n">MB</span><span class="o">/</span><span class="n">s</span>
  <span class="n">Data</span> <span class="n">Validity</span> <span class="o">&amp;</span> <span class="n">DMA</span> <span class="n">Test</span> <span class="n">on</span> <span class="n">bank1</span>
  <span class="n">Host</span> <span class="o">-&gt;</span> <span class="n">PCIe</span> <span class="o">-&gt;</span> <span class="n">FPGA</span> <span class="n">write</span> <span class="n">bandwidth</span> <span class="o">=</span> <span class="mf">9566.47</span> <span class="n">MB</span><span class="o">/</span><span class="n">s</span>
  <span class="n">Host</span> <span class="o">&lt;-</span> <span class="n">PCIe</span> <span class="o">&lt;-</span> <span class="n">FPGA</span> <span class="n">read</span> <span class="n">bandwidth</span> <span class="o">=</span> <span class="mf">12155.7</span> <span class="n">MB</span><span class="o">/</span><span class="n">s</span>
  <span class="n">Data</span> <span class="n">Validity</span> <span class="o">&amp;</span> <span class="n">DMA</span> <span class="n">Test</span> <span class="n">on</span> <span class="n">bank2</span>
  <span class="n">Host</span> <span class="o">-&gt;</span> <span class="n">PCIe</span> <span class="o">-&gt;</span> <span class="n">FPGA</span> <span class="n">write</span> <span class="n">bandwidth</span> <span class="o">=</span> <span class="mf">8562.48</span> <span class="n">MB</span><span class="o">/</span><span class="n">s</span>
  <span class="n">Host</span> <span class="o">&lt;-</span> <span class="n">PCIe</span> <span class="o">&lt;-</span> <span class="n">FPGA</span> <span class="n">read</span> <span class="n">bandwidth</span> <span class="o">=</span> <span class="mf">12154.5</span> <span class="n">MB</span><span class="o">/</span><span class="n">s</span>
</pre></div>
</div>
<p>The PCIe FPGA write bandwidth is about 9 GB/sec and the FPGA read bandwidth is about 12 GB/sec. The PCIe bandwidth is 3.1 GB/sec above your established goal.</p>
</section>
<section id="identifying-parallelization-for-an-fpga-application">
<h3>Identifying Parallelization for an FPGA Application<a class="headerlink" href="#identifying-parallelization-for-an-fpga-application" title="Permalink to this heading">¶</a></h3>
<p>In Software, the flow will look similar to the following figure.
<img alt="missing image" src="../../../../_images/Architect1.PNG" /></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Murmurhash2</span></code> functions are calculated for all the words up front, and output flags are set in the local memory. Each of the loops in the hash compute functions are run sequentially.</p></li>
<li><p>After all hashes have computed, only then can another loop be called for all the documents to calculate the compute score.</p></li>
</ul>
<p>When you run the application on the FPGA, an additional delay is added when the data is transferred from the host to device memory and read back. You can split the entire application time and create a budgeted-based run based on following requirements:</p>
<ol class="simple">
<li><p>Transferring document data of size 1400 MB from the host application to the device DDR using PCIe. Using a PCIe Write BW of approximately 9 GBps, the approximate time for transfer = 1400 MB/9.5 GBps = ~147 ms.</p></li>
<li><p>Compute the hashes on the FPGA.</p></li>
<li><p>Transferring flags data of size 350 MB from Device to Host using PCIe. Using a PCIe Read BW of approximately 12 GBps, the approximate time for transfer = 350 MB/12G = ~30 ms.</p></li>
<li><p>Calculate the compute score after all the flags are available from the FPGA. This takes about a total of 380 ms on the CPU.</p></li>
</ol>
<p>For achieving application target of 380 ms, adding 1470 ms + 30 ms + 380 ms is clearly above your goal of 380 ms for 100,000 documents computation, and the FPGA time for computing the hashes has not yet been accounted for. However unlike the CPU, parallelization can be achieved while working with the FPGA. You should also architect an accelerator for “Compute hashes on FPGA” for the best possible performance to ensure the FPGA compute is not the bottleneck.</p>
<p>If steps 1 through 4 are carried out sequentially like the CPU, you cannot achieve your performance goal. You will need to take advantage of concurrent processing and overlapping of the FPGA.</p>
<ol class="simple">
<li><p>Parallelism between the host to device data transfer and Compute on FPGA. Split the 100,000 documents into multiple buffers, and send the buffers to the device so the kernel does not need to wait until the whole buffer is transferred.</p></li>
<li><p>Parallelism between Compute on FPGA and Compute Profile score on CPU</p></li>
<li><p>Increase the number of words to be processed in parallel to increase the concurrent hash compute processing. The hash compute in the CPU is performed on a 32-bit word. Because the hash compute can be completed independently on several words, you can explore computing 4, 8, or even 16 words in parallel.</p></li>
</ol>
<p>Based on your earlier analysis, the <code class="docutils literal notranslate"><span class="pre">Murmurhash2</span></code> function is a good candidate for computation on the FPGA, and the Compute Profile Score calculation can be carried out on the host. For a hardware function on the FPGA, based on the established goal in previous lab, you should process hashes as fast as possible by processing multiples of these words every clock cycle.</p>
<p>The application conceptually can similar to the following figure.</p>
<p><img alt="missing image" src="../../../../_images/Architect2.PNG" /></p>
<p>Transferring words from the host to CPU, Compute on FPGA, transferring words from the FPGA to CPU all can be executed in parallel. The CPU starts to calculate the profile score as soon as the flags are received;essentially, the profile score on the CPU can also start calculations in parallel. With the pipelining as shown above, the latency of the Compute on FPGA will become invisible.</p>
</section>
</section>
<section id="next-steps">
<h2>Next Steps<a class="headerlink" href="#next-steps" title="Permalink to this heading">¶</a></h2>
<p>In this lab, you profiled an application and determined which parts were best-suited for FPGA acceleration. You also created the setup to create an optimized kernel to achieve your acceleration goal. You will explore these steps in the following lab sections:</p>
<ul class="simple">
<li><p><a class="reference internal" href="4_implement-kernel.html"><span class="doc">Implementing the Kernel</span></a>: Create an optimized kernel with 4, 8, and 16 words to be processed in parallel and all 100,000 documents worth 1.4 GB are sent from host to kernel in single batch.</p></li>
<li><p><a class="reference internal" href="5_data-movement.html"><span class="doc">Analyze Data Movement Between Host and Kernel</span></a>: Explore sending 100,000 documents in multiple batches, so that the kernel compute can be overlapped with the host data transfer for optimized application performance. You will analyze the results by keeping the <code class="docutils literal notranslate"><span class="pre">Murmurhash2</span></code> functions on the FPGA and Compute Score functions on the CPU to process in sequential mode. Next, flags created by the accelerator will also be sent over to the host and overlapped with the host to data transfer and FPGA compute.</p></li>
<li><p><a class="reference internal" href="6_using-multiple-ddr.html"><span class="doc">Using Multiple DDR Banks</span></a>: Explore using multiple DDR banks to potentially improve the application performance. The DDR banks are accessed by the host and kernel at the same time.</p></li>
</ul>
<p>In the next section, you will <a class="reference internal" href="4_implement-kernel.html"><span class="doc">implement the kernel</span></a> by applying the “Methodology for Developing C/C++ Kernels” to create an optimized kernel to meet the requirements of the kernel specification.</p>
<hr/>
<p align="center" class="sphinxhide"><b><a href="docs/bloom/README.md">Return to Start of Tutorial</a></b></p><p align="center" class="sphinxhide"><sup>Copyright&copy; 2021 Xilinx</sup></p></section>
</section>


           </div>
          </div>
          
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
				  
				  <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, Xilinx, Inc. Xilinx is now a part of AMD.
      <span class="lastupdated">Last updated on July 27, 2022.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>