<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
  <title>Window Based AI Engine Kernels &mdash; Vitis™ Tutorials 2020.2 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../../../../index.html" class="icon icon-home"> Vitis™ Tutorials
            <img src="../../../../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2020.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">日本語版</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/master/docs-jp/README.html">Master</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting Started Pathway</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Getting_Started/Vitis/README.html">Vitis Flow 101 Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Getting_Started/Vitis_HLS/README.html">Vitis HLS Analysis and Optimization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Hardware Accelerators</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Introduction/README.html">Introduction to Vitis Hardware Accelerators Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Design_Tutorials/02-bloom/README.html">Optimizing Accelerated FPGA Applications: Bloom Filter Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Design_Tutorials/01-convolution-tutorial/README.html">Accelerating Video Convolution Filtering Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Design_Tutorials/03-rtl_stream_kernel_integration/README.html">Mixed Kernels Design Tutorial with AXI Stream and Vitis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Design_Tutorials/04-traveling-salesperson/README.html">The Travelling Salesman Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Design_Tutorials/05-bottom_up_rtl_kernel/README.html">Bottom-up RTL Kernel Flow with Vitis for Acceleration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Feature_Tutorials/01-rtl_kernel_workflow/README.html">Getting Started with RTL Kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Feature_Tutorials/02-mixing-c-rtl-kernels/README.html">Mixing C++ and RTL Kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Feature_Tutorials/03-dataflow_debug_and_optimization/README.html">Vitis HLS Analysis and Optimization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Runtime and System Optimization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Design_Tutorials/01-host-code-opt/README.html">Host Code Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Design_Tutorials/02-ivas-ml/README.html">IVAS ZCU104 ML Acceleration Reference Release</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Feature_Tutorials/01-mult-ddr-banks/README.html">Using Multiple DDR Banks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Feature_Tutorials/02-using-multiple-cu/README.html">Using Multiple Compute Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Feature_Tutorials/03-controlling-vivado-implementation/README.html">Controlling Vivado Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Feature_Tutorials/04-using-hbm/README.html">Using HBM</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Vitis Platform Creation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Vitis_Platform_Creation/Introduction/01-Overview/README.html">Platform Creation Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Vitis_Platform_Creation/Introduction/02-Edge-AI-ZCU104/README.html">Vitis Custom Embedded Platform Creation Example on ZCU104</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Vitis_Platform_Creation/Introduction/03_Edge_VCK190/README.html">Versal Custom Platform Creation Tutorial</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/">Main</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2021-2/build/html/index.html">2021.2</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2021-1/build/html/index.html">2021.1</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-1/docs/build/html/README.html">2020.1</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Vitis™ Tutorials</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Window Based AI Engine Kernels</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/docs/AI_Engine_Development/Feature_Tutorials/04-packet-switching/window_based_aie_kernel.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <table>
 <tr>
   <td align="center"><img src="https://raw.githubusercontent.com/Xilinx/Image-Collateral/main/xilinx-logo.png" width="30%"/><h1>AI Engine Packet Switching Tutorial</h1>
   </td>
 </tr>
 <tr>
 </td>
 </tr>
</table><div class="section" id="window-based-ai-engine-kernels">
<h1>Window Based AI Engine Kernels<a class="headerlink" href="#window-based-ai-engine-kernels" title="Permalink to this heading">¶</a></h1>
<p>This example shows you how to construct a graph with packet switching capability. In the first section, <a class="reference external" href="#Construct-Graph-with-Packet-Switching-Capability">Construct Graph with Packet Switching Capability</a>, the example graph features:</p>
<ul class="simple">
<li><p>Four parallel AI Engine kernels, with all four kernels sharing the same input and output ports to the PL.</p></li>
<li><p>The AI Engine kernels use window interfaces, which means they are agnostic about how data is communicated to the PL.</p></li>
</ul>
<p>This section introduces two new templated node classes, <code class="docutils literal notranslate"><span class="pre">pktsplit&lt;n&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">pktmerge&lt;n&gt;</span></code>, to construct the graph. These classes switch the packet to the correct destination and construct the packet with the corresponding packet IDs, respectively.</p>
<p>Then this example introduces the <a class="reference external" href="#Packet-Format">Packet Format</a> and how to <a class="reference external" href="#Prepare-Data-and-Run-AI-Engine-Simulator">Prepare Data and Run AI Engine Simulator</a>.</p>
<p>Then, it introduces a system design that includes <a class="reference external" href="#Example-PL-Kernels-for-Packet-Switching">Example PL Kernels for Packet Switching</a>.
In the example PL kernels, you can see how a packet is constructed and how the packet ID generated by the AI Engine compiler is used.</p>
<p>Then, PS code for the system design is introduced in <a class="reference external" href="#Example-PS-code-for-Packet-Switching">Example PS code for Packet Switching</a>.</p>
<p>Finally, you can see how to <a class="reference external" href="#Run-Hardware-Emulation-and-Hardware-flows">Run Hardware Emulation and Hardware flows</a>.</p>
<div class="section" id="construct-graph-with-packet-switching-capability">
<h2>Construct Graph with Packet Switching Capability<a class="headerlink" href="#construct-graph-with-packet-switching-capability" title="Permalink to this heading">¶</a></h2>
<p>To explicitly control the multiplexing and de-multiplexing of packets, two new templated node classes are added to the ADF graph library: <code class="docutils literal notranslate"><span class="pre">pktsplit&lt;n&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">pktmerge&lt;n&gt;</span></code>. A node instance of class <code class="docutils literal notranslate"><span class="pre">pktmerge&lt;n&gt;</span></code> is a n:1 multiplexer of n packet streams producing a single packet stream. A node instance of class <code class="docutils literal notranslate"><span class="pre">pktsplit&lt;n&gt;</span></code> is a 1:n de-multiplexer of a packet stream producing n different packet streams.</p>
<p><strong>Note: The maximum number of allowable packet streams is four on a single physical channel (<strong>n≤4</strong>).</strong></p>
<p>The data from the PLIO is first connected to the <code class="docutils literal notranslate"><span class="pre">pktsplit&lt;n&gt;</span></code> instance, which splits the packet depending on the packet ID. It automatically discards the packet header and fills the window input buffers. It automatically discards the <code class="docutils literal notranslate"><span class="pre">TLAST</span></code> signal of the packet when the window data is fully filled.</p>
<p>Each AI Engine kernel works similarly to a non-packet switching kernel. The output data is merged by the <code class="docutils literal notranslate"><span class="pre">pktmerge&lt;n&gt;</span></code> instance, which automatically inserts the packet headers with packet IDs, and <code class="docutils literal notranslate"><span class="pre">TLAST</span></code> for the last data of the packet.</p>
<p><strong>Hint: Make sure the packet length matches the window size for either kernel input or output window.</strong></p>
<p>Change the working directory to <code class="docutils literal notranslate"><span class="pre">window_aie</span></code>. The example graph code is in <code class="docutils literal notranslate"><span class="pre">aie/graph.h</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">mygraph</span><span class="p">:</span> <span class="n">public</span> <span class="n">adf</span><span class="p">::</span><span class="n">graph</span> <span class="p">{</span>
<span class="n">private</span><span class="p">:</span>
  <span class="n">adf</span><span class="p">::</span> <span class="n">kernel</span> <span class="n">core</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

  <span class="n">adf</span><span class="p">::</span> <span class="n">pktsplit</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">;</span>
  <span class="n">adf</span><span class="p">::</span> <span class="n">pktmerge</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">mg</span><span class="p">;</span>
<span class="n">public</span><span class="p">:</span>
  <span class="n">adf</span><span class="p">::</span><span class="n">port</span><span class="o">&lt;</span><span class="nb">input</span><span class="o">&gt;</span>  <span class="ow">in</span><span class="p">;</span>
  <span class="n">adf</span><span class="p">::</span><span class="n">port</span><span class="o">&lt;</span><span class="n">output</span><span class="o">&gt;</span>  <span class="n">out</span><span class="p">;</span>
  <span class="n">mygraph</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">core</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">aie_core1</span><span class="p">);</span>
    <span class="n">core</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">aie_core2</span><span class="p">);</span>
    <span class="n">core</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">aie_core3</span><span class="p">);</span>
    <span class="n">core</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">aie_core4</span><span class="p">);</span>
    <span class="n">adf</span><span class="p">::</span><span class="n">source</span><span class="p">(</span><span class="n">core</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">=</span> <span class="s2">&quot;aie_core1.cpp&quot;</span><span class="p">;</span>
    <span class="n">adf</span><span class="p">::</span><span class="n">source</span><span class="p">(</span><span class="n">core</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">=</span> <span class="s2">&quot;aie_core2.cpp&quot;</span><span class="p">;</span>
    <span class="n">adf</span><span class="p">::</span><span class="n">source</span><span class="p">(</span><span class="n">core</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="s2">&quot;aie_core3.cpp&quot;</span><span class="p">;</span>
    <span class="n">adf</span><span class="p">::</span><span class="n">source</span><span class="p">(</span><span class="n">core</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">=</span> <span class="s2">&quot;aie_core4.cpp&quot;</span><span class="p">;</span>

    <span class="n">sp</span> <span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">pktsplit</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">::</span><span class="n">create</span><span class="p">();</span>
    <span class="n">mg</span> <span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">pktmerge</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">::</span><span class="n">create</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
      <span class="n">adf</span><span class="p">::</span><span class="n">runtime</span><span class="o">&lt;</span><span class="n">ratio</span><span class="o">&gt;</span><span class="p">(</span><span class="n">core</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">;</span>
      <span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">pktstream</span><span class="p">,</span> <span class="n">adf</span><span class="p">::</span><span class="n">window</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">core</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="ow">in</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">window</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">adf</span><span class="p">::</span><span class="n">pktstream</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">core</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mg</span><span class="o">.</span><span class="ow">in</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">pktstream</span><span class="o">&gt;</span> <span class="p">(</span><span class="ow">in</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="ow">in</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">pktstream</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">mg</span><span class="o">.</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This is a graph with a 4:1 splitter <code class="docutils literal notranslate"><span class="pre">pktsplit&lt;4&gt;</span></code> and 1:4 merger <code class="docutils literal notranslate"><span class="pre">pktmerge&lt;4&gt;</span></code>. Note that the connection type for <code class="docutils literal notranslate"><span class="pre">pktsplit</span></code> and <code class="docutils literal notranslate"><span class="pre">pktmerge</span></code> is <code class="docutils literal notranslate"><span class="pre">adf::pktstream</span></code>. The input port <code class="docutils literal notranslate"><span class="pre">in</span></code> is first connected to the <code class="docutils literal notranslate"><span class="pre">pktsplit</span></code>, and <code class="docutils literal notranslate"><span class="pre">pktsplit</span></code> switches the packets to different AI Engine kernels. The outputs of AI Engine kernels are connected to the <code class="docutils literal notranslate"><span class="pre">pktmerge</span></code>, and <code class="docutils literal notranslate"><span class="pre">pktmerge</span></code> generates packet headers for those packets automatically and outputs them through output port, <code class="docutils literal notranslate"><span class="pre">out</span></code>.</p>
<p>Run the make command <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">aie</span></code> to compile the graph. Then open the compiled summary with the Vitis™ analyzer using the command <code class="docutils literal notranslate"><span class="pre">vitis_analyzer</span> <span class="pre">./Work/graph.aiecompile_summary</span></code>. Then click the <code class="docutils literal notranslate"><span class="pre">Graph</span></code> tab in the Vitis analyzer. The graph of the design is shown as follows:</p>
<p><img alt="graph" src="../../../../_images/pic1.png" /></p>
<p>It is seen that every <code class="docutils literal notranslate"><span class="pre">sp</span></code> output has been assigned a unique packet ID. Also, every <code class="docutils literal notranslate"><span class="pre">mg</span></code> input has been assigned a unique ID. The packet IDs can vary on different implementations. The AI Engine compiler generates a JSON file that contains all the packet ID infomation <code class="docutils literal notranslate"><span class="pre">Work/reports/packet_switching_report.json</span></code>. It also generates header files that define unique macro variables for the packet IDs. These files are <code class="docutils literal notranslate"><span class="pre">Work/temp/packet_ids_c.h</span></code> and <code class="docutils literal notranslate"><span class="pre">Work/temp/packet_ids_v.h</span></code>, which can be directly included in the C or Verilog source code.</p>
<p>For example, in this test case, the <code class="docutils literal notranslate"><span class="pre">Work/temp/packet_ids_c.h</span></code> is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define Datain0_0 0</span>
<span class="c1">#define Datain0_1 1</span>
<span class="c1">#define Datain0_2 2</span>
<span class="c1">#define Datain0_3 3</span>
<span class="c1">#define Dataout0_0 3</span>
<span class="c1">#define Dataout0_1 2</span>
<span class="c1">#define Dataout0_2 1</span>
<span class="c1">#define Dataout0_3 0</span>
</pre></div>
</div>
<p>The macro names <code class="docutils literal notranslate"><span class="pre">Datain0_0</span></code>, …, <code class="docutils literal notranslate"><span class="pre">Dataout0_3</span></code> do not change between different compilations. You can see how these macros are used in the PL kernels in this test case in a later section.</p>
</div>
<div class="section" id="packet-format">
<h2>Packet Format<a class="headerlink" href="#packet-format" title="Permalink to this heading">¶</a></h2>
<p>The first 32-bit word of a packet must always be a packet header which encodes several bit fields, as shown in the following table.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Bit</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>4-0</td>
<td>Packet ID</td>
</tr>
<tr>
<td>11-5</td>
<td>7'b0000000</td>
</tr>
<tr>
<td>14-12</td>
<td>Packet Type</td>
</tr>
<tr>
<td>15</td>
<td>1'b0</td>
</tr>
<tr>
<td>20-16</td>
<td>Source Row</td>
</tr>
<tr>
<td>27-21</td>
<td>Source Column</td>
</tr>
<tr>
<td>30-28</td>
<td>3'b000</td>
</tr>
<tr>
<td>31</td>
<td>Odd parity of bits[30:0]</td>
</tr>
</tbody>
</table><p>The packet ID in the header should match the ID assigned by the compiler. The packet type can be any 3-bit pattern that you want to insert to identify the type of packet. The source row and column denote the AI Engine tile coordinates from where the packet originated. By convention, source row and column for packets originating in the PL is -1,-1.</p>
<p>The last 32-bit word should have its <code class="docutils literal notranslate"><span class="pre">TLAST</span></code> set High. Other words should set their <code class="docutils literal notranslate"><span class="pre">TLAST</span></code> Low.</p>
<p>When the packet originates from the PL, the packet header should be constructed by the PL kernels manually. When the AI Engine receives the packet, it is decoded and routed to the destination corresponding to the packet ID in the header.</p>
<p>When the packet originates from AI Engine, the first 32-bit word should be decoded by the PL kernels manually. By decoding the packet ID from the packet, and reading the packet switching header files (<code class="docutils literal notranslate"><span class="pre">Work/temp/packet_ids_c.h</span></code> and <code class="docutils literal notranslate"><span class="pre">Work/temp/packet_ids_v.h</span></code>) by the compiler, the PL kernels should be able to route the packet to the correct destination.</p>
</div>
<div class="section" id="prepare-data-and-run-ai-engine-simulator">
<h2>Prepare Data and Run AI Engine Simulator<a class="headerlink" href="#prepare-data-and-run-ai-engine-simulator" title="Permalink to this heading">¶</a></h2>
<p>When constructing the input data file for the AI Engine simulator, the data file should contain the sequence of packets. Each packet contains the packet header, follwed by the data. The last data has the <code class="docutils literal notranslate"><span class="pre">TLAST</span></code> keyword in a separate line just above the data. The data is in 32-bit integer format, including the header. The following is an example of a packet in the data file (<code class="docutils literal notranslate"><span class="pre">data/input.txt</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2415853568</span>
<span class="mi">0</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">4</span>
<span class="mi">5</span>
<span class="mi">6</span>
<span class="n">TLAST</span>
<span class="mi">7</span>
</pre></div>
</div>
<p>In this packet, <code class="docutils literal notranslate"><span class="pre">2415853568</span></code> is an integer. The hex value for <code class="docutils literal notranslate"><span class="pre">2415853568</span></code> is <code class="docutils literal notranslate"><span class="pre">0x8FFF0000</span></code>, which has packet ID of 0 (the last five bits). It is useful for you to have your own program to convert the original data into the data file with packet headers in the required format.</p>
<p>When the input PLIO is not 32 bits wide, it can include multiple 32-bit integers in a line to construct wider bit words, with spaces between them. For example, the following is an example packet for a 64-bit width PLIO.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2415853568</span> <span class="mi">0</span>
<span class="mi">1</span> <span class="mi">2</span>
<span class="mi">3</span> <span class="mi">4</span>
<span class="mi">5</span> <span class="mi">6</span>
<span class="n">TLAST</span>
<span class="mi">7</span>
</pre></div>
</div>
<p>Run the AI Engine simulator with following make command. The detailed information for the AI Engine compiler and AI Engine simulator commands can be found in <a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/yii1603912637443.html">AI Engine Documentation</a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">aiesim</span>
</pre></div>
</div>
<p>The output data is in <code class="docutils literal notranslate"><span class="pre">aiesimulator_output/data/output.txt</span></code>. The output data is also arranged as sucessive packets, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="mi">413</span> <span class="n">ns</span>
<span class="mi">50462720</span> 
<span class="n">T</span> <span class="mi">416</span> <span class="n">ns</span>
<span class="mi">4</span> 
<span class="n">T</span> <span class="mi">417</span> <span class="n">ns</span>
<span class="mi">8</span> 
<span class="n">T</span> <span class="mi">418</span> <span class="n">ns</span>
<span class="mi">12</span> 
<span class="n">T</span> <span class="mi">419</span> <span class="n">ns</span>
<span class="mi">16</span> 
<span class="n">T</span> <span class="mi">420</span> <span class="n">ns</span>
<span class="mi">20</span> 
<span class="n">T</span> <span class="mi">421</span> <span class="n">ns</span>
<span class="mi">24</span> 
<span class="n">T</span> <span class="mi">422</span> <span class="n">ns</span>
<span class="mi">28</span> 
<span class="n">T</span> <span class="mi">423</span> <span class="n">ns</span>
<span class="n">TLAST</span>
<span class="mi">32</span> 
</pre></div>
</div>
<p>The packet header is the first 32-bit word <code class="docutils literal notranslate"><span class="pre">50462720</span></code>. Its hex value is <code class="docutils literal notranslate"><span class="pre">0x3020000</span></code>. Therefore the packet ID is 0 (the last 5 bits). You can look at the packet switching header files (<code class="docutils literal notranslate"><span class="pre">Work/temp/packet_ids_c.h</span></code> and <code class="docutils literal notranslate"><span class="pre">Work/temp/packet_ids_v.h</span></code>) to find out which AI Engine kernel has produced it. The <code class="docutils literal notranslate"><span class="pre">Work/temp/packet_ids_c.h</span></code> has defined:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define Dataout0_3 0</span>
</pre></div>
</div>
<p>Here, Dataout0_<strong>3</strong> denotes that the packet ID 0 comes from <code class="docutils literal notranslate"><span class="pre">pktmerge.in[3]</span></code>. By looking at the graph code (<code class="docutils literal notranslate"><span class="pre">aie/graph.h</span></code>) or graph view in Vitis analyzer, you can find which AI Engine kernel actually produced it. In this example result, it is kernel <code class="docutils literal notranslate"><span class="pre">core[3]</span></code> (<code class="docutils literal notranslate"><span class="pre">aie/aie_core4.cpp</span></code>).</p>
</div>
<div class="section" id="example-pl-kernels-for-packet-switching">
<h2>Example PL Kernels for Packet Switching<a class="headerlink" href="#example-pl-kernels-for-packet-switching" title="Permalink to this heading">¶</a></h2>
<p>This section describes how the PL kernels can generate and decode packet headers, and how to distribute packets to the corresponding destinations. HLS example code is provided, and hardware emulation and hardware flows can be run.</p>
<p>The packet switching feature does not have a dependency on the PL kernel types (HLS, Verilog, etc) and their design structure. It just has requirements around the packet format and how the packet ID works as described in the previous sections.</p>
<p>The system design structure of the example is as follows:</p>
<p><img alt="graph" src="../../../../_images/pic2.png" /></p>
<p>The previous section has introduced the AI Engine side. It receives packets from one PLIO (AXI4-Stream interface), and distributes the packets to different AI Engine kernels. Then all AI Engine outputs are packed with packet headers automatically and sent to one PLIO.</p>
<p>In this example, the PL kernel <code class="docutils literal notranslate"><span class="pre">mm2s1</span></code> sends raw data to the HLS packet sender module, and the HLS packet sender module generates packets that match the packet switching requirements. It goes through the AI Engine kernel, <code class="docutils literal notranslate"><span class="pre">core[0]</span></code> (<code class="docutils literal notranslate"><span class="pre">aie/aie_core1.cpp</span></code>). Then the HLS packet receiver module decodes the packet header and sends the raw data to the PL kernel, <code class="docutils literal notranslate"><span class="pre">s2mm1</span></code>. Similarly, PL kernel, <code class="docutils literal notranslate"><span class="pre">mm2s2</span></code>, sends a message to PL kernel, <code class="docutils literal notranslate"><span class="pre">s2mm2</span></code>. And it is the same for <code class="docutils literal notranslate"><span class="pre">mm2s3</span></code> to <code class="docutils literal notranslate"><span class="pre">s2mm3</span></code> and <code class="docutils literal notranslate"><span class="pre">mm2s4</span></code> to <code class="docutils literal notranslate"><span class="pre">s2mm4</span></code>.</p>
<p>Only the HLS packet sender module and HLS packet receiver module deal with the packet IDs generated by the AI Engine compiler. Other PL kernels focus on the data processing.</p>
<p>In this example, the four <code class="docutils literal notranslate"><span class="pre">mm2s</span></code> kernels are created by the <code class="docutils literal notranslate"><span class="pre">--nk</span></code> option of V++ linker. The same applies for the <code class="docutils literal notranslate"><span class="pre">s2mm</span></code> kernels. You can look at <code class="docutils literal notranslate"><span class="pre">system.cfg</span></code> to see how all PL kernels are created and connected:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">connectivity</span><span class="p">]</span>
<span class="n">nk</span><span class="o">=</span><span class="n">s2mm</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="n">s2mm_1</span><span class="o">.</span><span class="n">s2mm_2</span><span class="o">.</span><span class="n">s2mm_3</span><span class="o">.</span><span class="n">s2mm_4</span>
<span class="n">nk</span><span class="o">=</span><span class="n">mm2s</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="n">mm2s_1</span><span class="o">.</span><span class="n">mm2s_2</span><span class="o">.</span><span class="n">mm2s_3</span><span class="o">.</span><span class="n">mm2s_4</span>
<span class="n">nk</span><span class="o">=</span><span class="n">hls_packet_sender</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="n">hls_packet_sender_1</span>
<span class="n">nk</span><span class="o">=</span><span class="n">hls_packet_receiver</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="n">hls_packet_receiver_1</span>
<span class="n">stream_connect</span><span class="o">=</span><span class="n">hls_packet_sender_1</span><span class="o">.</span><span class="n">out</span><span class="p">:</span><span class="n">ai_engine_0</span><span class="o">.</span><span class="n">Datain0</span>
<span class="n">stream_connect</span><span class="o">=</span><span class="n">ai_engine_0</span><span class="o">.</span><span class="n">Dataout0</span><span class="p">:</span><span class="n">hls_packet_receiver_1</span><span class="o">.</span><span class="ow">in</span>

<span class="n">stream_connect</span><span class="o">=</span><span class="n">mm2s_1</span><span class="o">.</span><span class="n">s</span><span class="p">:</span><span class="n">hls_packet_sender_1</span><span class="o">.</span><span class="n">s0</span>
<span class="n">stream_connect</span><span class="o">=</span><span class="n">mm2s_2</span><span class="o">.</span><span class="n">s</span><span class="p">:</span><span class="n">hls_packet_sender_1</span><span class="o">.</span><span class="n">s1</span>
<span class="n">stream_connect</span><span class="o">=</span><span class="n">mm2s_3</span><span class="o">.</span><span class="n">s</span><span class="p">:</span><span class="n">hls_packet_sender_1</span><span class="o">.</span><span class="n">s2</span>
<span class="n">stream_connect</span><span class="o">=</span><span class="n">mm2s_4</span><span class="o">.</span><span class="n">s</span><span class="p">:</span><span class="n">hls_packet_sender_1</span><span class="o">.</span><span class="n">s3</span>
<span class="n">stream_connect</span><span class="o">=</span><span class="n">hls_packet_receiver_1</span><span class="o">.</span><span class="n">out0</span><span class="p">:</span><span class="n">s2mm_1</span><span class="o">.</span><span class="n">s</span>
<span class="n">stream_connect</span><span class="o">=</span><span class="n">hls_packet_receiver_1</span><span class="o">.</span><span class="n">out1</span><span class="p">:</span><span class="n">s2mm_2</span><span class="o">.</span><span class="n">s</span>
<span class="n">stream_connect</span><span class="o">=</span><span class="n">hls_packet_receiver_1</span><span class="o">.</span><span class="n">out2</span><span class="p">:</span><span class="n">s2mm_3</span><span class="o">.</span><span class="n">s</span>
<span class="n">stream_connect</span><span class="o">=</span><span class="n">hls_packet_receiver_1</span><span class="o">.</span><span class="n">out3</span><span class="p">:</span><span class="n">s2mm_4</span><span class="o">.</span><span class="n">s</span>
</pre></div>
</div>
<p>Next review the HLS packet sender module in <code class="docutils literal notranslate"><span class="pre">pl_kernels/hls_packet_sender.cpp</span></code>. You can review the packet format in the previous section if necessary. The packet ID is generated by the function, <code class="docutils literal notranslate"><span class="pre">generateHeader</span></code>. Pay special attention to how it sends the packet header and reads data from the corresponding PL kernels:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#include &quot;hls_stream.h&quot;
#include &quot;ap_int.h&quot;
#include &quot;ap_axi_sdata.h&quot;
#include &quot;packet_ids_c.h&quot;

static const unsigned int pktType=0;
static const int PACKET_NUM=4; //How many kernels do packet switching
static const int PACKET_LEN=8; //Length for a packet

static const unsigned int packet_ids[PACKET_NUM]={Datain0_0, Datain0_1, Datain0_2, Datain0_3}; //macro values are generated in packet_ids_c.h

ap_uint&lt;32&gt; generateHeader(unsigned int pktType, unsigned int ID){
#pragma HLS inline
  ap_uint&lt;32&gt; header=0;
  header(4,0)=ID;
  header(11,5)=0;
  header(14,12)=pktType;
  header[15]=0;
  header(20,16)=-1;//source row
  header(27,21)=-1;//source column
  header(30,28)=0;
  header[31]=header(30,0).xor_reduce()?(ap_uint&lt;1&gt;)0:(ap_uint&lt;1&gt;)1;
  return header;
}

void hls_packet_sender(hls::stream&lt;ap_axiu&lt;32,0,0,0&gt;&gt; &amp;s0,hls::stream&lt;ap_axiu&lt;32,0,0,0&gt;&gt; &amp;s1,hls::stream&lt;ap_axiu&lt;32,0,0,0&gt;&gt; &amp;s2,hls::stream&lt;ap_axiu&lt;32,0,0,0&gt;&gt; &amp;s3,
  hls::stream&lt;ap_axiu&lt;32,0,0,0&gt;&gt; &amp;out, const unsigned int num){
  for(unsigned int iter=0;iter&lt;num;iter++){
    for(int i=0;i&lt;PACKET_NUM;i++){//Iterate on PL kernels that do packet switching
      unsigned int ID=packet_ids[i];
      ap_uint&lt;32&gt; header=generateHeader(pktType,ID); //packet header
      ap_axiu&lt;32,0,0,0&gt; tmp;
      tmp.data=header;
      tmp.keep=-1;
      tmp.last=0;
      out.write(tmp);
      for(int j=0;j&lt;PACKET_LEN;j++){ //packet data
        switch(i){//based on which kernel is sending packet, read the corresponding stream
        case 0:tmp=s0.read();break;
        case 1:tmp=s1.read();break;
        case 2:tmp=s2.read();break;
        case 3:tmp=s3.read();break;
        }
        if(j==PACKET_LEN-1){
          tmp.last=1; //last word in a packet has TLAST=1
        }else{
          tmp.last=0;
        }
        out.write(tmp);
      }
    }
  }
}
</pre></div>
</div>
<p>Now, review the HLS packet receiver module in <code class="docutils literal notranslate"><span class="pre">pl_kernels/hls_packet_receiver.cpp</span></code>. The packet ID is retrieved from the packet header by the function, <code class="docutils literal notranslate"><span class="pre">getPacketId</span></code>. Note how it sends the packet data to the corresponding PL kernels:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &quot;hls_stream.h&quot;</span>
<span class="c1">#include &quot;ap_int.h&quot;</span>
<span class="c1">#include &quot;ap_axi_sdata.h&quot;</span>
<span class="c1">#include &quot;packet_ids_c.h&quot;</span>

<span class="n">static</span> <span class="n">const</span> <span class="nb">int</span> <span class="n">PACKET_NUM</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>
<span class="n">static</span> <span class="n">const</span> <span class="nb">int</span> <span class="n">PACKET_LEN</span><span class="o">=</span><span class="mi">8</span><span class="p">;</span>

<span class="n">static</span> <span class="n">const</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">packet_ids</span><span class="p">[</span><span class="n">PACKET_NUM</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="n">Dataout0_0</span><span class="p">,</span> <span class="n">Dataout0_1</span><span class="p">,</span> <span class="n">Dataout0_2</span><span class="p">,</span> <span class="n">Dataout0_3</span><span class="p">};</span>

<span class="n">unsigned</span> <span class="nb">int</span> <span class="n">getPacketId</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">header</span><span class="p">){</span>
<span class="c1">#pragma HLS inline</span>
  <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">ID</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
  <span class="n">ID</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">=</span><span class="n">header</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">ID</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">hls_packet_receiver</span><span class="p">(</span><span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="ow">in</span><span class="p">,</span> <span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">out0</span><span class="p">,</span><span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">out1</span><span class="p">,</span><span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">out2</span><span class="p">,</span><span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">out3</span><span class="p">,</span>
  <span class="n">const</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">total_num_packet</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="nb">iter</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nb">iter</span><span class="o">&lt;</span><span class="n">total_num_packet</span><span class="p">;</span><span class="nb">iter</span><span class="o">++</span><span class="p">){</span>
      <span class="n">ap_axiu</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="o">=</span><span class="ow">in</span><span class="o">.</span><span class="n">read</span><span class="p">();</span><span class="o">//</span><span class="n">first</span> <span class="n">word</span> <span class="ow">is</span> <span class="n">packet</span> <span class="n">header</span>
      <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">ID</span><span class="o">=</span><span class="n">getPacketId</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
      <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">channel</span><span class="o">=</span><span class="n">packet_ids</span><span class="p">[</span><span class="n">ID</span><span class="p">];</span>
      <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">PACKET_LEN</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
        <span class="n">tmp</span><span class="o">=</span><span class="ow">in</span><span class="o">.</span><span class="n">read</span><span class="p">();</span>
        <span class="n">switch</span><span class="p">(</span><span class="n">channel</span><span class="p">){</span>
        <span class="k">case</span> <span class="mi">0</span><span class="p">:</span><span class="n">out0</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span><span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span><span class="n">out1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span><span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">2</span><span class="p">:</span><span class="n">out2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span><span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">3</span><span class="p">:</span><span class="n">out3</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span><span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that for both packet sender and packet receiver, the packet IDs are read from <code class="docutils literal notranslate"><span class="pre">packet_ids_c.h</span></code>, which is generated by the AI Engine compiler. Therefore, it requires that the AI Engine compilation is completed before the PL kernel compilation. Or, if packet IDs are changed when the AI Engine side has had any change, it requires the PL kernels to be re-compiled.</p>
</div>
<div class="section" id="example-ps-code-for-packet-switching">
<h2>Example PS code for Packet Switching<a class="headerlink" href="#example-ps-code-for-packet-switching" title="Permalink to this heading">¶</a></h2>
<p>The PS code for hardware emulation and hardware flows is in <code class="docutils literal notranslate"><span class="pre">sw/host.cpp</span></code>. You can review the code. It opens <code class="docutils literal notranslate"><span class="pre">xclbin</span></code> by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="o">//</span> <span class="n">Open</span> <span class="n">xclbin</span>
 <span class="n">auto</span> <span class="n">dhdl</span> <span class="o">=</span> <span class="n">xrtDeviceOpen</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="o">//</span><span class="n">device</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span>
 <span class="n">ret</span><span class="o">=</span><span class="n">xrtDeviceLoadXclbinFile</span><span class="p">(</span><span class="n">dhdl</span><span class="p">,</span><span class="n">xclbinFilename</span><span class="p">);</span>	
 <span class="n">xuid_t</span> <span class="n">uuid</span><span class="p">;</span>
 <span class="n">xrtDeviceGetXclbinUUID</span><span class="p">(</span><span class="n">dhdl</span><span class="p">,</span> <span class="n">uuid</span><span class="p">);</span>
</pre></div>
</div>
<p>Allocate buffers for <code class="docutils literal notranslate"><span class="pre">mm2s</span></code> kernels and <code class="docutils literal notranslate"><span class="pre">s2mm</span></code> kernels:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">output</span> <span class="n">memory</span>
<span class="n">xrtBufferHandle</span> <span class="n">out_bo1</span> <span class="o">=</span> <span class="n">xrtBOAlloc</span><span class="p">(</span><span class="n">dhdl</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">/*</span><span class="n">BANK</span><span class="o">=*/</span><span class="mi">0</span><span class="p">);</span>
<span class="o">...</span>
<span class="nb">int</span> <span class="o">*</span><span class="n">host_out1</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="o">*</span><span class="p">)</span><span class="n">xrtBOMap</span><span class="p">(</span><span class="n">out_bo1</span><span class="p">);</span>
<span class="o">...</span>
<span class="o">//</span> <span class="nb">input</span> <span class="n">memory</span>
<span class="n">xrtBufferHandle</span> <span class="n">in_bo1</span> <span class="o">=</span> <span class="n">xrtBOAlloc</span><span class="p">(</span><span class="n">dhdl</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">/*</span><span class="n">BANK</span><span class="o">=*/</span><span class="mi">0</span><span class="p">);</span>
<span class="o">...</span>
<span class="nb">int</span> <span class="o">*</span><span class="n">host_in1</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="o">*</span><span class="p">)</span><span class="n">xrtBOMap</span><span class="p">(</span><span class="n">in_bo1</span><span class="p">);</span>
<span class="o">...</span>
</pre></div>
</div>
<p>It initializes the input memory and then syncs the input memory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">initialize</span> <span class="nb">input</span> <span class="n">memory</span>
<span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">mem_size</span><span class="o">/</span><span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">);</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
  <span class="o">*</span><span class="p">(</span><span class="n">host_in1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">host_in2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">host_in3</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">host_in4</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">//</span> <span class="n">sync</span> <span class="nb">input</span> <span class="n">memory</span>
<span class="n">xrtBOSync</span><span class="p">(</span><span class="n">in_bo1</span><span class="p">,</span> <span class="n">XCL_BO_SYNC_BO_TO_DEVICE</span> <span class="p">,</span> <span class="n">mem_size</span><span class="p">,</span><span class="o">/*</span><span class="n">OFFSET</span><span class="o">=*/</span> <span class="mi">0</span><span class="p">);</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Then it starts the output kernels and the input kernels:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">start</span> <span class="n">output</span> <span class="n">kernels</span>
<span class="n">xrtKernelHandle</span> <span class="n">s2mm_k1</span> <span class="o">=</span> <span class="n">xrtPLKernelOpen</span><span class="p">(</span><span class="n">dhdl</span><span class="p">,</span> <span class="n">uuid</span><span class="p">,</span> <span class="s2">&quot;s2mm:</span><span class="si">{s2mm_1}</span><span class="s2">&quot;</span><span class="p">);</span>
<span class="n">xrtRunHandle</span> <span class="n">s2mm_r1</span> <span class="o">=</span> <span class="n">xrtRunOpen</span><span class="p">(</span><span class="n">s2mm_k1</span><span class="p">);</span>
<span class="n">xrtRunSetArg</span><span class="p">(</span><span class="n">s2mm_r1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out_bo1</span><span class="p">);</span>
<span class="n">xrtRunSetArg</span><span class="p">(</span><span class="n">s2mm_r1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mem_size</span><span class="o">/</span><span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">));</span>
<span class="n">xrtRunStart</span><span class="p">(</span><span class="n">s2mm_r1</span><span class="p">);</span>
<span class="o">...</span>
<span class="n">xrtKernelHandle</span> <span class="n">hls_packet_receiver_k</span> <span class="o">=</span> <span class="n">xrtPLKernelOpen</span><span class="p">(</span><span class="n">dhdl</span><span class="p">,</span> <span class="n">uuid</span><span class="p">,</span> <span class="s2">&quot;hls_packet_receiver&quot;</span><span class="p">);</span>
<span class="n">xrtRunHandle</span> <span class="n">hls_packet_receiver_r</span> <span class="o">=</span> <span class="n">xrtRunOpen</span><span class="p">(</span><span class="n">hls_packet_receiver_k</span><span class="p">);</span>
<span class="n">xrtRunSetArg</span><span class="p">(</span><span class="n">hls_packet_receiver_r</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">total_packet_num</span><span class="p">);</span>
<span class="n">xrtRunStart</span><span class="p">(</span><span class="n">hls_packet_receiver_r</span><span class="p">);</span>

<span class="o">//</span> <span class="n">start</span> <span class="nb">input</span> <span class="n">kernels</span>
<span class="n">xrtKernelHandle</span> <span class="n">mm2s_k1</span> <span class="o">=</span> <span class="n">xrtPLKernelOpen</span><span class="p">(</span><span class="n">dhdl</span><span class="p">,</span> <span class="n">uuid</span><span class="p">,</span> <span class="s2">&quot;mm2s:</span><span class="si">{mm2s_1}</span><span class="s2">&quot;</span><span class="p">);</span>
<span class="n">xrtRunHandle</span> <span class="n">mm2s_r1</span> <span class="o">=</span> <span class="n">xrtRunOpen</span><span class="p">(</span><span class="n">mm2s_k1</span><span class="p">);</span>
<span class="n">xrtRunSetArg</span><span class="p">(</span><span class="n">mm2s_r1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">in_bo1</span><span class="p">);</span>
<span class="n">xrtRunSetArg</span><span class="p">(</span><span class="n">mm2s_r1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mem_size</span><span class="o">/</span><span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">));</span>
<span class="n">xrtRunStart</span><span class="p">(</span><span class="n">mm2s_r1</span><span class="p">);</span>
<span class="o">...</span>
<span class="n">xrtKernelHandle</span> <span class="n">hls_packet_sender_k</span> <span class="o">=</span> <span class="n">xrtPLKernelOpen</span><span class="p">(</span><span class="n">dhdl</span><span class="p">,</span> <span class="n">uuid</span><span class="p">,</span> <span class="s2">&quot;hls_packet_sender&quot;</span><span class="p">);</span>
<span class="n">xrtRunHandle</span> <span class="n">hls_packet_sender_r</span> <span class="o">=</span> <span class="n">xrtRunOpen</span><span class="p">(</span><span class="n">hls_packet_sender_k</span><span class="p">);</span>
<span class="n">xrtRunSetArg</span><span class="p">(</span><span class="n">hls_packet_sender_r</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">packet_num</span><span class="p">);</span>
<span class="n">xrtRunStart</span><span class="p">(</span><span class="n">hls_packet_sender_r</span><span class="p">);</span>
</pre></div>
</div>
<p>And then starts the graph:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">start</span> <span class="n">graph</span>
<span class="n">adf</span><span class="p">::</span><span class="n">registerXRT</span><span class="p">(</span><span class="n">dhdl</span><span class="p">,</span> <span class="n">uuid</span><span class="p">);</span>
<span class="n">gr</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="o">//</span><span class="n">Iteration</span> <span class="n">number</span><span class="o">=</span><span class="mf">2.</span> <span class="n">The</span> <span class="n">amount</span> <span class="n">of</span> <span class="n">data</span> <span class="n">matches</span> <span class="k">for</span> <span class="n">PL</span> <span class="n">kernels</span> <span class="ow">and</span> <span class="n">graph</span>
</pre></div>
</div>
<p>Then waits for <code class="docutils literal notranslate"><span class="pre">s2mm</span></code> kernels to complete, and syncs output memory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">wait</span> <span class="k">for</span> <span class="n">s2mm</span> <span class="n">to</span> <span class="n">complete</span>
<span class="n">xrtRunWait</span><span class="p">(</span><span class="n">s2mm_r1</span><span class="p">);</span>
<span class="o">...</span>
<span class="o">//</span> <span class="n">sync</span> <span class="n">output</span> <span class="n">memory</span>
<span class="n">xrtBOSync</span><span class="p">(</span><span class="n">out_bo1</span><span class="p">,</span> <span class="n">XCL_BO_SYNC_BO_FROM_DEVICE</span> <span class="p">,</span> <span class="n">mem_size</span><span class="p">,</span><span class="o">/*</span><span class="n">OFFSET</span><span class="o">=*/</span> <span class="mi">0</span><span class="p">);</span>   
<span class="o">...</span>
</pre></div>
</div>
<p>Then, finally, it performs post-processing and releases objects.</p>
<p>Note that there is no special packet switching handling in the PS code. It is already done on the AI Engine and PL side.</p>
</div>
<div class="section" id="run-hardware-emulation-and-hardware-flows">
<h2>Run Hardware Emulation and Hardware flows<a class="headerlink" href="#run-hardware-emulation-and-hardware-flows" title="Permalink to this heading">¶</a></h2>
<p>Run HW emulation with the following make command (it will build the HW system and host application):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">run_hw_emu</span>
</pre></div>
</div>
<p>Hint: If the keyboard is accidentally hit and stops the system booting automatically, type boot at the <strong>Versal&gt;</strong> prompt to resume the system booting.</p>
<p>After Linux has booted, run the following commands at the Linux prompt (this is only for HW cosim):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mount</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">mmcblk0p1</span> <span class="o">/</span><span class="n">mnt</span>
<span class="n">cd</span> <span class="o">/</span><span class="n">mnt</span>
<span class="n">export</span> <span class="n">XILINX_XRT</span><span class="o">=/</span><span class="n">usr</span>
<span class="n">export</span> <span class="n">XCL_EMULATION_MODE</span><span class="o">=</span><span class="n">hw_emu</span>
<span class="o">./</span><span class="n">host</span><span class="o">.</span><span class="n">exe</span> <span class="n">a</span><span class="o">.</span><span class="n">xclbin</span>
</pre></div>
</div>
<p>To exit QEMU press Ctrl+A, x</p>
<p>To run in hardware, first build the system and application using the following make command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">package</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span>
</pre></div>
</div>
<p>After Linux has booted, run the following commands at the Linux prompt:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export</span> <span class="n">XILINX_XRT</span><span class="o">=/</span><span class="n">usr</span>
<span class="n">cd</span> <span class="o">/</span><span class="n">mnt</span><span class="o">/</span><span class="n">sd</span><span class="o">-</span><span class="n">mmcblk0p1</span>
<span class="o">./</span><span class="n">host</span><span class="o">.</span><span class="n">exe</span> <span class="n">a</span><span class="o">.</span><span class="n">xclbin</span>
</pre></div>
</div>
<p>The host code is self-checking; it checks the correctness of the output data. If the output data is correct, after the run has completed, it will print:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span> <span class="n">PASSED</span>
</pre></div>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this heading">¶</a></h2>
<p>In this step, you learned about the following concepts:</p>
<ul class="simple">
<li><p>Construct packet switching graph</p></li>
<li><p>Packet format and prepare data for AI Engine simulator</p></li>
<li><p>Design PL kernels for packet switching</p></li>
<li><p>PS application and run HW/HW emulation flows</p></li>
</ul>
<p>Next, review <a class="reference internal" href="window_based_mix_data_type.html"><span class="doc">Window Based AI Engine Kernels with Mixed Data Types</span></a></p>
<p>© Copyright 2020 Xilinx, Inc.</p>
<p>Licensed under the Apache License, Version 2.0 (the “License”);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">licenses</span><span class="o">/</span><span class="n">LICENSE</span><span class="o">-</span><span class="mf">2.0</span>
</pre></div>
</div>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an “AS IS” BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
<p align="center"><sup>XD029</sup></p></div>
</div>


           </div>
          </div>
          
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
				  
				  <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, Xilinx, Inc. Xilinx is now a part of AMD.
      <span class="lastupdated">Last updated on August 5, 2022.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>