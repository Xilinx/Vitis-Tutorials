<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
  <title>PL GMIO Programming Model &mdash; Vitis™ Tutorials 2020.2 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../../../../index.html" class="icon icon-home"> Vitis™ Tutorials
            <img src="../../../../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2020.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">日本語版</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/master/docs-jp/README.html">Master</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting Started Pathway</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Getting_Started/Vitis/README.html">Vitis Flow 101 Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Getting_Started/Vitis_HLS/README.html">Vitis HLS Analysis and Optimization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Hardware Accelerators</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Introduction/README.html">Introduction to Vitis Hardware Accelerators Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Design_Tutorials/02-bloom/README.html">Optimizing Accelerated FPGA Applications: Bloom Filter Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Design_Tutorials/01-convolution-tutorial/README.html">Accelerating Video Convolution Filtering Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Design_Tutorials/03-rtl_stream_kernel_integration/README.html">Mixed Kernels Design Tutorial with AXI Stream and Vitis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Design_Tutorials/04-traveling-salesperson/README.html">The Travelling Salesman Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Design_Tutorials/05-bottom_up_rtl_kernel/README.html">Bottom-up RTL Kernel Flow with Vitis for Acceleration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Feature_Tutorials/01-rtl_kernel_workflow/README.html">Getting Started with RTL Kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Feature_Tutorials/02-mixing-c-rtl-kernels/README.html">Mixing C++ and RTL Kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Feature_Tutorials/03-dataflow_debug_and_optimization/README.html">Vitis HLS Analysis and Optimization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Runtime and System Optimization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Design_Tutorials/01-host-code-opt/README.html">Host Code Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Design_Tutorials/02-ivas-ml/README.html">IVAS ZCU104 ML Acceleration Reference Release</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Feature_Tutorials/01-mult-ddr-banks/README.html">Using Multiple DDR Banks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Feature_Tutorials/02-using-multiple-cu/README.html">Using Multiple Compute Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Feature_Tutorials/03-controlling-vivado-implementation/README.html">Controlling Vivado Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Feature_Tutorials/04-using-hbm/README.html">Using HBM</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Vitis Platform Creation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Vitis_Platform_Creation/Introduction/01-Overview/README.html">Platform Creation Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Vitis_Platform_Creation/Introduction/02-Edge-AI-ZCU104/README.html">Vitis Custom Embedded Platform Creation Example on ZCU104</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Vitis_Platform_Creation/Introduction/03_Edge_VCK190/README.html">Versal Custom Platform Creation Tutorial</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/">Main</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Vitis™ Tutorials</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>PL GMIO Programming Model</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/docs/AI_Engine_Development/Feature_Tutorials/02-using-gmio/single_pl_gmio.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <table>
 <tr>
   <td align="center"><img src="https://raw.githubusercontent.com/Xilinx/Image-Collateral/main/xilinx-logo.png" width="30%"/><h1>AI Engine GMIO Tutorial</h1>
   </td>
 </tr>
 <tr>
 </td>
 </tr>
</table><div class="section" id="pl-gmio-programming-model">
<h1>PL GMIO Programming Model<a class="headerlink" href="#pl-gmio-programming-model" title="Permalink to this heading">¶</a></h1>
<p>It is possible to make PL-to-DDR memory or DDR memory to PL connections witihin an AI Engine graph. To support this, PL kernels with an AXI4-Stream interface and an AXI4 Master interface are required inside the graph. In this example, two PL kernels (<code class="docutils literal notranslate"><span class="pre">mm2s</span></code> and <code class="docutils literal notranslate"><span class="pre">s2mm</span></code>) are used to connect to one AI Engine kernel in the graph. The AXI4-Stream interfaces of <code class="docutils literal notranslate"><span class="pre">mm2s</span></code> and <code class="docutils literal notranslate"><span class="pre">s2mm</span></code> are connected to the AI Engine window or stream data interfaces, and the AXI4 Master interfaces of <code class="docutils literal notranslate"><span class="pre">mm2s</span></code> and <code class="docutils literal notranslate"><span class="pre">s2mm</span></code> are connected to the GMIO ports of the graph.</p>
<p><a class="reference external" href="#Step-1---PL-Kernels-with-Fixed-Size-of-Data">Step 1 - PL Kernels with Fixed Size of Data</a> and <a class="reference external" href="#Step-2---PL-Kernels-with-Variable-Size-of-Data">Step 2 - PL Kernels with Variable Size of Data</a>, introduce the PL kernels along with the Adaptive Data Flow (ADF) APIs that take care of buffer object (BO) allocations and data transfers. The graph for the example is as shown in the following figure:</p>
<p><img alt="Graph" src="../../../../_images/picture4.PNG" /></p>
<div class="section" id="step-1-pl-kernels-with-fixed-size-of-data">
<h2>Step 1 - PL Kernels with Fixed Size of Data<a class="headerlink" href="#step-1-pl-kernels-with-fixed-size-of-data" title="Permalink to this heading">¶</a></h2>
<p>This step introduces the PL GMIO specification, PL kernels with fixed size of data in the graph, and its programming model. Change the directory to <code class="docutils literal notranslate"><span class="pre">single_pl_gmio/step1</span></code>. Look at the graph specification in <code class="docutils literal notranslate"><span class="pre">aie/graph_pl.h</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">mygraph_pl</span><span class="p">:</span> <span class="n">public</span> <span class="n">adf</span><span class="p">::</span><span class="n">graph</span>
<span class="p">{</span>
  <span class="n">private</span><span class="p">:</span>
  <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span> <span class="n">k</span><span class="p">;</span>
  <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span> <span class="n">k_mm2s</span><span class="p">;</span>
  <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span> <span class="n">k_s2mm</span><span class="p">;</span>

  <span class="n">public</span><span class="p">:</span>
  <span class="n">adf</span><span class="p">::</span><span class="n">port</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">direction</span><span class="p">::</span><span class="n">inout</span><span class="o">&gt;</span> <span class="n">inoutMem</span><span class="p">;</span>
  <span class="n">adf</span><span class="p">::</span><span class="n">port</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">direction</span><span class="p">::</span><span class="ow">in</span><span class="o">&gt;</span> <span class="n">inMem</span><span class="p">;</span>

  <span class="n">mygraph_pl</span><span class="p">()</span>
  <span class="p">{</span>
	      <span class="n">k</span> <span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">vec_incr</span><span class="p">);</span>
	      <span class="n">adf</span><span class="p">::</span><span class="n">source</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="s2">&quot;vec_incr.cc&quot;</span><span class="p">;</span>
	      <span class="n">adf</span><span class="p">::</span><span class="n">runtime</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">ratio</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	      <span class="n">k_mm2s</span><span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">mm2s</span><span class="p">);</span>
	      <span class="n">adf</span><span class="p">::</span><span class="n">source</span><span class="p">(</span><span class="n">k_mm2s</span><span class="p">)</span> <span class="o">=</span> <span class="s2">&quot;hls/mm2s.cpp&quot;</span><span class="p">;</span>
	      <span class="n">adf</span><span class="p">::</span><span class="n">fabric</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">pl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k_mm2s</span><span class="p">);</span>
	      <span class="n">k_s2mm</span> <span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">s2mm</span><span class="p">);</span>
	      <span class="n">adf</span><span class="p">::</span><span class="n">source</span><span class="p">(</span><span class="n">k_s2mm</span><span class="p">)</span> <span class="o">=</span> <span class="s2">&quot;hls/s2mm.cpp&quot;</span><span class="p">;</span>
	      <span class="n">adf</span><span class="p">::</span><span class="n">fabric</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">pl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k_s2mm</span><span class="p">);</span>
	
	      <span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">gmem</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inMem</span><span class="p">,</span><span class="n">k_mm2s</span><span class="o">.</span><span class="ow">in</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	      <span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">stream</span><span class="p">,</span><span class="n">adf</span><span class="p">::</span><span class="n">window</span><span class="o">&lt;</span><span class="mi">1024</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">k_mm2s</span><span class="o">.</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">k</span><span class="o">.</span><span class="ow">in</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	      <span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">window</span><span class="o">&lt;</span><span class="mi">1024</span><span class="o">&gt;</span><span class="p">,</span><span class="n">adf</span><span class="p">::</span><span class="n">stream</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">k_s2mm</span><span class="o">.</span><span class="ow">in</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	      <span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">gmem</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k_s2mm</span><span class="o">.</span><span class="n">inout</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">inoutMem</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Two PL kernels are inside the graph, <code class="docutils literal notranslate"><span class="pre">mm2s</span></code> and <code class="docutils literal notranslate"><span class="pre">s2mm</span></code>. They are connected to the AI Engine kernel with the streaming interface. They are connected to the input and inout ports with type <code class="docutils literal notranslate"><span class="pre">adf::gmem</span></code>, and the input and inout ports of the graph are GMIO. It tells the AI Engine tools to automatically use a NoC Master Unit (NMU) for Direct Memory Access (DMA) transactions.</p>
<p>Run the following make command to compile the graph (libadf.a):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">aie</span>
</pre></div>
</div>
<p><strong>Note:</strong> The <code class="docutils literal notranslate"><span class="pre">mm2s</span></code> and <code class="docutils literal notranslate"><span class="pre">s2mm</span></code> have an AXI4-Lite interface for control. To support PL kernel with AXI4-Lite interfaces inside the graph, the option <code class="docutils literal notranslate"><span class="pre">--pl-axi-lite=true</span></code> is required for the AI Engine compiler.</p>
<p>Then open the compile result with Vitis™ Analyzer:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vitis_analyzer</span> <span class="o">./</span><span class="n">Work</span><span class="o">/</span><span class="n">graph</span><span class="o">.</span><span class="n">aiecompile_summary</span>
</pre></div>
</div>
<p>In the Vitis Analyzer, click the <code class="docutils literal notranslate"><span class="pre">graph</span></code> tab, and the graph is displayed as follows:</p>
<p><img alt="Graph" src="../../../../_images/picture4.PNG" /></p>
<p>It can be seen that the PL kernels <code class="docutils literal notranslate"><span class="pre">mm2s</span></code> and <code class="docutils literal notranslate"><span class="pre">s2mm</span></code> are between GMIOs and the AI Engine kernel, and there is a PLIO between each PL kernel and AI Engine kernel.</p>
<p>The reference code for HLS modules <code class="docutils literal notranslate"><span class="pre">mm2s</span></code> (<code class="docutils literal notranslate"><span class="pre">aie/hls/mm2s.cpp</span></code>) and <code class="docutils literal notranslate"><span class="pre">s2mm</span></code> (<code class="docutils literal notranslate"><span class="pre">aie/hls/s2mm.cpp</span></code>) is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">mm2s</span><span class="p">(</span><span class="n">const</span> <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;*</span> <span class="n">mem</span><span class="p">,</span> <span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axis</span><span class="o">&lt;</span><span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span>  <span class="o">&gt;&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">#pragma HLS INTERFACE m_axi port=mem offset=slave bundle=gmem</span>
<span class="c1">#pragma HLS interface axis port=s</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=mem bundle=control</span>
<span class="c1">#pragma HLS interface s_axilite port=return bundle=control</span>

  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="o">//</span><span class="mi">2048</span> <span class="n">Bytes</span> <span class="n">per</span> <span class="n">run</span>
  <span class="c1">#pragma HLS PIPELINE II=1 enable_flush</span>
    <span class="n">ap_axis</span><span class="o">&lt;</span><span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="n">mem</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">x</span><span class="o">.</span><span class="n">keep</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">x</span><span class="o">.</span><span class="n">last</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">s</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">s2mm</span><span class="p">(</span><span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;*</span> <span class="n">mem</span><span class="p">,</span> <span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axis</span><span class="o">&lt;</span><span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span>  <span class="o">&gt;&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">#pragma HLS INTERFACE m_axi port=mem offset=slave bundle=gmem</span>
<span class="c1">#pragma HLS interface axis port=s</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=mem bundle=control</span>
<span class="c1">#pragma HLS interface s_axilite port=return bundle=control</span>

  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="o">//</span><span class="mi">2048</span> <span class="n">Bytes</span> <span class="n">per</span> <span class="n">run</span>
  <span class="c1">#pragma HLS PIPELINE II=1 enable_flush</span>
    <span class="n">ap_axis</span><span class="o">&lt;</span><span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">read</span><span class="p">();</span>
    <span class="n">mem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Note:</strong> The size of data transferred per invocation for <code class="docutils literal notranslate"><span class="pre">mm2s</span></code> and <code class="docutils literal notranslate"><span class="pre">s2mm</span></code> is 2048 bytes. It must match the data needed or produced by AI Engine per <code class="docutils literal notranslate"><span class="pre">graph::run</span></code> API call. In the graph, we can see the window size for AI Engine kernel is 1024 bytes. This means that each of the two iterations of AI Engine kernel matches one invocation of PL kernel.</p>
<p>Look at the main function in <code class="docutils literal notranslate"><span class="pre">aie/graph.cpp</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">GMIO</span> <span class="n">gmioInPL</span><span class="p">(</span><span class="s2">&quot;gmioInPL_0&quot;</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
<span class="n">GMIO</span> <span class="n">gmioOutPL</span><span class="p">(</span><span class="s2">&quot;gmioOutPL_0&quot;</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
<span class="n">adf</span><span class="p">::</span><span class="n">simulation</span><span class="p">::</span><span class="n">platform</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">platform</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gmioInPL</span><span class="p">,</span><span class="o">&amp;</span><span class="n">gmioOutPL</span><span class="p">);</span>	
<span class="n">mygraph_pl</span> <span class="n">gr_pl</span><span class="p">;</span>
<span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;&gt;</span> <span class="n">c0</span><span class="p">(</span><span class="n">platform</span><span class="o">.</span><span class="n">src</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gr_pl</span><span class="o">.</span><span class="n">inMem</span><span class="p">);</span>
<span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;&gt;</span> <span class="n">c1</span><span class="p">(</span><span class="n">gr_pl</span><span class="o">.</span><span class="n">inoutMem</span><span class="p">,</span><span class="n">platform</span><span class="o">.</span><span class="n">sink</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="n">const</span> <span class="nb">int</span> <span class="n">ITERATION</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
<span class="n">const</span> <span class="nb">int</span> <span class="n">BLOCK_SIZE_in_Bytes</span><span class="o">=</span><span class="mi">2048</span><span class="p">;</span>
<span class="n">const</span> <span class="nb">int</span> <span class="n">TOTAL_REPEAT</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">gr_pl</span><span class="o">.</span><span class="n">init</span><span class="p">();</span>
	<span class="nb">int</span> <span class="n">error</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">adf</span><span class="p">::</span><span class="n">return_code</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">int32</span><span class="o">*</span> <span class="n">inMem</span><span class="p">;</span>
	<span class="n">int32</span><span class="o">*</span> <span class="n">outMem</span><span class="p">;</span>
	<span class="n">inMem</span><span class="o">=</span><span class="p">(</span><span class="n">int32</span><span class="o">*</span><span class="p">)</span><span class="n">GMIO</span><span class="p">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">BLOCK_SIZE_in_Bytes</span><span class="p">);</span>
	<span class="n">outMem</span><span class="o">=</span><span class="p">(</span><span class="n">int32</span><span class="o">*</span><span class="p">)</span><span class="n">GMIO</span><span class="p">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">BLOCK_SIZE_in_Bytes</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="nb">iter</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nb">iter</span><span class="o">&lt;</span><span class="n">TOTAL_REPEAT</span><span class="p">;</span><span class="nb">iter</span><span class="o">++</span><span class="p">){</span>
		<span class="o">//</span><span class="n">pre</span><span class="o">-</span><span class="n">processing</span>
		<span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">BLOCK_SIZE_in_Bytes</span><span class="o">/</span><span class="n">sizeof</span><span class="p">(</span><span class="n">int32</span><span class="p">);</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
			<span class="n">inMem</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="nb">iter</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span><span class="o">=</span><span class="n">gmioInPL</span><span class="o">.</span><span class="n">pl_gm</span><span class="p">(</span><span class="n">inMem</span><span class="p">,</span> <span class="n">BLOCK_SIZE_in_Bytes</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ret</span><span class="o">!=</span><span class="n">adf</span><span class="p">::</span><span class="n">ok</span><span class="p">){</span>
			<span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s2">&quot;GMIO pl_gm error&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span><span class="o">=</span><span class="n">gmioOutPL</span><span class="o">.</span><span class="n">pl_gm</span><span class="p">(</span><span class="n">outMem</span><span class="p">,</span> <span class="n">BLOCK_SIZE_in_Bytes</span><span class="p">);</span>
		<span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s2">&quot;GMIO::pl_gm enqueing completed&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
		<span class="n">ret</span><span class="o">=</span><span class="n">gr_pl</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">ITERATION</span><span class="p">);</span>
		<span class="n">ret</span><span class="o">=</span><span class="n">gr_pl</span><span class="o">.</span><span class="n">wait</span><span class="p">();</span>
		<span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s2">&quot;Graph PL run end&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
		<span class="o">//</span><span class="n">post</span><span class="o">-</span><span class="n">processing</span>
		<span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">BLOCK_SIZE_in_Bytes</span><span class="o">/</span><span class="n">sizeof</span><span class="p">(</span><span class="n">int32</span><span class="p">);</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">outMem</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="n">j</span><span class="o">+</span><span class="nb">iter</span><span class="o">+</span><span class="mi">1</span><span class="p">){</span>
				<span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s2">&quot;ERROR:dout[&quot;</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="o">&lt;&lt;</span><span class="s2">&quot;]=&quot;</span><span class="o">&lt;&lt;</span><span class="n">outMem</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
				<span class="n">error</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">GMIO</span><span class="p">::</span><span class="n">free</span><span class="p">(</span><span class="n">inMem</span><span class="p">);</span>
	<span class="n">GMIO</span><span class="p">::</span><span class="n">free</span><span class="p">(</span><span class="n">outMem</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This example declares two GMIO objects, <code class="docutils literal notranslate"><span class="pre">gmioInPL</span></code> and <code class="docutils literal notranslate"><span class="pre">gmioOutPL</span></code>. The constructor specifies the logical name of the GMIO, the burst length of the memory-mapped AXI4 transaction, and the required bandwidth (in MB/s).</p>
<p><strong>Note:</strong> The burst length is not used for PL GMIO. The number specified here is just for syntax compliance for the GMIO constructor.</p>
<p><code class="docutils literal notranslate"><span class="pre">inMem</span></code> and <code class="docutils literal notranslate"><span class="pre">outMem</span></code> must be allocated using <code class="docutils literal notranslate"><span class="pre">GMIO::malloc</span></code>. In each iteration of the main for loop, the data is pre-processed. Then <code class="docutils literal notranslate"><span class="pre">GMIO::pl_gm</span></code> is used to specify the input buffer and output buffer for the PL GMIO data transfers. <code class="docutils literal notranslate"><span class="pre">graph::run</span></code> is called after <code class="docutils literal notranslate"><span class="pre">GMIO::pl_gm</span></code> to start the PL GMIO data transfers. Note that <code class="docutils literal notranslate"><span class="pre">ITERATION</span></code> is 2 in <code class="docutils literal notranslate"><span class="pre">gr_pl.run(ITERATION)</span></code>.</p>
<p>One important difference between the PL GMIO and the AI Engine GMIO is that <code class="docutils literal notranslate"><span class="pre">graph::run()</span></code> must be called after <code class="docutils literal notranslate"><span class="pre">GMIO::pl_gm</span></code> for the PL GMIO. However, for the AI Engine GMIO, <code class="docutils literal notranslate"><span class="pre">graph::run()</span></code> can be called before or after GMIO operations (<code class="docutils literal notranslate"><span class="pre">GMIO::gm2aie</span></code>, <code class="docutils literal notranslate"><span class="pre">GMIO::aie2gm</span></code>, <code class="docutils literal notranslate"><span class="pre">GMIO::gm2aie_nb</span></code>, and <code class="docutils literal notranslate"><span class="pre">GMIO::aie2gm_nb</span></code>). After <code class="docutils literal notranslate"><span class="pre">graph::run()</span></code>, <code class="docutils literal notranslate"><span class="pre">graph::wait()</span></code> can be called to wait for the graph to complete.  Thus, the GMIO output to DDR memory has also been synchronized. Then post-processing of DDR memory data can be done. After all the iterations are complete, <code class="docutils literal notranslate"><span class="pre">GMIO::free</span></code> must be called to free the allocated memory.</p>
<p><strong>Note:</strong> Unlike AI Engine GMIO, there is no <code class="docutils literal notranslate"><span class="pre">GMIO::wait</span></code> for PL GMIO.</p>
<div class="section" id="run-in-hardware">
<h3>Run in Hardware<a class="headerlink" href="#run-in-hardware" title="Permalink to this heading">¶</a></h3>
<p>To make GMIO work in hardware flow, the following code can be added to main function before graph execution and GMIO data transfer:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#if !defined(__AIESIM__) &amp;&amp; !defined(__ADF_FRONTEND__)</span>
	<span class="c1">#include &quot;adf/adf_api/XRTConfig.h&quot;</span>
	<span class="c1">#include &quot;experimental/xrt_kernel.h&quot;</span>
	<span class="o">//</span> <span class="n">Create</span> <span class="n">XRT</span> <span class="n">device</span> <span class="n">handle</span> <span class="k">for</span> <span class="n">ADF</span> <span class="n">API</span>
	<span class="n">char</span><span class="o">*</span> <span class="n">xclbinFilename</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">auto</span> <span class="n">dhdl</span> <span class="o">=</span> <span class="n">xrtDeviceOpen</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="o">//</span><span class="n">device</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span>
	<span class="n">xrtDeviceLoadXclbinFile</span><span class="p">(</span><span class="n">dhdl</span><span class="p">,</span><span class="n">xclbinFilename</span><span class="p">);</span>
	<span class="n">xuid_t</span> <span class="n">uuid</span><span class="p">;</span>
	<span class="n">xrtDeviceGetXclbinUUID</span><span class="p">(</span><span class="n">dhdl</span><span class="p">,</span> <span class="n">uuid</span><span class="p">);</span>
	<span class="n">adf</span><span class="p">::</span><span class="n">registerXRT</span><span class="p">(</span><span class="n">dhdl</span><span class="p">,</span> <span class="n">uuid</span><span class="p">);</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p>Using the guard macro <code class="docutils literal notranslate"><span class="pre">__AIESIM__</span></code> (defined when launching AI Engine simulator) and <code class="docutils literal notranslate"><span class="pre">__ADF_FRONTEND__</span></code> (defined when launching x86simulator), the same version of host code can work for the AI Engine simulator and hardware flow.</p>
<p>At the end of the program, close the device using the XRT API <code class="docutils literal notranslate"><span class="pre">xrtDeviceClose()</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#if !defined(__AIESIM__) &amp;&amp; !defined(__ADF_FRONTEND__)</span>
	<span class="n">xrtDeviceClose</span><span class="p">(</span><span class="n">dhdl</span><span class="p">);</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p>Run the following make command to build image for hardware:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">package</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span>
</pre></div>
</div>
<p>After the package is done, run the following commands in the Linux prompt after booting Linux from an SD card:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export</span> <span class="n">XILINX_XRT</span><span class="o">=/</span><span class="n">usr</span>
<span class="n">chmod</span> <span class="mi">755</span> <span class="n">host</span><span class="o">.</span><span class="n">exe</span>
<span class="o">./</span><span class="n">host</span><span class="o">.</span><span class="n">exe</span> <span class="n">a</span><span class="o">.</span><span class="n">xclbin</span>
</pre></div>
</div>
<p>The host code is self-checking. It will check the output data against the golden data. If the output data matches the golden data after the run is complete, it will print the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>PASS!
</pre></div>
</div>
</div>
</div>
<div class="section" id="step-2-pl-kernels-with-variable-size-of-data">
<h2>Step 2 - PL Kernels with Variable Size of Data<a class="headerlink" href="#step-2-pl-kernels-with-variable-size-of-data" title="Permalink to this heading">¶</a></h2>
<p>In the previous step, the <code class="docutils literal notranslate"><span class="pre">mm2s</span></code> and <code class="docutils literal notranslate"><span class="pre">s2mm</span></code> PL kernels were transfering a fixed number of data. A Runtime parameter (RTP) in the graph can be used to transfer scalar value <code class="docutils literal notranslate"><span class="pre">size</span></code> to PL kernel, making it send or receive a variable number from memory.</p>
<p>Change the working directory to <code class="docutils literal notranslate"><span class="pre">single_pl_gmio/step2</span></code>. An example of <code class="docutils literal notranslate"><span class="pre">mm2s</span></code> (<code class="docutils literal notranslate"><span class="pre">aie/hls/mm2s.cpp</span></code>) and <code class="docutils literal notranslate"><span class="pre">s2mm</span></code> (<code class="docutils literal notranslate"><span class="pre">aie/hls/s2mm.cpp</span></code>) PL kernels are as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">mm2s</span><span class="p">(</span><span class="n">const</span> <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;*</span> <span class="n">mem</span><span class="p">,</span> <span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axis</span><span class="o">&lt;</span><span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span>  <span class="o">&gt;&amp;</span> <span class="n">s</span><span class="p">,</span><span class="n">const</span> <span class="nb">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">#pragma HLS INTERFACE m_axi port=mem offset=slave bundle=gmem</span>
<span class="c1">#pragma HLS interface axis port=s</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=mem bundle=control</span>
<span class="c1">#pragma HLS interface s_axilite port=return bundle=control</span>
	<span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">#pragma HLS PIPELINE II=1 enable_flush</span>
		<span class="n">ap_axis</span><span class="o">&lt;</span><span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="n">mem</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">x</span><span class="o">.</span><span class="n">keep</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">x</span><span class="o">.</span><span class="n">last</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">s</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">s2mm</span><span class="p">(</span><span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;*</span> <span class="n">mem</span><span class="p">,</span> <span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axis</span><span class="o">&lt;</span><span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span>  <span class="o">&gt;&amp;</span> <span class="n">s</span><span class="p">,</span><span class="n">const</span> <span class="nb">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">#pragma HLS INTERFACE m_axi port=mem offset=slave bundle=gmem</span>
<span class="c1">#pragma HLS interface axis port=s</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=mem bundle=control</span>
<span class="c1">#pragma HLS interface s_axilite port=return bundle=control</span>
	<span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">#pragma HLS PIPELINE II=1 enable_flush</span>
		<span class="n">ap_axis</span><span class="o">&lt;</span><span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">read</span><span class="p">();</span>
		<span class="n">mem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the graph definition (<code class="docutils literal notranslate"><span class="pre">aie/graph_pl.h</span></code>), two additional <code class="docutils literal notranslate"><span class="pre">adf::async</span></code> declarations are added for the RTP port of <code class="docutils literal notranslate"><span class="pre">mm2s</span></code> and <code class="docutils literal notranslate"><span class="pre">s2mm</span></code>. <code class="docutils literal notranslate"><span class="pre">k_mm2s.in[1]</span></code> is the second input of <code class="docutils literal notranslate"><span class="pre">mm2s</span></code>, which is <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">size</span></code>. Besides, the kernel declaration <code class="docutils literal notranslate"><span class="pre">adf::kernel</span></code> for <code class="docutils literal notranslate"><span class="pre">mm2s</span></code> and <code class="docutils literal notranslate"><span class="pre">s2mm</span></code> are moved from private member to public member of the class. This is because access to the RTP port of kernel in the host program is required.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">mygraph_pl</span><span class="p">:</span> <span class="n">public</span> <span class="n">adf</span><span class="p">::</span><span class="n">graph</span>
<span class="p">{</span>
<span class="n">private</span><span class="p">:</span>
  <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span> <span class="n">k</span><span class="p">;</span>
<span class="n">public</span><span class="p">:</span>
  <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span> <span class="n">k_mm2s</span><span class="p">;</span>
  <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span> <span class="n">k_s2mm</span><span class="p">;</span>
  <span class="n">adf</span><span class="p">::</span><span class="n">port</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">direction</span><span class="p">::</span><span class="n">inout</span><span class="o">&gt;</span> <span class="n">inoutMem</span><span class="p">;</span>
  <span class="n">adf</span><span class="p">::</span><span class="n">port</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">direction</span><span class="p">::</span><span class="ow">in</span><span class="o">&gt;</span> <span class="n">inMem</span><span class="p">;</span>

  <span class="n">mygraph_pl</span><span class="p">()</span>
  <span class="p">{</span>
		<span class="n">k</span> <span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">vec_incr</span><span class="p">);</span>
		<span class="n">adf</span><span class="p">::</span><span class="n">source</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="s2">&quot;vec_incr.cc&quot;</span><span class="p">;</span>
		<span class="n">adf</span><span class="p">::</span><span class="n">runtime</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">ratio</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">k_mm2s</span><span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">mm2s</span><span class="p">);</span>
		<span class="n">adf</span><span class="p">::</span><span class="n">source</span><span class="p">(</span><span class="n">k_mm2s</span><span class="p">)</span> <span class="o">=</span> <span class="s2">&quot;hls/mm2s.cpp&quot;</span><span class="p">;</span>
		<span class="n">adf</span><span class="p">::</span><span class="n">fabric</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">pl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k_mm2s</span><span class="p">);</span>
		<span class="n">k_s2mm</span> <span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">s2mm</span><span class="p">);</span>
		<span class="n">adf</span><span class="p">::</span><span class="n">source</span><span class="p">(</span><span class="n">k_s2mm</span><span class="p">)</span> <span class="o">=</span> <span class="s2">&quot;hls/s2mm.cpp&quot;</span><span class="p">;</span>
		<span class="n">adf</span><span class="p">::</span><span class="n">fabric</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">pl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k_s2mm</span><span class="p">);</span>
		
		<span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">gmem</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inMem</span><span class="p">,</span><span class="n">k_mm2s</span><span class="o">.</span><span class="ow">in</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">stream</span><span class="p">,</span><span class="n">adf</span><span class="p">::</span><span class="n">window</span><span class="o">&lt;</span><span class="mi">1024</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">k_mm2s</span><span class="o">.</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">k</span><span class="o">.</span><span class="ow">in</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">window</span><span class="o">&lt;</span><span class="mi">1024</span><span class="o">&gt;</span><span class="p">,</span><span class="n">adf</span><span class="p">::</span><span class="n">stream</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">k_s2mm</span><span class="o">.</span><span class="ow">in</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">gmem</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k_s2mm</span><span class="o">.</span><span class="n">inout</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">inoutMem</span><span class="p">);</span>

		<span class="n">adf</span><span class="p">::</span><span class="k">async</span><span class="p">(</span><span class="n">k_mm2s</span><span class="o">.</span><span class="ow">in</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">adf</span><span class="p">::</span><span class="k">async</span><span class="p">(</span><span class="n">k_s2mm</span><span class="o">.</span><span class="ow">in</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Next, examine host code in <code class="docutils literal notranslate"><span class="pre">aie/graph.cpp</span></code>. It is similar to  <em><strong>Step 1</strong></em>, except that it is needed to update the RTP port of the PL kernels (<code class="docutils literal notranslate"><span class="pre">size</span></code> for <code class="docutils literal notranslate"><span class="pre">mm2s</span></code> and <code class="docutils literal notranslate"><span class="pre">s2mm</span></code>) before starting graph. The API <code class="docutils literal notranslate"><span class="pre">graph::update</span></code> is used to update graph’s RTP port with a scalar value.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gr_pl</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">gr_pl</span><span class="o">.</span><span class="n">k_mm2s</span><span class="o">.</span><span class="ow">in</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ITERATION</span><span class="o">*</span><span class="mi">64</span><span class="p">);</span>
<span class="n">gr_pl</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">gr_pl</span><span class="o">.</span><span class="n">k_s2mm</span><span class="o">.</span><span class="ow">in</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ITERATION</span><span class="o">*</span><span class="mi">64</span><span class="p">);</span>
<span class="n">ret</span><span class="o">=</span><span class="n">gmioInPL</span><span class="o">.</span><span class="n">pl_gm</span><span class="p">(</span><span class="n">inMem</span><span class="p">,</span> <span class="n">BLOCK_SIZE_in_Bytes</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">ret</span><span class="o">!=</span><span class="n">adf</span><span class="p">::</span><span class="n">ok</span><span class="p">){</span>
	<span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s2">&quot;GMIO pl_gm error&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">ret</span><span class="o">=</span><span class="n">gmioOutPL</span><span class="o">.</span><span class="n">pl_gm</span><span class="p">(</span><span class="n">outMem</span><span class="p">,</span> <span class="n">BLOCK_SIZE_in_Bytes</span><span class="p">);</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s2">&quot;GMIO::pl_gm enqueing completed&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">ret</span><span class="o">=</span><span class="n">gr_pl</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">ITERATION</span><span class="p">);</span>
<span class="n">ret</span><span class="o">=</span><span class="n">gr_pl</span><span class="o">.</span><span class="n">wait</span><span class="p">();</span>
</pre></div>
</div>
<p>For information RTP usage, refer to the <em>Versal ACAP AI Engine Programming Environment User Guide</em> (UG1076).</p>
<div class="section" id="run-in-ai-engine-simulator-and-hardware">
<h3>Run in AI Engine Simulator and Hardware<a class="headerlink" href="#run-in-ai-engine-simulator-and-hardware" title="Permalink to this heading">¶</a></h3>
<p>Run the following make command to compile graph and run AI Engine simulator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">aiesim</span>
</pre></div>
</div>
<p>Run the following make command to build image for hardware:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">package</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span>
</pre></div>
</div>
<p>After the package is done, run the following commands in the Linux prompt after booting Linux from an SD card:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export</span> <span class="n">XILINX_XRT</span><span class="o">=/</span><span class="n">usr</span>
<span class="n">cd</span> <span class="o">/</span><span class="n">mnt</span><span class="o">/</span><span class="n">sd</span><span class="o">-</span><span class="n">mmcblk0p1</span>
<span class="o">./</span><span class="n">host</span><span class="o">.</span><span class="n">exe</span> <span class="n">a</span><span class="o">.</span><span class="n">xclbin</span>
</pre></div>
</div>
<p>The host code is self-checking. It will check the output data against the golden data. If the output data matches the golden data after the run is complete, it will print the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>PASS!
</pre></div>
</div>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this heading">¶</a></h2>
<p>In this example, you learned about the following core concepts:</p>
<ul class="simple">
<li><p>Programming model for PL GMIO</p></li>
<li><p>PL Kernel required for PL GMIO in the graph</p></li>
<li><p>PL kernels with fixed or variable size, and their usage</p></li>
</ul>
<p>Next, review <a class="reference internal" href="perf_profile_aie_gmio.html"><span class="doc">AIE GMIO Performance Profiling</span></a>.</p>
<p align="center"><sup>Copyright&copy; 2020 Xilinx</sup></p><p>Licensed under the Apache License, Version 2.0 (the “License”);</p>
<p>you may not use this file except in compliance with the License.</p>
<p>You may obtain a copy of the License at</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">licenses</span><span class="o">/</span><span class="n">LICENSE</span><span class="o">-</span><span class="mf">2.0</span>
</pre></div>
</div>
<p>Unless required by applicable law or agreed to in writing, software</p>
<p>distributed under the License is distributed on an “AS IS” BASIS,</p>
<p>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</p>
<p>See the License for the specific language governing permissions and</p>
<p>limitations under the License.</p>
<p align="center"><sup>XD007</sup></p></div>
</div>


           </div>
          </div>
          
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
				  
				  <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, Xilinx, Inc. Xilinx is now a part of AMD.
      <span class="lastupdated">Last updated on August 5, 2022.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>