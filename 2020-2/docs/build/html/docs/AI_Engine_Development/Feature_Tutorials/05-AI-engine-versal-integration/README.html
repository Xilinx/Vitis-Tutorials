<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
  <title>Introduction &mdash; Vitis™ Tutorials 2020.2 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../../../../index.html" class="icon icon-home"> Vitis™ Tutorials
            <img src="../../../../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2020.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">日本語版</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/master/docs-jp/README.html">Master</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting Started Pathway</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Getting_Started/Vitis/README.html">Vitis Flow 101 Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Getting_Started/Vitis_HLS/README.html">Vitis HLS Analysis and Optimization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Hardware Accelerators</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Introduction/README.html">Introduction to Vitis Hardware Accelerators Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Design_Tutorials/02-bloom/README.html">Optimizing Accelerated FPGA Applications: Bloom Filter Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Design_Tutorials/01-convolution-tutorial/README.html">Accelerating Video Convolution Filtering Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Design_Tutorials/03-rtl_stream_kernel_integration/README.html">Mixed Kernels Design Tutorial with AXI Stream and Vitis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Design_Tutorials/04-traveling-salesperson/README.html">The Travelling Salesman Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Design_Tutorials/05-bottom_up_rtl_kernel/README.html">Bottom-up RTL Kernel Flow with Vitis for Acceleration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Feature_Tutorials/01-rtl_kernel_workflow/README.html">Getting Started with RTL Kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Feature_Tutorials/02-mixing-c-rtl-kernels/README.html">Mixing C++ and RTL Kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Hardware_Accelerators/Feature_Tutorials/03-dataflow_debug_and_optimization/README.html">Vitis HLS Analysis and Optimization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Runtime and System Optimization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Design_Tutorials/01-host-code-opt/README.html">Host Code Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Design_Tutorials/02-ivas-ml/README.html">IVAS ZCU104 ML Acceleration Reference Release</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Feature_Tutorials/01-mult-ddr-banks/README.html">Using Multiple DDR Banks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Feature_Tutorials/02-using-multiple-cu/README.html">Using Multiple Compute Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Feature_Tutorials/03-controlling-vivado-implementation/README.html">Controlling Vivado Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Feature_Tutorials/04-using-hbm/README.html">Using HBM</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Vitis Platform Creation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Vitis_Platform_Creation/Introduction/01-Overview/README.html">Platform Creation Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Vitis_Platform_Creation/Introduction/02-Edge-AI-ZCU104/README.html">Vitis Custom Embedded Platform Creation Example on ZCU104</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Vitis_Platform_Creation/Introduction/03_Edge_VCK190/README.html">Versal Custom Platform Creation Tutorial</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/">Main</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Vitis™ Tutorials</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Introduction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/docs/AI_Engine_Development/Feature_Tutorials/05-AI-engine-versal-integration/README.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <table>
 <tr>
   <td align="center"><img src="https://raw.githubusercontent.com/Xilinx/Image-Collateral/main/xilinx-logo.png" width="30%"/><h1>AI Engine Versal Integration for Hardware Emulation and Hardware</h1>
   </td>
 </tr>
 <tr>
 </td>
 </tr>
</table><div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h1>
<p>The Xilinx Versal ACAP is a fully software-programmable, heterogeneous compute platform that combines the PS (Scalar Engine which includes the Arm processors), PL (Adaptable Engines which includes the FPGA fabric) and AI Engines (AI Engines; Intelligent Engines).</p>
<p>This tutorial demonstrates creating a system design running on the AI Engine, PS, and PL and validating the design running on these heterogeneous domains by running Hardware Emulation. Finally it also takes you through the steps of running this design on the VCK190 board.</p>
<p>This tutorial steps through hardware emulation and hardware flow in the context of a complete Versal ACAP system integration. A Makefile is provided, which can be modified to suit your own needs in a different context. By default the Makefile is set for <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code>. If you need to build for <code class="docutils literal notranslate"><span class="pre">hw</span></code>, add <code class="docutils literal notranslate"><span class="pre">TARGET=hw</span></code> to the <code class="docutils literal notranslate"><span class="pre">make</span></code> commands.</p>
<p><strong>IMPORTANT</strong>: Before beginning the tutorial make sure you have read and followed the <em>Vitis Software Platform Release Notes</em> (v2020.2) for setting up software and installing the VCK190 base platform.</p>
<p>Before starting this tutorial run the steps below:</p>
<ol class="simple">
<li><p>Set up your platform by running the <code class="docutils literal notranslate"><span class="pre">xilinx-versal-common-v2020.2/environment-setup-aarch64-xilinx-linux</span></code> script as provided in the platform download. This script sets up the <code class="docutils literal notranslate"><span class="pre">SDKTARGETSYSROOT</span></code> and <code class="docutils literal notranslate"><span class="pre">CXX</span></code> variables. If the script is not present, you <strong>must</strong> run the <code class="docutils literal notranslate"><span class="pre">xilinx-versal-common-v2020.2/sdk.sh</span></code>.</p></li>
<li><p>Set up your <code class="docutils literal notranslate"><span class="pre">ROOTFS</span></code>, and <code class="docutils literal notranslate"><span class="pre">IMAGE</span></code> to point to the <code class="docutils literal notranslate"><span class="pre">xilinx-versal-common-v2020.2</span></code> directory.</p></li>
<li><p>Set up your <code class="docutils literal notranslate"><span class="pre">PLATFORM_REPO_PATHS</span></code> environment variable based upon where you downloaded the platform.</p></li>
</ol>
<p>This tutorial targets the VCK190 ES board (see https://www.xilinx.com/products/boards-and-kits/vck190.html). This board is currently available via early access. If you have already purchased this board, download the necessary files from the lounge and ensure you have the correct licenses installed. If you do not have a board and ES license please contact your Xilinx sales contact.</p>
</div>
<div class="section" id="objectives">
<h1>Objectives<a class="headerlink" href="#objectives" title="Permalink to this heading">¶</a></h1>
<p>After completing this tutorial, you should be able to:</p>
<ul class="simple">
<li><p>Add input/output ports in an ADF dataflow graph and define their names which will be visible during system integration</p></li>
<li><p>Compile HLS functions for integration in the Programmable Logic (PL)</p></li>
<li><p>Compile ADF graphs</p></li>
<li><p>Create a configuration file that describes system connections and use it during the link stage</p></li>
<li><p>Create a software application that runs on Linux</p></li>
<li><p>Package the design into an easy-to-boot SD card image</p></li>
</ul>
</div>
<div class="section" id="tutorial-overview">
<h1>Tutorial Overview<a class="headerlink" href="#tutorial-overview" title="Permalink to this heading">¶</a></h1>
<p><strong>Section 1</strong>: Compile AI Engine code using the AI Engine compiler and HLS code using <code class="docutils literal notranslate"><span class="pre">v++</span></code>.</p>
<p><strong>Section 2</strong>: Link the AI Engine kernels, and HLS PL kernels with an extensible platform provided.</p>
<p><strong>Section 3</strong>: Compile the A72 host code.</p>
<p><strong>Section 4</strong>: Create the bootable image.</p>
<p><strong>Section 5</strong>: Run the hardware emulation.</p>
<p>The design that will be used is shown in the following figure:</p>
<p><img alt="System Diagram" src="../../../../_images/lab8_system_diagram.png" /></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Kernel</th>
<th>Type</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>MM2S</td>
<td>HLS</td>
<td>Memory Map to Stream HLS kernel to feed input data from DDR to AI Engine interpolator kernel via the PL DMA</td>
</tr>
<tr>
<td>WeightSum</td>
<td>AI Engine</td>
<td>Ramp filter [1 2 3 4 5 6 7 8]</td>
</tr>
<tr>
<td>Average</td>
<td>AI Engine</td>
<td>Just a division by 36</td>
</tr>
<tr>
<td>Polar_clip</td>
<td>HLS</td>
<td>The polar_clip has a single input stream of complex 16-bit samples, and a single output stream whose underlying samples are also complex 16-bit elements. This equates to 32-bit interfaces on the PL side.</td>
</tr>
<tr>
<td>Classify</td>
<td>AI Engine</td>
<td>Classify the input samples</td>
</tr>
<tr>
<td>S2MM</td>
<td>HLS</td>
<td>Stream to Memory Map HLS kernel to feed output result data from AI Engine classifier kernel to DDR via the PL DMA</td>
</tr>
</tbody>
</table><div class="section" id="section-1-compile-pl-kernels-and-ai-engine-graph">
<h2>Section 1: Compile PL Kernels and AI Engine Graph<a class="headerlink" href="#section-1-compile-pl-kernels-and-ai-engine-graph" title="Permalink to this heading">¶</a></h2>
<p>The first step is to take any v++ kernels (HLS C) and your AI Engine kernels and graph and compile them into their respective <code class="docutils literal notranslate"><span class="pre">.xo</span></code> and <code class="docutils literal notranslate"><span class="pre">.o</span></code> files. You can compile the kernels and graph in parallel because they do not rely on each other at this step.</p>
<p>This tutorial design has three AI Engine kernels (<code class="docutils literal notranslate"><span class="pre">weightsum</span></code>, <code class="docutils literal notranslate"><span class="pre">average</span></code>, and <code class="docutils literal notranslate"><span class="pre">classifier</span></code>), one HLS PL kernel (<code class="docutils literal notranslate"><span class="pre">polar_clip</span></code>) and two HLS PL kernels (<code class="docutils literal notranslate"><span class="pre">s2mm</span></code> and <code class="docutils literal notranslate"><span class="pre">mm2s</span></code>):</p>
<div class="section" id="compiling-hls-kernels-using-v">
<h3>Compiling HLS Kernels Using v++<a class="headerlink" href="#compiling-hls-kernels-using-v" title="Permalink to this heading">¶</a></h3>
<p>To compile the <code class="docutils literal notranslate"><span class="pre">mm2s</span></code>, <code class="docutils literal notranslate"><span class="pre">s2mm</span></code>, and <code class="docutils literal notranslate"><span class="pre">polar_clip</span></code> PL HLS kernels, use the <code class="docutils literal notranslate"><span class="pre">v++</span></code> compiler command - which takes in an HLS kernel source and produces an <code class="docutils literal notranslate"><span class="pre">.xo</span></code> file.</p>
<p>To compile the kernels, run the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make kernels
</pre></div>
</div>
<p>Or</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>v++ -c --platform <span class="nv">$PLATFORM_REPO_PATHS</span>/xilinx_vck190_es1_base_202020_1/xilinx_vck190_es1_base_202020_1.xpfm --save-temps -g -k s2mm pl_kernels/s2mm.cpp -o s2mm.xo
v++ -c --platform <span class="nv">$PLATFORM_REPO_PATHS</span>/xilinx_vck190_es1_base_202020_1/xilinx_vck190_es1_base_202020_1.xpfm --save-temps -g -k mm2s pl_kernels/mm2s.cpp -o mm2s.xo
v++ -c --platform <span class="nv">$PLATFORM_REPO_PATHS</span>/xilinx_vck190_es1_base_202020_1/xilinx_vck190_es1_base_202020_1.xpfm --save-temps -g -k polar_clip pl_kernels/polar_clip.cpp -o polar_clip.xo
</pre></div>
</div>
<p>Looking at the <code class="docutils literal notranslate"><span class="pre">v++</span></code> command line, you will see several options. The following table describes each option:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Switch/flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-c</code></td>
<td>Tells v++ to just compile the kernel</td>
</tr>
<tr>
<td><code>--platform/-f</code></td>
<td>Specifies the path to an extensible platform</td>
</tr>
<tr>
<td><code>-g</code></td>
<td>Required for the hw_emu target to capture waveform data</td>
</tr>
<tr>
<td><code>-k</code></td>
<td>The kernel name. This has to match the function name in the corresponding file defining the kernel. (Eg: For kernel <code>mm2s</code> needs to make the function name in <code>mm2s.cpp</code></td>
</tr>
<tr>
<td><code>-o</code></td>
<td>The output file must always have the suffix of <code>.xo</code></td>
</tr>
<tr>
<td><code>--save-temps/-s</code></td>
<td>Saves the generated output process in the <code>_x</code> directory</td>
</tr>
</tbody>
</table></div>
<div class="section" id="compiling-an-ai-engine-adf-graph-for-v-flow">
<h3>Compiling an AI Engine ADF Graph for V++ Flow<a class="headerlink" href="#compiling-an-ai-engine-adf-graph-for-v-flow" title="Permalink to this heading">¶</a></h3>
<p>An ADF Graph can be connected to an extensible Vitis platform. That is, the graph I/Os can be connected either to platform ports or to ports on Vitis kernels through the <code class="docutils literal notranslate"><span class="pre">v++</span></code> connectivity directives.</p>
<ul class="simple">
<li><p>An AI Engine ADF C++ graph contains AI Engine kernels only.</p></li>
<li><p>All interconnections between AI Engine kernels are defined in the C++ graph (<code class="docutils literal notranslate"><span class="pre">graph.h</span></code>).</p></li>
<li><p>All interconnections to external I/Os are fully specified in the C++ simulation testbench (<code class="docutils literal notranslate"><span class="pre">graph.cpp</span></code>) that instantiates the C++ ADF graph object (this is strictly only used in <code class="docutils literal notranslate"><span class="pre">aiesimulator</span></code> which is another tutorial). All platform connections from the graph to the “PLIO” map onto ports on the AI Engine subsystem graph that are connected via v++ connectivity directives.</p></li>
<li><p>No dangling ports or implicit “connections” are allowed by <code class="docutils literal notranslate"><span class="pre">v++</span></code>.</p></li>
<li><p>Stream connections are specified through the <code class="docutils literal notranslate"><span class="pre">v++</span> <span class="pre">--sc</span></code> option, including employment of PL-based data movers, either in the platform or defined outside the ADF graph as Vitis PL kernels.</p></li>
</ul>
<p>To compile the graph type to be used in either HW or HW_EMU, use:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make aie
</pre></div>
</div>
<p>Or</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>aiecompiler --target<span class="o">=</span>hw -include<span class="o">=</span><span class="s2">&quot;</span><span class="nv">$XILINX_VITIS</span><span class="s2">/aietools/include&quot;</span> -include<span class="o">=</span><span class="s2">&quot;./aie&quot;</span> -include<span class="o">=</span><span class="s2">&quot;./data&quot;</span> -include<span class="o">=</span><span class="s2">&quot;./aie/kernels&quot;</span> -include<span class="o">=</span><span class="s2">&quot;./&quot;</span> --pl-freq<span class="o">=</span><span class="m">100</span> -workdir<span class="o">=</span>./Work  aie/graph.cpp
</pre></div>
</div>
<table border="1" class="docutils">
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>--target</td>
<td>Target how the compiler will build the graph. Default is <code>hw</code></td>
</tr>
<tr>
<td>--include</td>
<td>All the include files needed to build the graph</td>
</tr>
<tr>
<td>--pl-freq</td>
<td>Sets the frequency (in MHz) to all PL kernels in the graph</td>
</tr>
<tr>
<td>--workdir</td>
<td>The location of where the Work directory will be created</td>
</tr>
</tbody>
</table><p>The generated output from <code class="docutils literal notranslate"><span class="pre">aiecompiler</span></code> is the <code class="docutils literal notranslate"><span class="pre">Work</span></code> directory, and the <code class="docutils literal notranslate"><span class="pre">libadf.a</span></code> file. This file contains the compiled AI Engine configuration, graph, and Kernel <code class="docutils literal notranslate"><span class="pre">.elf</span></code> files.</p>
</div>
</div>
<div class="section" id="section-2-use-v-to-link-ai-engine-hls-kernels-with-the-platform">
<h2>Section 2: Use V++ to Link AI Engine, HLS Kernels with the Platform<a class="headerlink" href="#section-2-use-v-to-link-ai-engine-hls-kernels-with-the-platform" title="Permalink to this heading">¶</a></h2>
<p>After the AI Engine kernels, graph, PL kernel, and HLS kernels have been compiled, you can use <code class="docutils literal notranslate"><span class="pre">v++</span></code> to link them with the platform to generate an <code class="docutils literal notranslate"><span class="pre">.xclbin</span></code>.</p>
<p><img alt="Section 2" src="../../../../_images/tutorial_step_2.png" /></p>
<p><code class="docutils literal notranslate"><span class="pre">v++</span></code> lets you integrate your AI Engine, HLS, and RTL kernels into an existing extensible platform. This step is where the platform chosen is provided by the hardware designer (or you can opt to use one of the many extensible base platforms provide by Xilinx) and <code class="docutils literal notranslate"><span class="pre">v++</span></code> builds the hardware design for you in addition to integrating the AI Engine and PL kernels in the design.</p>
<p>You have a number of kernels at your disposal, but you need to tell the linker how you want to connect them together (from the AI Engine array to PL and vice versa). These connections are described in a configuration file: <code class="docutils literal notranslate"><span class="pre">system.cfg</span></code> in this tutorial.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[connectivity]</span><span class="w"></span>
<span class="na">nk</span><span class="o">=</span><span class="s">mm2s:1:mm2s</span><span class="w"></span>
<span class="na">nk</span><span class="o">=</span><span class="s">s2mm:1:s2mm</span><span class="w"></span>
<span class="na">stream_connect</span><span class="o">=</span><span class="s">mm2s.s:ai_engine_0.DataIn1</span><span class="w"></span>
<span class="na">stream_connect</span><span class="o">=</span><span class="s">ai_engine_0.DataOut1:s2mm.s</span><span class="w"></span>
</pre></div>
</div>
<table border="1" class="docutils">
<thead>
<tr>
<th>Option/Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nk</code></td>
<td>This specifies the kernel and how many are there be instantiated. As example, the <code>nk=mm2s:1:mm2s</code> means that the kernel <code>mm2s</code> will instantiate one kernel with the name of <code>mm2s</code>.</td>
</tr>
<tr>
<td><code>stream_connect/sc</code></td>
<td>This specifies the streaming connections to be made between PL/AIE or PL/PL. In this case, it should always be an output of a kernel to the input of a kernel.</td>
</tr>
</tbody>
</table><p><strong>NOTE:</strong> The <code class="docutils literal notranslate"><span class="pre">v++</span></code> command-line can get unruly, and using the <code class="docutils literal notranslate"><span class="pre">system.cfg</span></code> file can help contain it.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">ai_engine_0</span></code> the names are provided in the <code class="docutils literal notranslate"><span class="pre">graph.cpp</span></code> when instantiating a <code class="docutils literal notranslate"><span class="pre">PLIO</span></code> object. For this design, as an example, this line <code class="docutils literal notranslate"><span class="pre">PLIO</span> <span class="pre">*in0</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">PLIO(&quot;DataIn1&quot;,</span> <span class="pre">adf::plio_32_bits,&quot;data/input.txt&quot;);</span></code> has the name <strong>DataIn1</strong> which is the interface name.</p>
<p>Notice that the <code class="docutils literal notranslate"><span class="pre">polar_clip</span></code> kernel is not specified in the <code class="docutils literal notranslate"><span class="pre">system.cfg</span></code> file. This is because the generated graph (<code class="docutils literal notranslate"><span class="pre">libadf.a</span></code>) contains the kernel information and knows how to connect it up to the AI Engine.</p>
<p>You can see the <code class="docutils literal notranslate"><span class="pre">v++</span></code> switches in more detail in the <a class="reference external" href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2020_2/ug1393-vitis-application-acceleration.pdf">Vitis Unified Software Platform Documentation</a>.</p>
<p>To build the design you can run the follow command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make xclbin
</pre></div>
</div>
<p>Or</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>v++ -l --platform <span class="nv">$PLATFORM_REPO_PATHS</span>/xilinx_vck190_es1_base_202020_1/xilinx_vck190_es1_base_202020_1.xpfm s2mm.xo mm2s.xo polar_clip.xo libadf.a -t hw_emu --save-temps -g --config system.cfg -o tutorial.xclbin 
</pre></div>
</div>
<table border="1" class="docutils">
<thead>
<tr>
<th>Flag/Switch</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--link</code>/<code>-l</code></td>
<td>Tells v++ that it will be linking a design, so only the <code>*.xo</code> and <code>libadf.a</code> files are valid inputs</td>
</tr>
<tr>
<td><code>--target</code>/<code>-t</code></td>
<td>Tells v++ how far of a build it should go, hardware (which will build down to a PDI) or hardware emulation (which will build the emulation models)</td>
</tr>
<tr>
<td><code>--platform</code></td>
<td>Same from the previous two steps</td>
</tr>
<tr>
<td><code>--config</code></td>
<td>This allows you to simplify the v++ command-line if it gets too unruly and have items in an <code>.ini</code> style file.</td>
</tr>
</tbody>
</table><p>Now you have a generated <code class="docutils literal notranslate"><span class="pre">.xclbin</span></code> that will be used to execute your design on the platform.</p>
</div>
<div class="section" id="section-3-compile-the-a72-host-application">
<h2>Section 3: Compile the A72 Host Application<a class="headerlink" href="#section-3-compile-the-a72-host-application" title="Permalink to this heading">¶</a></h2>
<p>After all the new AI Engine outputs are created, you can compile your host application by following the typical cross-compilation flow for the Cortex-A72. As you might notice, the host code is using <a class="reference external" href="http://www.github.com/Xilinx/XRT">XRT</a> (Xilinx Run Time) as an API to talk to the AI Engine and PL kernels. Notice that in the linker that it is using the the libraries: <code class="docutils literal notranslate"><span class="pre">-ladf_api_xrt</span> <span class="pre">-lxrt_coreutil</span></code>.</p>
<ol>
<li><p>Open <code class="docutils literal notranslate"><span class="pre">sw/main.cpp</span></code> and familiarize yourself with the contents. Pay close attention to API calls and the comments provided.</p>
<p>Note that <a class="reference external" href="https://xilinx.github.io/XRT/2020.2/html/index.html">XRT</a> is used in the host application. This API layer is used to communicate with the programmable logic, specifically the PLIO kernels for reading and writing data. To understand how to use this API in an AI Engine application refer to the “Programming the PS Host Application”.</p>
</li>
<li><p>Open the <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>, and familiarize yourself with the contents. Take note of the <code class="docutils literal notranslate"><span class="pre">GCC_FLAGS</span></code>, <code class="docutils literal notranslate"><span class="pre">GCC_INCLUDES</span></code>.</p>
<ol class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">GCC_FLAGS</span></code>: Self-explanatory that you will be compiling this code with C++ 14. More explanation will be provided in the packaging step.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GCC_INCLUDES</span></code>: Has the list of all the necessary include files from the SDKTARGETSYSROOT as well as the AI Engine tools.</p></li>
</ol>
</li>
<li><p>Close the Makefile, and run the command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make host
</pre></div>
</div>
<p>Or</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> ./sw 
<span class="nv">$CXX</span> -Wall -c -std<span class="o">=</span>c++14 -Wno-int-to-pointer-cast --sysroot<span class="o">=</span><span class="nv">$SDKTARGETSYSROOT</span> -I<span class="nv">$SDKTARGETSYSROOT</span>/usr/include/xrt -I<span class="nv">$SDKTARGETSYSROOT</span>/usr/include -I./ -I../aie -I<span class="nv">$XILINX_VITIS</span>/aietools/include -I<span class="nv">$XILINX_VITIS</span>/include -o aie_control_xrt.o ../Work/ps/c_rts/aie_control_xrt.cpp
<span class="nv">$CXX</span> -Wall -c -std<span class="o">=</span>c++14 -Wno-int-to-pointer-cast --sysroot<span class="o">=</span><span class="nv">$SDKTARGETSYSROOT</span> -I<span class="nv">$SDKTARGETSYSROOT</span>/usr/include/xrt -I<span class="nv">$SDKTARGETSYSROOT</span>/usr/include -I./ -I../aie -I<span class="nv">$XILINX_VITIS</span>/aietools/include -I<span class="nv">$XILINX_VITIS</span>/include -o main.o host.cpp
<span class="nv">$CXX</span> main.o aie_control_xrt.o -ladf_api_xrt -lxrt_coreutil -L<span class="nv">$SDKTARGETSYSROOT</span>/usr/lib --sysroot<span class="o">=</span><span class="nv">$SDKTARGETSYSROOT</span> -L<span class="nv">$XILINX_VITIS</span>/aietools/lib/aarch64.o -o host.exe 
<span class="nb">cd</span> ..
</pre></div>
</div>
</li>
</ol>
<p>The follow table describes some of the GCC options being used:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-Wall</code></td>
<td>Print out all warnings</td>
</tr>
<tr>
<td><code>-Wno-int-to-pointer-cast</code></td>
<td>Warn about an integer to pointer cast</td>
</tr>
<tr>
<td><code>--sysroot</code></td>
<td>Tells the compiler where to find the headers/libs for cross-compile</td>
</tr>
<tr>
<td><code>-std=c++14</code></td>
<td>This is required for Linux applications using XRT</td>
</tr>
</tbody>
</table></div>
<div class="section" id="section-4-package-the-design">
<h2>Section 4: Package the Design<a class="headerlink" href="#section-4-package-the-design" title="Permalink to this heading">¶</a></h2>
<p>With all the AI Engine outputs and the new platform created, you can now generate the Programmable Device Image (PDI) and a package to be used on an SD card. The PDI contains all executables, bitstreams, and configurations of every element of the device, and the packaged SD card directory contains everything to boot Linux and have your generated application and <code class="docutils literal notranslate"><span class="pre">.xclbin</span></code>.</p>
<p>To package the design, run the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make package
</pre></div>
</div>
<p>Or</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> ./sw
v++ --package -t hw_emu <span class="se">\</span>
	-f <span class="nv">$PLATFORM_REPO_PATHS</span>/xilinx_vck190_es1_base_202020_1/xilinx_vck190_es1_base_202020_1.xpfm <span class="se">\</span>
	--package.rootfs<span class="o">=</span><span class="nv">$PLATFORM_REPO_PATHS</span>/sw/versal/xilinx-versal-common-v2020.2/rootfs.ext4 <span class="se">\</span>
	--package.image_format<span class="o">=</span>ext4 <span class="se">\</span>
	--package.boot_mode<span class="o">=</span>sd <span class="se">\</span>
	--package.kernel_image<span class="o">=</span><span class="nv">$PLATFORM_REPO_PATHS</span>/sw/versal/xilinx-versal-common-v2020.2/Image <span class="se">\</span>
	--package.defer_aie_run <span class="se">\</span>
	--package.sd_file host.exe ../tutorial.xclbin ../libadf.a
<span class="nb">cd</span> ..
</pre></div>
</div>
<p><strong>NOTE:</strong> By default the <code class="docutils literal notranslate"><span class="pre">--package</span></code> flow will create a <code class="docutils literal notranslate"><span class="pre">a.xclbin</span></code> automatically if the <code class="docutils literal notranslate"><span class="pre">-o</span></code> switch is not set.</p>
<p>The following table describes the packager options:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Switch/flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rootfs</code></td>
<td>Points to the formatted image of the platform</td>
</tr>
<tr>
<td><code>image_format</code></td>
<td>Tells packager what the image format is</td>
</tr>
<tr>
<td><code>boot_mode</code></td>
<td>Signifies how the design is going to be run</td>
</tr>
<tr>
<td><code>kernel_image</code></td>
<td>Points to the Image file created by Petalinux</td>
</tr>
<tr>
<td><code>defer_aie_run</code></td>
<td>Tells packager at boot to not start the AI Engine and let the host application control it</td>
</tr>
<tr>
<td><code>sd_file</code></td>
<td>Tell the packager what file is to be packaged in the <code>sd_card</code> directory. You'll have to specify this multiple times for all the files you want packaged</td>
</tr>
</tbody>
</table></div>
<div class="section" id="section-5-run-hardware-emulation">
<h2>Section 5: Run Hardware Emulation<a class="headerlink" href="#section-5-run-hardware-emulation" title="Permalink to this heading">¶</a></h2>
<p>After packaging, everything is set to run emulation or hardware.</p>
<ol class="simple">
<li><p>To run emulation use the following command:</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make run_emu
</pre></div>
</div>
<p>Or</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> ./sw
./launch_hw_emu.sh
<span class="nb">cd</span> ..
</pre></div>
</div>
<p>When launched, use the Linux prompt presented to run the design.</p>
<ol>
<li><p>Execute the following command when the emulated Linux prompt displays:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> /mnt/sd-mmcblk0p1
<span class="nb">export</span> <span class="nv">XILINX_XRT</span><span class="o">=</span>/usr
dmesg -n <span class="m">4</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;Hide DRM messages...&quot;</span>
</pre></div>
</div>
</li>
</ol>
<p>This will set up the design to run emulation. Run the design using the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./host.exe a.xclbin
</pre></div>
</div>
<p>You should see an output displaying <strong>TEST PASSED</strong>. When this is shown, run the keyboard command: <code class="docutils literal notranslate"><span class="pre">Ctrl+A</span> <span class="pre">x</span></code> to end the QEMU instance.</p>
</div>
<div class="section" id="section-6-build-and-run-on-hardware">
<h2>Section 6: Build and Run on Hardware<a class="headerlink" href="#section-6-build-and-run-on-hardware" title="Permalink to this heading">¶</a></h2>
<ol>
<li><p>To build for hardware run the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make xclbin <span class="nv">TARGET</span><span class="o">=</span>hw
</pre></div>
</div>
<p>Or</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>v++ -l --platform <span class="nv">$PLATFORM_REPO_PATHS</span>/xilinx_vck190_es1_base_202020_1/xilinx_vck190_es1_base_202020_1.xpfm s2mm.xo mm2s.xo polar_clip.xo libadf.a -t hw --save-temps -g --config system.cfg -o tutorial.xclbin 
</pre></div>
</div>
</li>
<li><p>Then re-run the packaging step with:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make package <span class="nv">TARGET</span><span class="o">=</span>hw
</pre></div>
</div>
<p>Or</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> ./sw
v++ --package -t hw <span class="se">\</span>
	-f <span class="nv">$PLATFORM_REPO_PATHS</span>/xilinx_vck190_es1_base_202020_1/xilinx_vck190_es1_base_202020_1.xpfm <span class="se">\</span>
	--package.rootfs<span class="o">=</span><span class="nv">$PLATFORM_REPO_PATHS</span>/sw/versal/xilinx-versal-common-v2020.2/rootfs.ext4 <span class="se">\</span>
	--package.image_format<span class="o">=</span>ext4 <span class="se">\</span>
	--package.boot_mode<span class="o">=</span>sd <span class="se">\</span>
	--package.kernel_image<span class="o">=</span><span class="nv">$PLATFORM_REPO_PATHS</span>/sw/versal/xilinx-versal-common-v2020.2/Image <span class="se">\</span>
	--package.defer_aie_run <span class="se">\</span>
	--package.sd_file host.exe ../tutorial.xclbin ../libadf.a
<span class="nb">cd</span> ..
</pre></div>
</div>
</li>
</ol>
<p>When you run on hardware, ensure you have a supported SD card. Format the SD card with the <code class="docutils literal notranslate"><span class="pre">sw/sd_card.img</span></code> file. Then plug the SD card into the board and power it up.</p>
<ol>
<li><p>When a Linux prompt appears, run the following commands:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>dmesg -n <span class="m">4</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;Hide DRM messages...&quot;</span>
<span class="nb">cd</span> /mnt/sd-mmcblk0p1
<span class="nb">export</span> <span class="nv">XILINX_XRT</span><span class="o">=</span>/usr
./host.exe a.xclbin
</pre></div>
</div>
</li>
</ol>
<p>You should see <strong>TEST PASSED</strong>. You have successfully run your design on hardware.</p>
<p><strong>IMPORTANT</strong>: To rerun the application you need to power cycle the board.</p>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this heading">¶</a></h2>
<p>In this tutorial you learned the following:</p>
<ul class="simple">
<li><p>How to compile PLIO and PL Kernels using v++ -c</p></li>
<li><p>How to link the <code class="docutils literal notranslate"><span class="pre">libadf.a</span></code>, PLIO and PL kernels to the <code class="docutils literal notranslate"><span class="pre">xilinx_vck190_es1_202020_1</span></code> platform</p></li>
<li><p>How to package your host code, and the generated <code class="docutils literal notranslate"><span class="pre">xclbin</span></code> and <code class="docutils literal notranslate"><span class="pre">libadf.a</span></code> into an SD card directory</p></li>
<li><p>How to execute the design on the board</p></li>
<li><p>How to execute the design for hardware emulation</p></li>
</ul>
<p>To read more about the use of Vitis in the AI Engine flow see: <em>UG1076: Versal ACAP AI Engine Programming Environment Chapter 13: Integrating the Application Using the Vitis Tool Flow</em>.</p>
<p>© Copyright 2020 Xilinx, Inc.</p>
<p>Licensed under the Apache License, Version 2.0 (the “License”);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">licenses</span><span class="o">/</span><span class="n">LICENSE</span><span class="o">-</span><span class="mf">2.0</span>
</pre></div>
</div>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an “AS IS” BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
<p align="center"><sup>XD002</sup></p></div>
</div>


           </div>
          </div>
          
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
				  
				  <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, Xilinx, Inc. Xilinx is now a part of AMD.
      <span class="lastupdated">Last updated on August 5, 2022.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>