<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
  <title>Data Movement Between the Host and Kernel &mdash; Vitis™ Tutorials 2020.2 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../../../../index.html" class="icon icon-home"> Vitis™ Tutorials
            <img src="../../../../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2020.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">日本語版</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/master/docs-jp/README.html">Master</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting Started Pathway</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Getting_Started/Vitis/README.html">Vitis Flow 101 Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Getting_Started/Vitis_HLS/README.html">Vitis HLS Analysis and Optimization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Hardware Accelerators</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Introduction/README.html">Introduction to Vitis Hardware Accelerators Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="README.html">Optimizing Accelerated FPGA Applications: Bloom Filter Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../01-convolution-tutorial/README.html">Accelerating Video Convolution Filtering Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03-rtl_stream_kernel_integration/README.html">Mixed Kernels Design Tutorial with AXI Stream and Vitis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04-traveling-salesperson/README.html">The Travelling Salesman Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05-bottom_up_rtl_kernel/README.html">Bottom-up RTL Kernel Flow with Vitis for Acceleration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Feature_Tutorials/01-rtl_kernel_workflow/README.html">Getting Started with RTL Kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Feature_Tutorials/02-mixing-c-rtl-kernels/README.html">Mixing C++ and RTL Kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Feature_Tutorials/03-dataflow_debug_and_optimization/README.html">Vitis HLS Analysis and Optimization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Runtime and System Optimization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Design_Tutorials/01-host-code-opt/README.html">Host Code Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Design_Tutorials/02-ivas-ml/README.html">IVAS ZCU104 ML Acceleration Reference Release</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Feature_Tutorials/01-mult-ddr-banks/README.html">Using Multiple DDR Banks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Feature_Tutorials/02-using-multiple-cu/README.html">Using Multiple Compute Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Feature_Tutorials/03-controlling-vivado-implementation/README.html">Controlling Vivado Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Runtime_and_System_Optimization/Feature_Tutorials/04-using-hbm/README.html">Using HBM</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Vitis Platform Creation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Vitis_Platform_Creation/Introduction/01-Overview/README.html">Platform Creation Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Vitis_Platform_Creation/Introduction/02-Edge-AI-ZCU104/README.html">Vitis Custom Embedded Platform Creation Example on ZCU104</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Vitis_Platform_Creation/Introduction/03_Edge_VCK190/README.html">Versal Custom Platform Creation Tutorial</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/">Main</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Vitis™ Tutorials</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Data Movement Between the Host and Kernel</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/docs/Hardware_Accelerators/Design_Tutorials/02-bloom/5_data-movement.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <table class="sphinxhide">
 <tr>
   <td align="center"><img src="https://raw.githubusercontent.com/Xilinx/Image-Collateral/main/xilinx-logo.png" width="30%"/><h1>2020.2 Vitis™ Application Acceleration Development Flow Tutorials</h1>
   <a href="https://github.com/Xilinx/Vitis-Tutorials/tree/2020.1">See 2020.1 Vitis Application Acceleration Development Flow Tutorials</a>
   </td>
 </tr>
 <tr>
 <td>
 </td>
 </tr>
</table><div class="section" id="data-movement-between-the-host-and-kernel">
<h1>Data Movement Between the Host and Kernel<a class="headerlink" href="#data-movement-between-the-host-and-kernel" title="Permalink to this heading">¶</a></h1>
<p>In the previous step, you implemented a sequential execution of the written words from the host, computing hash functions on the FPGA, and reading flags by the host.</p>
<p>The compute does not start until the entire input is read into the FPGA, and similarly, the host read from the FPGA does not start until compute is done on the FPGA.</p>
<p>In this lab, you will work with an:</p>
<ul class="simple">
<li><p>Overlap of host data transfer and compute on the FPGA with split buffers (two buffers)</p>
<ul>
<li><p>Split the documents and send them to the FPGA in two iterations.</p></li>
<li><p>The kernel can start the compute as soon as the data for the corresponding iteration is transferred to the FPGA.</p></li>
</ul>
</li>
<li><p>Overlap of host data transfer and compute with multiple buffers</p>
<ul>
<li><p>Explore how the application performance is affected based on splitting the documents and into 2, 4, 8, 16, 32, 64, and 128 chunks.</p></li>
</ul>
</li>
<li><p>Overlap data transfer from host, compute on FPGA and profile score on the CPU</p>
<ul>
<li><p>Enables the host to start profile scores as soon as the flags are received.</p></li>
</ul>
</li>
</ul>
<div class="section" id="overlap-of-host-data-transfer-and-compute-with-split-buffers">
<h2>Overlap of Host Data Transfer and Compute with Split Buffers<a class="headerlink" href="#overlap-of-host-data-transfer-and-compute-with-split-buffers" title="Permalink to this heading">¶</a></h2>
<p>The following figure illustrates the use case where the input data is split into two sub-buffers.</p>
<p><img alt="../../../../_images/overlap_split_buffer.PNG" src="../../../../_images/overlap_split_buffer.PNG" /></p>
<div class="section" id="host-code-modifications">
<h3>Host Code Modifications<a class="headerlink" href="#host-code-modifications" title="Permalink to this heading">¶</a></h3>
<p>Navigate to <code class="docutils literal notranslate"><span class="pre">$LAB_WORK_DIR/reference_files</span></code>, and with a file editor, open <code class="docutils literal notranslate"><span class="pre">run_split_buffer.cpp</span></code>.</p>
<p>Lines 64 through 148 are modified to optimize the host code to send the input buffer in two iterations which enables the overlap of data transfers with the accelerator execution. The following steps explain the process in detail:</p>
<ol>
<li><p>The following two sub-buffers for <code class="docutils literal notranslate"><span class="pre">input_doc_words</span></code> and <code class="docutils literal notranslate"><span class="pre">output_inh_flags</span></code> are created.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Make buffers resident in the device</span>
<span class="n">q</span><span class="p">.</span><span class="n">enqueueMigrateMemObjects</span><span class="p">({</span><span class="n">buffer_bloom_filter</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_input_doc_words</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_output_inh_flags</span><span class="p">},</span><span class="w"> </span><span class="n">CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Specify size of sub-buffers, one for each transaction </span>
<span class="kt">unsigned</span><span class="w"> </span><span class="n">subbuf_doc_sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total_doc_size</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="n">subbuf_inh_sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total_doc_size</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Declare sub-buffer regions to specify offset and size of sub-buffer   </span>
<span class="n">cl_buffer_region</span><span class="w"> </span><span class="n">subbuf_inh_info</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="n">cl_buffer_region</span><span class="w"> </span><span class="n">subbuf_doc_info</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>

<span class="c1">// Declare sub-buffers</span>
<span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">subbuf_inh_flags</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">subbuf_doc_words</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>

<span class="w"> </span><span class="c1">// Specify offset and size of sub-buffers </span>
<span class="n">subbuf_inh_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">subbuf_inh_sz</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)};</span><span class="w"></span>
<span class="n">subbuf_inh_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="n">subbuf_inh_sz</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">),</span><span class="w"> </span><span class="n">subbuf_inh_sz</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)};</span><span class="w"></span>
<span class="n">subbuf_doc_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">subbuf_doc_sz</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uint</span><span class="p">)};</span><span class="w"></span>
<span class="n">subbuf_doc_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="n">subbuf_doc_sz</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="n">uint</span><span class="p">),</span><span class="w"> </span><span class="n">subbuf_doc_sz</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uint</span><span class="p">)};</span><span class="w"></span>

<span class="c1">// Create sub-buffers from buffers based on sub-buffer regions</span>
<span class="n">subbuf_inh_flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer_output_inh_flags</span><span class="p">.</span><span class="n">createSubBuffer</span><span class="p">(</span><span class="n">CL_MEM_WRITE_ONLY</span><span class="p">,</span><span class="w"> </span><span class="n">CL_BUFFER_CREATE_TYPE_REGION</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">subbuf_inh_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="n">subbuf_inh_flags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer_output_inh_flags</span><span class="p">.</span><span class="n">createSubBuffer</span><span class="p">(</span><span class="n">CL_MEM_WRITE_ONLY</span><span class="p">,</span><span class="w"> </span><span class="n">CL_BUFFER_CREATE_TYPE_REGION</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">subbuf_inh_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="n">subbuf_doc_words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer_input_doc_words</span><span class="p">.</span><span class="n">createSubBuffer</span><span class="w"> </span><span class="p">(</span><span class="n">CL_MEM_READ_ONLY</span><span class="p">,</span><span class="w">  </span><span class="n">CL_BUFFER_CREATE_TYPE_REGION</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">subbuf_doc_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="n">subbuf_doc_words</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer_input_doc_words</span><span class="p">.</span><span class="n">createSubBuffer</span><span class="w"> </span><span class="p">(</span><span class="n">CL_MEM_READ_ONLY</span><span class="p">,</span><span class="w">  </span><span class="n">CL_BUFFER_CREATE_TYPE_REGION</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">subbuf_doc_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">mbytes_total</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">total_doc_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span><span class="p">);</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">mbytes_block</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">mbytes_total</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot; Processing %.3f MBytes of data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mbytes_total</span><span class="p">);</span><span class="w"></span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot; Splitting data in 2 sub-buffers of %.3f MBytes for FPGA processing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mbytes_block</span><span class="p">);</span><span class="w">  </span>
</pre></div>
</div>
</li>
<li><p>A vector of events are created to coordinate the read, compute, and write operations, so that each iteration is independent of the other iteration, allowing for an overlap between the data transfer and compute.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create Events to co-ordinate read,compute and write for each iteration </span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;</span><span class="w"> </span><span class="n">wordWait</span><span class="p">;</span><span class="w"></span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;</span><span class="w"> </span><span class="n">krnlWait</span><span class="p">;</span><span class="w"></span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;</span><span class="w"> </span><span class="n">flagWait</span><span class="p">;</span><span class="w"></span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;--------------------------------------------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>

<span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">time_point</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">;</span><span class="w"></span>
<span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>The kernel arguments are set, and the kernel is enqueued to load the Bloom filter coefficients.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Only load the Bloom filter in the kernel</span>
<span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="w"> </span><span class="n">buffDone</span><span class="p">,</span><span class="n">krnlDone</span><span class="p">,</span><span class="n">flagDone</span><span class="p">;</span><span class="w"></span>
<span class="n">total_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">load_filter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="n">kernel</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">total_size</span><span class="p">);</span><span class="w"></span>
<span class="n">kernel</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">load_filter</span><span class="p">);</span><span class="w"></span>
<span class="n">q</span><span class="p">.</span><span class="n">enqueueMigrateMemObjects</span><span class="p">({</span><span class="n">buffer_bloom_filter</span><span class="p">},</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffDone</span><span class="p">);</span><span class="w"></span>
<span class="n">wordWait</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">buffDone</span><span class="p">);</span><span class="w"></span>
<span class="n">q</span><span class="p">.</span><span class="n">enqueueTask</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wordWait</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">krnlDone</span><span class="p">);</span><span class="w"></span>
<span class="n">krnlWait</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">krnlDone</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>During the first iteration, the kernel arguments are set, the commands to write the input buffer with first set of words to the FPGA, execute the kernel, and read the results back to the host, are enqueued.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">//  Set Kernel Arguments, Read, Enqueue Kernel and Write for first iteration</span>
<span class="w">  </span><span class="n">total_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total_doc_size</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">load_filter</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">total_size</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">load_filter</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">subbuf_inh_flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">subbuf_doc_words</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueMigrateMemObjects</span><span class="p">({</span><span class="n">subbuf_doc_words</span><span class="p">[</span><span class="mi">0</span><span class="p">]},</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wordWait</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffDone</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="n">wordWait</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">buffDone</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueTask</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wordWait</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">krnlDone</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">krnlWait</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">krnlDone</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueMigrateMemObjects</span><span class="p">({</span><span class="n">subbuf_inh_flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]},</span><span class="w"> </span><span class="n">CL_MIGRATE_MEM_OBJECT_HOST</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">krnlWait</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flagDone</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">flagWait</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">flagDone</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>During the second iteration, the kernel arguments are set, the commands to write the input buffer with second set of words to the FPGA, execute the kernel, and read the results back to the host, are enqueued.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">//  Set Kernel Arguments, Read, Enqueue Kernel and Write for second iteration</span>
<span class="w">  </span><span class="n">total_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total_doc_size</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">load_filter</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">total_size</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">load_filter</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">subbuf_inh_flags</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">subbuf_doc_words</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueMigrateMemObjects</span><span class="p">({</span><span class="n">subbuf_doc_words</span><span class="p">[</span><span class="mi">1</span><span class="p">]},</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wordWait</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffDone</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="n">wordWait</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">buffDone</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueTask</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wordWait</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">krnlDone</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">krnlWait</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">krnlDone</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueMigrateMemObjects</span><span class="p">({</span><span class="n">subbuf_inh_flags</span><span class="p">[</span><span class="mi">1</span><span class="p">]},</span><span class="w"> </span><span class="n">CL_MIGRATE_MEM_OBJECT_HOST</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">krnlWait</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flagDone</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">flagWait</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">flagDone</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>The host waits until the output is read back from the FPGA.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Wait until all results are copied back to the host before doing the post-processing</span>
<span class="w"> </span><span class="n">flagWait</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">wait</span><span class="p">();</span><span class="w"></span>
<span class="w"> </span><span class="n">flagWait</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">wait</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="run-the-application-using-the-bloom8x-kernel">
<h3>Run the Application Using the Bloom8x Kernel<a class="headerlink" href="#run-the-application-using-the-bloom8x-kernel" title="Permalink to this heading">¶</a></h3>
<p>Navigate to the <code class="docutils literal notranslate"><span class="pre">makefile</span></code> directory, and run the following <code class="docutils literal notranslate"><span class="pre">make</span></code> command.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> cd $LAB_WORK_DIR/makefile; make run STEP=split_buffer TARGET=hw PF=8 
</pre></div>
</div>
<p>The following output displays.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Processing</span> <span class="mf">1398.903</span> <span class="n">MBytes</span> <span class="n">of</span> <span class="n">data</span>
<span class="n">Split_buffer</span> <span class="p">:</span> <span class="n">Splitting</span> <span class="n">data</span> <span class="ow">in</span> <span class="mi">2</span> <span class="n">sub</span><span class="o">-</span><span class="n">buffers</span> <span class="n">of</span> <span class="mf">699.452</span> <span class="n">MBytes</span> <span class="k">for</span> <span class="n">FPGA</span> <span class="n">processing</span>
<span class="o">--------------------------------------------------------------------</span>
<span class="n">Executed</span> <span class="n">FPGA</span> <span class="n">accelerated</span> <span class="n">version</span>  <span class="o">|</span>   <span class="mf">734.0995</span> <span class="n">ms</span>   <span class="p">(</span> <span class="n">FPGA</span> <span class="mf">262.363</span> <span class="n">ms</span> <span class="p">)</span>
<span class="n">Executed</span> <span class="n">Software</span><span class="o">-</span><span class="n">Only</span> <span class="n">version</span>     <span class="o">|</span>   <span class="mf">3246.2145</span> <span class="n">ms</span>
<span class="o">--------------------------------------------------------------------</span>
<span class="n">Verification</span><span class="p">:</span> <span class="n">PASS</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="review-profile-report-and-timeline-trace-for-the-bloom8x-kernel">
<h2>Review Profile Report and Timeline Trace for the Bloom8x Kernel<a class="headerlink" href="#review-profile-report-and-timeline-trace-for-the-bloom8x-kernel" title="Permalink to this heading">¶</a></h2>
<ol>
<li><p>Run the following commands to view the Timeline Trace report with Bloom8x kernel.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>vitis_analyzer $LAB_WORK_DIR/build/split_buffer/kernel_8/hw/runOnfpga_hw.xclbin.run_summary 
</pre></div>
</div>
</li>
<li><p>Zoom in to display the following Timeline Trace report.</p>
<p><img alt="../../../../_images/double_buffer_timeline_trace.PNG" src="../../../../_images/double_buffer_timeline_trace.PNG" /></p>
<ul class="simple">
<li><p>The Timeline Trace confirms that you achieved the execution schedule you expected.</p>
<ul>
<li><p>There is an overlap of the read and compute with write operations between the first and second iterations.</p></li>
<li><p>The execution time of the first kernel run and the first data read are effectively “hidden” behind the write data transfer from host. This results in a faster overall run.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>From the Profile Report, <em>Host Data Transfer: Host Transfer</em> shows that the “data transfer” from the host CPU consumes more than the “Kernel Compute Time”.</p>
<ul class="simple">
<li><p>The Host to Global Memory WRITE Transfer takes about 178 ms, which is higher compared to using a single buffer.</p></li>
<li><p>The Host to Global Memory READ Transfer takes about 38 ms.</p></li>
</ul>
</li>
<li><p><em>Kernels &amp; Compute Unit: Kernel Execution</em> shows that the kernel execution time (calculated by enqueing both compute times) is also higher than when you used a single buffer. When overlapping the host data transfer and kernel, the DDR memory is not exclusive to either the host or kernel which results in a lower performance data transfer. However, you can see that the overall performance is better here compared to the earlier results without splitting words.</p></li>
</ol>
<p>When the Bloom8x kernel is used, you can also confirm from the reports that the kernel enqueue time for each compute is smaller than each host transfer. Therefore, there is no real benefit of using the Bloom16x kernel because you are limited by the transfer time from the host. The execution time of the Bloom16x kernel will be faster, but the kernel does not improve the overall application performance. You can confirm this fact by using the Bloom16x kernel in the next step.</p>
<div class="section" id="run-the-application-using-the-bloom16x-kernel">
<h3>Run the Application Using the Bloom16x Kernel<a class="headerlink" href="#run-the-application-using-the-bloom16x-kernel" title="Permalink to this heading">¶</a></h3>
<p>Navigate to the <code class="docutils literal notranslate"><span class="pre">makefile</span></code> directory, and run the <code class="docutils literal notranslate"><span class="pre">make</span></code> command.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cd $LAB_WORK_DIR/makefile; make run STEP=split_buffer TARGET=hw PF=16
</pre></div>
</div>
<p>The following output displays.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Processing</span> <span class="mf">1398.903</span> <span class="n">MBytes</span> <span class="n">of</span> <span class="n">data</span>
<span class="n">Split_buffer</span> <span class="p">:</span> <span class="n">Splitting</span> <span class="n">data</span> <span class="ow">in</span> <span class="mi">2</span> <span class="n">sub</span><span class="o">-</span><span class="n">buffers</span> <span class="n">of</span> <span class="mf">699.452</span> <span class="n">MBytes</span> <span class="k">for</span> <span class="n">FPGA</span> <span class="n">processing</span>
<span class="o">--------------------------------------------------------------------</span>
<span class="n">Executed</span> <span class="n">FPGA</span> <span class="n">accelerated</span> <span class="n">version</span>  <span class="o">|</span>   <span class="mf">733.6324</span> <span class="n">ms</span>   <span class="p">(</span> <span class="n">FPGA</span> <span class="mf">233.314</span> <span class="n">ms</span> <span class="p">)</span>
<span class="n">Executed</span> <span class="n">Software</span><span class="o">-</span><span class="n">Only</span> <span class="n">version</span>     <span class="o">|</span>   <span class="mf">3133.5186</span> <span class="n">ms</span>
<span class="o">--------------------------------------------------------------------</span>
<span class="n">Verification</span><span class="p">:</span> <span class="n">PASS</span>
</pre></div>
</div>
<p>You can see that if the documents are split into two buffers, the overall application execution time using the Bloom8x kernel and Bloom16x kernel are very close. As expected, using the Bloom16x kernel rather than the Bloom8x kernel has no benefit.</p>
<p>While developing your own application, these attributes can be explored to make trade-offs and pick the optimal kernel implementation optimized for resources/performance.</p>
<p>You will continue this lab with the Bloom8x kernel.</p>
</div>
<div class="section" id="conclusion">
<h3>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this heading">¶</a></h3>
<p>The total execution time on the FPGA has been improved because of the overlapping computation with data transfers. The execution time of the first kernel run and the first data read have been eliminated.</p>
</div>
</div>
<div class="section" id="overlap-of-host-data-transfer-and-compute-with-multiple-buffers">
<h2>Overlap of Host Data Transfer and Compute with Multiple Buffers<a class="headerlink" href="#overlap-of-host-data-transfer-and-compute-with-multiple-buffers" title="Permalink to this heading">¶</a></h2>
<p>In the previous step, you split the input buffer into two sub-buffers and overlapped the first compute with the second data transfer. In this step, you will write generic code, so the input data is split and processed in an arbitrary number of iterations to achieve the optimal execution time.</p>
<div class="section" id="id1">
<h3>Host Code Modifications<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h3>
<p>Open <code class="docutils literal notranslate"><span class="pre">run_generic_buffer.cpp</span></code> in <code class="docutils literal notranslate"><span class="pre">$LAB_WORK_DIR/reference_files</span></code> with a file editor.</p>
<p>Lines 67 through 139 are modified to optimize the host code to send the input buffer in multiple iterations to enable the overlapping of the data transfer and compute. The process is explained in detail as follows:</p>
<ol>
<li><p>The following multiple sub-buffers are created for <code class="docutils literal notranslate"><span class="pre">input_doc_words</span></code> and <code class="docutils literal notranslate"><span class="pre">output_inh_flags</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// Specify size of sub buffers for each iteration</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">subbuf_doc_sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total_doc_size</span><span class="o">/</span><span class="n">num_iter</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">subbuf_inh_sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total_doc_size</span><span class="o">/</span><span class="n">num_iter</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Declare sub buffer regions to specify offset and size for each iteration</span>
<span class="w">  </span><span class="n">cl_buffer_region</span><span class="w"> </span><span class="n">subbuf_inh_info</span><span class="p">[</span><span class="n">num_iter</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">cl_buffer_region</span><span class="w"> </span><span class="n">subbuf_doc_info</span><span class="p">[</span><span class="n">num_iter</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Declare sub buffers</span>
<span class="w">  </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">subbuf_inh_flags</span><span class="p">[</span><span class="n">num_iter</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">cl</span><span class="o">::</span><span class="n">Buffer</span><span class="w"> </span><span class="n">subbuf_doc_words</span><span class="p">[</span><span class="n">num_iter</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Define sub buffers from buffers based on sub-buffer regions</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">num_iter</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">subbuf_inh_info</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="n">i</span><span class="o">*</span><span class="n">subbuf_inh_sz</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">),</span><span class="w"> </span><span class="n">subbuf_inh_sz</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)};</span><span class="w"></span>
<span class="w">    </span><span class="n">subbuf_doc_info</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="n">i</span><span class="o">*</span><span class="n">subbuf_doc_sz</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uint</span><span class="p">),</span><span class="w"> </span><span class="n">subbuf_doc_sz</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uint</span><span class="p">)};</span><span class="w"></span>
<span class="w">    </span><span class="n">subbuf_inh_flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer_output_inh_flags</span><span class="p">.</span><span class="n">createSubBuffer</span><span class="p">(</span><span class="n">CL_MEM_WRITE_ONLY</span><span class="p">,</span><span class="w"> </span><span class="n">CL_BUFFER_CREATE_TYPE_REGION</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">subbuf_inh_info</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">subbuf_doc_words</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer_input_doc_words</span><span class="p">.</span><span class="n">createSubBuffer</span><span class="w"> </span><span class="p">(</span><span class="n">CL_MEM_READ_ONLY</span><span class="p">,</span><span class="w">  </span><span class="n">CL_BUFFER_CREATE_TYPE_REGION</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">subbuf_doc_info</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">mbytes_total</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">total_doc_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">mbytes_block</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">mbytes_total</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">num_iter</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; Processing %.3f MBytes of data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mbytes_total</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">num_iter</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; Splitting data in %d sub-buffers of %.3f MBytes for FPGA processing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">num_iter</span><span class="p">,</span><span class="w"> </span><span class="n">mbytes_block</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>A vector of events are created to coordinate the read, compute, and write operations, so every iteration is independent of other iterations, which allows for an overlap between the data transfer and compute.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// Create Events for coordinating read,compute and write for each iteration</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;</span><span class="w"> </span><span class="n">wordWait</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;</span><span class="w"> </span><span class="n">krnlWait</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;</span><span class="w"> </span><span class="n">flagWait</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;--------------------------------------------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">time_point</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>The kernel arguments are set, and the kernel is enqueued to load the Bloom filter coefficients.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// Set Kernel arguments and load the Bloom filter coefficients in the kernel</span>
<span class="w">  </span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="w"> </span><span class="n">buffDone</span><span class="p">,</span><span class="w"> </span><span class="n">krnlDone</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">total_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">load_filter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">total_size</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">load_filter</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueMigrateMemObjects</span><span class="p">({</span><span class="n">buffer_bloom_filter</span><span class="p">},</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffDone</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">wordWait</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">buffDone</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueTask</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wordWait</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">krnlDone</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">krnlWait</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">krnlDone</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>For each iteration, kernel arguments are set, and the commands to write the input buffer to the FPGA, execute the kernel, and read the results back to the host, are enqueued.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// Set Kernel arguments. Read, Enqueue Kernel and Write for each iteration</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">num_iter</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cl</span><span class="o">::</span><span class="n">Event</span><span class="w"> </span><span class="n">buffDone</span><span class="p">,</span><span class="w"> </span><span class="n">krnlDone</span><span class="p">,</span><span class="w"> </span><span class="n">flagDone</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">total_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subbuf_doc_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">uint</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">load_filter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">kernel</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">subbuf_inh_flags</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">kernel</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">subbuf_doc_words</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">kernel</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">total_size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">kernel</span><span class="p">.</span><span class="n">setArg</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">load_filter</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueMigrateMemObjects</span><span class="p">({</span><span class="n">subbuf_doc_words</span><span class="p">[</span><span class="n">i</span><span class="p">]},</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wordWait</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffDone</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">wordWait</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">buffDone</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueTask</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wordWait</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">krnlDone</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">krnlWait</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">krnlDone</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">enqueueMigrateMemObjects</span><span class="p">({</span><span class="n">subbuf_inh_flags</span><span class="p">[</span><span class="n">i</span><span class="p">]},</span><span class="w"> </span><span class="n">CL_MIGRATE_MEM_OBJECT_HOST</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">krnlWait</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flagDone</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">flagWait</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">flagDone</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>The host waits until the output of each iteration is read back to the host.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">//</span> <span class="n">Wait</span> <span class="n">until</span> <span class="nb">all</span> <span class="n">results</span> <span class="n">are</span> <span class="n">copied</span> <span class="n">back</span> <span class="n">to</span> <span class="n">the</span> <span class="n">host</span> <span class="n">before</span> <span class="n">doing</span> <span class="n">the</span> <span class="n">post</span><span class="o">-</span><span class="n">processing</span>
  <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">num_iter</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">flagWait</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">wait</span><span class="p">();</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>The code is generic enough to split the data into an arbitrary number of multiple buffers.</p>
</li>
</ol>
</div>
<div class="section" id="id2">
<h3>Run the Application Using the Bloom8x Kernel<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<p>In this step, you will explore the Bloom8x kernel with 100,000 documents split into 2, 4, 8, 16, 32, 64, and 128 chunks, and explore which option results in the best performance.</p>
<ol>
<li><p>Go to the <code class="docutils literal notranslate"><span class="pre">makefile</span></code> directory and run the <code class="docutils literal notranslate"><span class="pre">make</span></code> command.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cd $LAB_WORK_DIR/makefile; make run STEP=generic_buffer TARGET=hw PF=8 ITER=8 
</pre></div>
</div>
<p>The argument <code class="docutils literal notranslate"><span class="pre">ITER</span></code> controls how the input data is split and how many buffers are transferred from the host to the FPGA.</p>
</li>
<li><p>Run the same <code class="docutils literal notranslate"><span class="pre">make</span></code> command with the following <code class="docutils literal notranslate"><span class="pre">ITER</span></code> values: 1, 2, 4, 8, 16, 32, 64.</p></li>
<li><p>When you run application with multiple <code class="docutils literal notranslate"><span class="pre">ITER</span></code> values, you will overwrite the output files, such as the Profile Summary report and Timeline Trace. Use the following command to enable the archive_summary feature to save a unique archive file.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">archive_summary</span> <span class="o">../</span><span class="n">build</span><span class="o">/</span><span class="n">generic_buffer</span><span class="o">/</span><span class="n">kernel_8</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">runOnfpga_hw</span><span class="o">.</span><span class="n">xclbin</span><span class="o">.</span><span class="n">run_summary</span> <span class="n">runOnfpga_hw_8</span><span class="o">.</span><span class="n">xclbin</span><span class="o">.</span><span class="n">run_summary</span><span class="o">.</span><span class="n">archive</span>
</pre></div>
</div>
</li>
<li><p>Use the <code class="docutils literal notranslate"><span class="pre">vitis_analyzer</span></code> command to review and visualize all the reports.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bash</span> <span class="n">vitis_analyzer</span> <span class="n">runOnfpga_hw_8</span><span class="o">.</span><span class="n">xclbin</span><span class="o">.</span><span class="n">run_summary</span><span class="o">.</span><span class="n">archive</span> 
</pre></div>
</div>
<p>The following figure shows the plotted graph with the execution times of different <code class="docutils literal notranslate"><span class="pre">ITER</span></code> values varying with <code class="docutils literal notranslate"><span class="pre">ITER</span></code>.</p>
<p><img alt="../../../../_images/iter_generic.PNG" src="../../../../_images/iter_generic.PNG" /></p>
<p>From the graph, you can see that <code class="docutils literal notranslate"><span class="pre">ITER=8</span></code> gives the best performance. Your results might differ based on your CPU performance, load on the server, etc.</p>
<p>The following output with <code class="docutils literal notranslate"><span class="pre">ITER</span></code> 8 displays.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Processing</span> <span class="mf">1398.907</span> <span class="n">MBytes</span> <span class="n">of</span> <span class="n">data</span>
<span class="n">Generic_Buffer</span> <span class="p">:</span> <span class="n">Splitting</span> <span class="n">data</span> <span class="ow">in</span> <span class="mi">8</span> <span class="n">sub</span><span class="o">-</span><span class="n">buffers</span> <span class="n">of</span> <span class="mf">174.863</span> <span class="n">MBytes</span> <span class="k">for</span> <span class="n">FPGA</span> <span class="n">processing</span>

<span class="o">--------------------------------------------------------------------</span>
<span class="n">Executed</span> <span class="n">FPGA</span> <span class="n">accelerated</span> <span class="n">version</span>  <span class="o">|</span>   <span class="mf">664.6440</span> <span class="n">ms</span>   <span class="p">(</span> <span class="n">FPGA</span> <span class="mf">224.135</span> <span class="n">ms</span> <span class="p">)</span>
<span class="n">Executed</span> <span class="n">Software</span><span class="o">-</span><span class="n">Only</span> <span class="n">version</span>     <span class="o">|</span>   <span class="mf">3036.5323</span> <span class="n">ms</span>
<span class="o">--------------------------------------------------------------------</span>
<span class="n">Verification</span><span class="p">:</span> <span class="n">PASS</span>
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="id3">
<h3>Review Profile Report and Timeline Trace for the Bloom8x Kernel<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h3>
<ol>
<li><p>Run the following commands to view the Timeline Trace report with Bloom8x kernel.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>vitis_analyzer $LAB_WORK_DIR/build/generic_buffer/kernel_8/hw/runOnfpga_hw.xclbin.run_summary
</pre></div>
</div>
</li>
<li><p>Zoom in to display the Timeline Trace report.</p>
<p><img alt="../../../../_images/generic_buffer_timeline_trace.PNG" src="../../../../_images/generic_buffer_timeline_trace.PNG" /></p>
</li>
</ol>
<ul class="simple">
<li><p>As you can see from the report, the input buffer is split into eight sub buffers, and there are overlaps between read, compute, and write for all iterations. The total computation is divided in eight iterations, but seven of them are occur simultaneously with data transfers; therefore, only the last compute counts towards the total FPGA execution time. This is indicated by the two arrows on timeline trace</p></li>
<li><p>You can also see that after splitting the input data into multiple buffers, the total execution time on the FPGA improved from the previous steps, allowing additional overlap between the data transfer and compute.</p></li>
</ul>
<p>For your application, the most optimized configuration is:</p>
<ul class="simple">
<li><p>Bloom8x kernel with the words split in 8 sub-buffers (<code class="docutils literal notranslate"><span class="pre">ITER=8</span></code>).</p></li>
</ul>
</div>
</div>
<div class="section" id="overlap-between-the-host-cpu-and-fpga">
<h2>Overlap Between the Host CPU and FPGA<a class="headerlink" href="#overlap-between-the-host-cpu-and-fpga" title="Permalink to this heading">¶</a></h2>
<p>In the previous steps, you looked at optimizing the execution time of the FPGA by overlapping the data transfer from the host to FPGA and compute on the FPGA. After the FPGA compute is complete, the CPU computes the document scores based on the output from the FPGA. Until now, the FPGA processing and CPU post-processing executed sequentially.</p>
<p>If you look at the previous Timeline Trace reports, you can see red segments on the very first row that shows the OpenCL API Calls made by the host application. This indicates that the host is waiting, staying idle while the FPGA computes the hash and flags. In this step, you will overlap the FPGA processing with the CPU post-processing.</p>
<p>Because the total compute is split into multiple iterations, you can start post-processing on the host CPU after the corresponding iteration is complete, allowing the overlap between the CPU and FPGA processing. The performance increases because the CPU is also processing in parallel with the FPGA, which reduces the execution time.</p>
<div class="section" id="id4">
<h3>Host Code Modifications<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<ol>
<li><p>Open <code class="docutils literal notranslate"><span class="pre">run_sw_overlap.cpp</span></code> in <code class="docutils literal notranslate"><span class="pre">$LAB_WORK_DIR/reference_files</span></code> with a file editor.</p>
<p>Lines 134 through 171 are modified to optimize the host code such that CPU processing is overlapped with FPGA processing. It is explained in detail as follows.</p>
<p>The following variables are created to keep track of the words processed by the FPGA.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// Create variables to keep track of number of words needed by CPU to compute score and number of words processed by FPGA such that CPU processing can overlap with FPGA</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">curr_entry</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">inh_flags</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">  </span><span class="n">available</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">  </span><span class="n">needed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">  </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Block the host only if the hash function of the words are still not computed by FPGA, thereby allowing overlap between the CPU and FPGA processing.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">doc</span><span class="o">&lt;</span><span class="n">total_num_docs</span><span class="p">;</span><span class="n">doc</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">doc_sizes</span><span class="p">[</span><span class="n">doc</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Calculate size by needed by CPU for processing next document score</span>
<span class="w">    </span><span class="n">needed</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Check if flags processed by FPGA is greater than needed by CPU. Else, block CPU</span>
<span class="w">    </span><span class="c1">// Update the number of available words and sub-buffer count(iter)</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">needed</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">available</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">flagWait</span><span class="p">[</span><span class="n">iter</span><span class="p">].</span><span class="n">wait</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">available</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">subbuf_doc_info</span><span class="p">[</span><span class="n">iter</span><span class="p">].</span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">uint</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">iter</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">curr_entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_doc_words</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">inh_flags</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">output_inh_flags</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">inh_flags</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">frequency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr_entry</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x00ff</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">word_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr_entry</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">ans</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">profile_weights</span><span class="p">[</span><span class="n">word_id</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">frequency</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">profile_score</span><span class="p">[</span><span class="n">doc</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="id5">
<h3>Run the Application Using the Bloom8x Kernel<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h3>
<p>Go to the <code class="docutils literal notranslate"><span class="pre">makefile</span></code> directory, and run the <code class="docutils literal notranslate"><span class="pre">make</span></code> command.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cd $LAB_WORK_DIR/makefile; make run STEP=sw_overlap TARGET=hw PF=8 ITER=8
</pre></div>
</div>
<p>The following output displays.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">Processing</span> <span class="mf">1398.905</span> <span class="n">MBytes</span> <span class="n">of</span> <span class="n">data</span>
  <span class="n">Splitting</span> <span class="n">data</span> <span class="ow">in</span> <span class="mi">8</span> <span class="n">sub</span><span class="o">-</span><span class="n">buffers</span> <span class="n">of</span> <span class="mf">174.863</span> <span class="n">MBytes</span> <span class="k">for</span> <span class="n">FPGA</span> <span class="n">processing</span>
  <span class="o">--------------------------------------------------------------------</span>
  <span class="n">Executed</span> <span class="n">FPGA</span> <span class="n">accelerated</span> <span class="n">version</span>  <span class="o">|</span>   <span class="mf">427.1341</span> <span class="n">ms</span>   <span class="p">(</span> <span class="n">FPGA</span> <span class="mf">230.345</span> <span class="n">ms</span> <span class="p">)</span>
  <span class="n">Executed</span> <span class="n">Software</span><span class="o">-</span><span class="n">Only</span> <span class="n">version</span>     <span class="o">|</span>   <span class="mf">3057.6307</span> <span class="n">ms</span>
  <span class="o">--------------------------------------------------------------------</span>
  <span class="n">Verification</span><span class="p">:</span> <span class="n">PASS</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3>Review Profile Report and Timeline Trace for the Bloom8x Kernel<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h3>
<ol>
<li><p>Run the following commands to view the Timeline Trace with Bloom8x kernel.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>vitis_analyzer $LAB_WORK_DIR/build/sw_overlap/kernel_8/hw/runOnfpga_hw.xclbin.run_summary 
</pre></div>
</div>
</li>
<li><p>Zoom in to display the Timeline Trace report.</p>
<p><img alt="../../../../_images/sw_overlap_timeline_trace.PNG" src="../../../../_images/sw_overlap_timeline_trace.PNG" /></p>
<ul class="simple">
<li><p>As shown in <em>OpenCL API Calls</em> of the <em>Host</em> section, the red segments are shorter (indicated by red squares) in width which indicates that the processing time of the host CPU is now overlapping with the FPGA processing, which improved the overall application execution time. In the previous steps, the host remained completely idle until the FPGA finished all its processing.</p></li>
<li><p><em>Data Transfer -&gt; Write</em> of the Host section seems to have no gap. Kernel compute time of each invocation is smaller than the Host transfer.</p></li>
<li><p>Each Kernel compute and writing flags to DDR are overlapped with the next Host-&gt;
Device transfer.</p></li>
</ul>
</li>
</ol>
</div>
<div class="section" id="review-profile-summary-report-for-the-bloom8x-kernel">
<h3>Review Profile Summary Report for the Bloom8x Kernel<a class="headerlink" href="#review-profile-summary-report-for-the-bloom8x-kernel" title="Permalink to this heading">¶</a></h3>
<ol>
<li><p><em>Kernels &amp; Compute Unit:Kernel Execution</em> reports 168ms. This should be same as when Bloom8x kernel run with ITER=8.</p></li>
<li><p><em>Kernels &amp; Compute Unit: Compute Unit Stalls</em> section also confirms that “External Memory” stalls are about 20.045 ms compared to no “External Memory” stalls when single buffer was used. This will result in slower data transfer and kernel compute compared to single buffer run.</p>
<p><img alt="../../../../_images/sw_overlap_stalls.PNG" src="../../../../_images/sw_overlap_stalls.PNG" /></p>
</li>
<li><p><em>Host Data Transfer: Host Transfer</em> Host to Global Memory WRITE Transfer takes about 207.5 ms and Host to Global Memory READ Transfer takes about 36.4 ms</p>
<p><img alt="../../../../_images/sw_overlap_profile_host.PNG" src="../../../../_images/sw_overlap_profile_host.PNG" /></p>
</li>
</ol>
<ul>
<li><p><em>Kernels &amp; Compute Unit: Compute Unit Utilization</em> section shows that CU Utilization is about 71%. This is an important measure representing how much time CU was active over the Device execution time.</p>
<p><img alt="../../../../_images/sw_overlap_profile_CU_util.PNG" src="../../../../_images/sw_overlap_profile_CU_util.PNG" /></p>
</li>
</ul>
<p>In the next lab, you will compare the results for “Host Data Transfer Rates” and “CU Utilization”.</p>
</div>
<div class="section" id="throughput-achieved">
<h3>Throughput Achieved<a class="headerlink" href="#throughput-achieved" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>Based on the results, the throughput of the application is 1399 MB/427 ms = approx 3.27 GBs.` You have now approximately 7.2 times (=3057 ms/427 ms) the performance results compared to the software results.</p></li>
</ul>
</div>
<div class="section" id="opportunities-for-performance-improvements">
<h3>Opportunities for Performance Improvements<a class="headerlink" href="#opportunities-for-performance-improvements" title="Permalink to this heading">¶</a></h3>
<p>The host and kernel are trying to access the same DDR bank at the same time which resulted in an external memory stall of 20.045 ms. These accesses cause memory contention and limits the speed-up of application execution. In the next module, you will <a class="reference internal" href="6_using-multiple-ddr.html"><span class="doc">make use of additional bank</span></a> to minimize the memory contentions.</p>
<hr class="docutils" />
<p align="center" class="sphinxhide"><b><a href="/docs/vitis-getting-started/">Return to Getting Started Pathway</a> — <a href="./README.md">Return to Start of Tutorial</a></b></p><p align="center" class="sphinxhide"><sup>Copyright&copy; 2020 Xilinx</sup></p></div>
</div>
</div>


           </div>
          </div>
          
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
				  
				  <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, Xilinx, Inc. Xilinx is now a part of AMD.
      <span class="lastupdated">Last updated on August 5, 2022.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>