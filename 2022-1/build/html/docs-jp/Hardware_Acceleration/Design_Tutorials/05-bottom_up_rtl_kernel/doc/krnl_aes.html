<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" /><!-- OneTrust Cookies Consent Notice start for xilinx.github.io --><script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script><!-- OneTrust Cookies Consent Notice end for xilinx.github.io --><title>RTL カーネル: krnl_aes - Vitis™ チュートリアル 2022.1 の資料</title>
      <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/_static/custom.css" type="text/css" /><!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]--><script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"><a href="../../../../../index.html" class="icon icon-home">Vitis™ チュートリアル <img src="../../../../../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/> </a><div class="version">2022.1</div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">English</span></p><ul><li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/master/docs/index.html">Main</a></li></ul><p class="caption" role="heading"><span class="caption-text">入門</span></p><ul><li class="toctree-l1"><a class="reference internal" href="../../../../Getting_Started/Vitis-Getting-Started.html">概要</a></li></ul><p class="caption" role="heading"><span class="caption-text">アクセラレーション</span></p><ul><li class="toctree-l1"><a class="reference internal" href="../../../Hardware-Acceleration.html">ハードウェア アクセラレーション</a></li></ul><p class="caption" role="heading"><span class="caption-text">AI エンジン</span></p><ul><li class="toctree-l1"><a class="reference internal" href="../../../../AI_Engine_Development/AI_Engine_Development.html">AI エンジン開発</a></li></ul><p class="caption" role="heading"><span class="caption-text">プラットフォーム</span></p><ul><li class="toctree-l1"><a class="reference internal" href="../../../../Vitis_Platform_Creation/Vitis_Platform_Creation.html">Vitis プラットフォームの作成</a></li></ul><p class="caption" role="heading"><span class="caption-text">その他のバージョン</span></p><ul><li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2021-2/build/html/index.html">2021.2</a></li><li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2021-1/build/html/index.html">2021.1</a></li><li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-2/docs/build/html/index.html">2020.2</a></li><li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/Vitis-Tutorials/2020-1/docs/build/html/indexE.html">2020.1</a></li></ul></div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" ><i data-toggle="wy-nav-top" class="fa fa-bars"></i> <a href="../../../../../index.html">Vitis™ チュートリアル</a></nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation"><ul class="wy-breadcrumbs"><li><a href="../../../../../index.html" class="icon icon-home"></a>&raquo;</li> <li>RTL カーネル: krnl_aes</li><li class="wy-breadcrumbs-aside"><a href="../../../../../_sources/docs/Hardware_Acceleration/Design_Tutorials/05-bottom_up_rtl_kernel/doc/krnl_aes.md.txt" rel="nofollow">ページ ソースの表示</a></li></ul><hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="rtl-kernel-krnl-aes">
<h1>RTL カーネル: krnl_aes<a class="headerlink" href="#rtl-kernel-krnl-aes" title="Permalink to this heading">¶</a></h1>
<div class="section" id="introduction">
<h2>入門チュートリアル<a class="headerlink" href="#入門チュートリアル" title="Permalink to this heading"></a></h2>
<p>この部分のチュートリアルでは、<a class="reference internal" href="aes.html"><span class="doc">「RTL モジュール: AES」</span></a> で作成した AES モジュールを使用します。RTL ロジックを追加し、Vivado® IP および Vitis カーネル (XO) ファイルにパックします。この Vitis™ カーネル ファイルを Vitis の v++ フローで直接使用すると、XCLBIN オーバーレイ ファイルを作成できます。また、XRT ライブラリを使用すると、ホストとカーネル間のカーネル制御とデータ転送ができます。</p>
</div>
<div class="section" id="kernel-features">
<h2>カーネルの機能<a class="headerlink" href="#kernel-features" title="Permalink to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> カーネルには 4 つの AES モジュールが含まれており、それぞれが AXI ストリーム スレーブおよびマスター ポートの外部に接続されています。また、カーネル制御用の AXI スレーブ ポートもあります。デザインを簡素化するために、すべての AES モジュールで同じ設定 (暗号化/復号化モード、キー長、およびキー値) が使用されます。</p>
<p><code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> は実際には内部で 2 つのクロックを使用します。1 つは外部 AXI ポート用、もう 1 つは内部 AXI ポートおよび AES コア用です。AES コアは、プラットフォームの AXI インターコネクトよりも高い周波数で動作します。</p>
<p>カーネル用の周波数の高いクロックを取得するには、2 つの方法があります。1 つ目は、提供されたセカンダリ プラットフォーム クロック、つまり <code class="docutils literal notranslate"><span class="pre">ap_clk_2</span></code> ポートを使用する方法です。Alveo™ データセンター アクセラレータ カードでは、ターゲット プラットフォームがユーザー カーネル用の複数のクロックを提供しています。たとえば、Alveo U200 <code class="docutils literal notranslate"><span class="pre">xilinx_u200_xdma_201830_2</span></code> プラットフォームでは、<code class="docutils literal notranslate"><span class="pre">ap_clk</span></code> および <code class="docutils literal notranslate"><span class="pre">ap_clk_2</span></code> という 2 つのシステム クロック (デフォルト周波数はそれぞれ 300MHz と 500MHz) が提供されいます。周波数は、Vitis の v++ リンク プロセスで設定できます。<code class="docutils literal notranslate"><span class="pre">ap_clk_2</span></code> は、Alveo プラットフォームのスタティック領域にあるスタンドアロン MMCM によって生成されます。追加クロックを取得する 2 つ目の方法では、RTL カーネル内で MMCM を手動でインスタンシエートします。これにより、一部の特定の要件の柔軟性が向上する場合があります。</p>
<p>ここで提供されるデザイン例では、2 つ目の方法を使用して必要なクロックを生成します。<code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> カーネルには、プラットフォームが提供する標準の 300MHz 入力クロックから 400MHz クロックを生成するようにカスタマイズされた MMCM モジュールが含まれています。</p>
<p>UltraScale+™ Alveo ターゲット プラットフォームは、スタティック領域とダイナミック領域に分割されます。ダイナミック領域内にカスタマがインスタンシエートした MMCM は、プラットフォーム バス クロックの駆動に使用される可能性のあるスタティック領域内の MMCM で駆動される可能性があります。これは通常、大きなクロック スキューを発生させ、同期デザインがタイミングを満たしにくくします。タイミング クロージャを達成しやすくするには、カスタマ MMCM で駆動されるこれらのモジュールが、プラットフォーム バス クロックに対して非同期モードで動作する必要があります。このデザイン例では、AXI スレーブ制御モジュールと 4 つの AES エンジンはすべて 400MHz クロック ドメインで動作し、カーネルは 300MHz 標準プラットフォーム クロック ドメインに接続されます。このため、全部で 9 つの AXI/AXIS クロック コンバーター IP がカーネルの最上位レベルで使用されます。1 つは AXI 制御スレーブ用の AXI クロック コンバーター、4 つは AXIS スレーブ ポート用の AXIS クロック コンバーター、4 つは AXIS マスター ポート用の AXIS クロック コンバーターです。</p>
<p>次は、krnl_aes カーネルのブロック図です。</p>
<div align="center"><img src="./images/krnl_aes.svg" alt="krnl_aes Diagram" > </div><br/><p>XRT でサポートされている Vitis アクセラレーション アプリケーションには、ap_ctrl_none、ap_ctrl_hs、および ap_ctrl_chain の 3 つのカーネル実行モデルがあります。詳細は、<a class="reference external" href="https://japan.xilinx.com/html_docs/xilinx2020_2/vitis_doc/managing_interface_synthesis.html?hl=ap_ctrl_chain#qls1539734256651__ae476299">UG1416</a> の<a class="reference external" href="https://xilinx.github.io/XRT/master/html/xrt_kernel_executions.html">「サポートされるカーネル実行モデル」</a>を参照してください。この RTL カーネル krnl_aes は ap_ctrl_none モードと ap_ctrl_hs モードの混合です。ap_ctrl_hs は AES キー拡張操作に使用されるので、ホストは AES キー拡張操作の終了を待って開始します。ap_ctrl_none は、一般的な AES 暗号化/復号化操作に使用されるので、カーネルが AXI ストリーム スレーブ ポートから入力データを受信するとすぐに、暗号化/復号化操作を自動的に開始および終了し、出力データを AXI ストリーム マスター ポートに送信します。</p>
<p>krnl_aes では、ap_ctrl_hs モードに次の制御信号波形がインプリメントされます。XRT は ap_start 信号をアサートしてカーネル実行を開始します。ap_start は ap_ready 信号によって High に維持され、ディアサートされます。ap_ready は実際には ap_done 信号のコピーです。最後に、ap_done が AXI スレーブ ポートの読み出し制御レジスタ操作で一掃されます。XRT スケジューラは、ap_start のステータスに応じて ap_start をアサートするタイミングを実際に決定します。つまり、XRT で ap_start がディアサートされていることが検出されると、カーネルで新しい ap_start 要求を受信する準備ができたと認識されます。</p>
<div align="center"><img src="./images/ap_ctrl_hs.svg" alt="ap_ctrl_hs mode" > </div><br/><p>次の表に、AXI スレーブ ポートに含まれるすべての制御レジスタとカーネル引数を示します。このカーネルでは、割り込みはサポートされていません。</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>名前</th>
<th>アドレス オフセット</th>
<th>幅 (ビット)</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CTRL</td>
<td>0x000</td>
<td>5</td>
<td>制御信号。<br>ビット 0  - ap_start <br>ビット 1  - ap_done <br>ビット 2  - ap_idle <br>ビット 3  - ap_ready、ap_ctrl_hs モードの ap_done のコピー バージョン<br>ビット 4  - ap_continue、ap_ctrl_hs モードでは使用なし</td>
</tr>
<tr>
<td>MODE</td>
<td>0x010</td>
<td>1</td>
<td>カーネル暗号モード:<br> 0 - 復号化 <br> 1 - 暗号化</td>
</tr>
<tr>
<td>KEY_LEN</td>
<td>0x018</td>
<td>2</td>
<td>AES キー長:<br>2&apos;b00 = 128 ビット<br>2&apos;b01 = 192 ビット<br>2&apos;b10 = 256 ビット</td>
</tr>
<tr>
<td>STATUS</td>
<td>0x020</td>
<td>4</td>
<td>4 つの AES エンジンのステータス：<br>0 - アイドル<br>1 - ビジー</td>
</tr>
<tr>
<td>KEY_W7</td>
<td>0x028</td>
<td>32</td>
<td>AES キーのワード 7</td>
</tr>
<tr>
<td>KEY_W6</td>
<td>0x030</td>
<td>32</td>
<td>AES キーのワード 6</td>
</tr>
<tr>
<td>KEY_W5</td>
<td>0x038</td>
<td>32</td>
<td>AES キーのワード 5</td>
</tr>
<tr>
<td>KEY_W4</td>
<td>0x040</td>
<td>32</td>
<td>AES キーのワード 4</td>
</tr>
<tr>
<td>KEY_W3</td>
<td>0x048</td>
<td>32</td>
<td>AES キーのワード 3。キーの長さが 128 の場合、このワードは使用されません。</td>
</tr>
<tr>
<td>KEY_W2</td>
<td>0x050</td>
<td>32</td>
<td>AES キーのワード 2。キーの長さが 128 の場合、このワードは使用されません。</td>
</tr>
<tr>
<td>KEY_W1</td>
<td>0x058</td>
<td>32</td>
<td>AES キーのワード 1。キーの長さが 128/192 ビットの場合、このワードは使用されません。</td>
</tr>
<tr>
<td>KEY_W0</td>
<td>0x060</td>
<td>32</td>
<td>AES キーのワード 0。キーの長さが 128/192 ビットの場合、このワードは使用されません。</td>
</tr>
</tbody>
</table></div>
<div class="section" id="ip-generation">
<h2>IP の生成<a class="headerlink" href="#ip-generation" title="Permalink to this heading">¶</a></h2>
<p>このデザイン例では、3 種類のデザイン IP と 2 種類の Verification IP を使用しています。</p><ul class="simple"> <li><p>クロック ジェネレーター MMCM</p></li> <li><p>AXI クロック コンバーター</p></li> <li><p>AXI ストリーム クロック コンバーター</p></li> <li><p>AXI マスター VIP</p></li> <li><p>AXIS マスター VIP</p></li> <li><p>AXIS スレーブ VIP</p></li> </ul>
<p>これらの IP はすべて Tcl スクリプト <strong>~/krnl_aes/gen_ip.tcl</strong> によって生成されます。このスクリプトは非プロジェクト モードで実行するもので、主に 3 つの Tcl コマンド (create_ip、set_property および generate_target) を使用して IP 生成を終了します。詳細は、これらのスクリプトおよび関連する IP の資料を参照してください。</p>
</div>
<div class="section" id="pack-the-design-into-vivado-ip-and-vitis-kernel">
<h2>Vivado IP および Vitis カーネルへのデザインのパック<a class="headerlink" href="#pack-the-design-into-vivado-ip-and-vitis-kernel" title="Permalink to this heading">¶</a></h2>
<p>Vitis の RTL カーネル デザインの重要な手順の 1 つは、RTL デザインを Vitis カーネル ファイル (XO) にパッケージすることです。GUI バージョンの RTL カーネル ウィザードを使用すると、Vitis カーネルを作成できます。また、Vivado の GUI バージョンの IP パッケージャーを使用してデザインを Vivado IP にパッケージし、XO ファイルを生成することもできます。Vivado は、Vitis カーネル生成用のコマンド ライン フローも提供し、GUI バージョンと同じジョブを提供します。このチュートリアルでは、Vivado Tcl コマンドを使用して、バッチ モードで krnl_aes IP パッケージおよび XO ファイルを生成します。このデザインの完全なカーネル生成スクリプトは <strong>~/krnl_aes/pack_kernel.tcl</strong> にあります。主な手順は以下のとおりです。詳細は、スクリプトを参照してください。実際には、スクリプトの各手順は GUI ツールに対応します。GUI バージョンの IP パッケージング ツールの使用については、<a class="reference external" href="https://docs.xilinx.com/r/2021.1-Japanese/ug1393-vitis-application-acceleration/RTL-%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB">「RTL カーネル」</a>を参照してください。</p>
<div class="section" id="step-1-create-vivado-project-and-add-design-sources">
<h3>手順 1: Vivado プロジェクトの作成およびデザイン ソースの追加<a class="headerlink" href="#step-1-create-vivado-project-and-add-design-sources" title="Permalink to this heading">¶</a></h3>
<p>まず、ソース ファイルを含む Vivado プロジェクトを作成する必要があります。スクリプトは、Tcl コマンド create_project、add_files および update_compiler_order を使用してこの手順を終了します。すべての RTL ソース コード、生成された IP ファイル (XCI ファイル)、および XDC ファイルを、新しく作成されたプロジェクトに追加する必要があります。</p>
<p>最後に、ipx::package_project Tcl コマンドを使用して、IP パッケージング プロセスを初期化します。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>create_project krnl_aes ./krnl_aes
add_files -norecurse <span class="o">{</span>
        ../rtl/aes_wrapper.sv ... ...              <span class="se">\</span>
        ../ip_generation/clk_gen/clk_gen.xci      <span class="se">\</span>
        ../ip_generation/axi_clock_converter/axi_clock_converter.xci <span class="se">\</span>
        ../ip_generation/axis_clock_converter/axis_clock_converter.xci <span class="se">\</span>
        ../krnl_aes.xdc                     <span class="se">\</span>
       <span class="o">}</span>
update_compile_order -fileset sources_1
ipx::package_project -root_dir ./krnl_aes_ip -vendor xilinx.com -library user -taxonomy /UserIP -import_files -set_current <span class="nb">true</span>
</pre></div>
</div>
<p>この手順では、「WARNING: [IP_Flow 19-5101] Packaging a component with a SystemVerilog top file is not fully supported.<em></em>「Please refer to UG1118 &lsquo;Creating and Packaging Custom IP&rsquo;」のような警告情報が表示されることもあります。現在のところ、Vitis ツール チェーンでは、最上位モジュールのポート定義を従来の Verilog 形式にする必要があります。最上位モジュール krnl_aes.sv は SystemVerilog 構文 (SystemVerilog インターフェイス オブジェクト) をいくつか使用していますが、従来の Verilog 形式のポート定義を使用するので、この警告は無視しても問題ありません。</p>
</div>
<div class="section" id="step-2-infer-clock-reset-axi-interfaces-and-associate-them-with-clock">
<h3>手順 2: クロック、リセット、AXI インターフェイスの推論およびクロックとの関連付け<a class="headerlink" href="#step-2-infer-clock-reset-axi-interfaces-and-associate-them-with-clock" title="Permalink to this heading">¶</a></h3>
<p>ここでは、最初に ipx::infer_bus_interface コマンドを使用して ap_clk および ap_rst_n を AXI バス信号として推論します。通常、RTL カーネルで使用されるクロックが ap_clk だけの場合、このコマンドは省略できます。デザインでより多くのクロック (ap_clk_2、ap_clk_3 など) を使用する場合は、ipx::infer_bus_interface コマンドを使用して、ポートを明示的に推論する必要があります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ipx</span><span class="p">::</span><span class="n">infer_bus_interface</span> <span class="n">ap_clk</span> <span class="n">xilinx</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="n">signal</span><span class="p">:</span><span class="n">clock_rtl</span><span class="p">:</span><span class="mf">1.0</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">infer_bus_interface</span> <span class="n">ap_rst_n</span> <span class="n">xilinx</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="n">signal</span><span class="p">:</span><span class="n">reset_rtl</span><span class="p">:</span><span class="mf">1.0</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
</pre></div>
</div>
<p>すべての AXI インターフェイスは自動的に推論されます。このデザインでは、これらの AXI ポートには、制御 AXI スレーブ ポート (s_axi_control) が 1 つ、AXIS スレーブ ポート (axis_slv0~3) が 4 つ、AXIS マスター ポート (axis_mst0~3) が 4 つ含まれます。</p>
<p>次に、ipx::associate_bus_interfaces コマンドを使用して、自動的に推論される AXI インターフェイスおよびリセット信号 ap_clk に関連付けます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ipx</span><span class="p">::</span><span class="n">associate_bus_interfaces</span> <span class="o">-</span><span class="n">busif</span> <span class="n">s_axi_control</span>  <span class="o">-</span><span class="n">clock</span> <span class="n">ap_clk</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">associate_bus_interfaces</span> <span class="o">-</span><span class="n">busif</span> <span class="n">axis_mst0</span>      <span class="o">-</span><span class="n">clock</span> <span class="n">ap_clk</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
  <span class="o">...</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">associate_bus_interfaces</span> <span class="o">-</span><span class="n">busif</span> <span class="n">axis_slv0</span>      <span class="o">-</span><span class="n">clock</span> <span class="n">ap_clk</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
  <span class="o">...</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">associate_bus_interfaces</span> <span class="o">-</span><span class="n">clock</span> <span class="n">ap_clk</span> <span class="o">-</span><span class="n">reset</span> <span class="n">ap_rst_n</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="step-3-set-the-definition-of-axi-control-slave-registers-including-ctrl-and-user-kernel-arguments">
<h3>手順 3: CTRL やユーザー カーネル引数を含む AXI 制御スレーブ レジスタの定義の設定<a class="headerlink" href="#step-3-set-the-definition-of-axi-control-slave-registers-including-ctrl-and-user-kernel-arguments" title="Permalink to this heading">¶</a></h3>
<p>ここでは、ipx::add_register コマンドを使用して、レジスタを推論される s_axi_control インターフェイスに追加し、set_property コマンドを使用してレジスタのプロパティ (たとえば KEY_LEN) を設定します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ipx</span><span class="p">::</span><span class="n">add_register</span> <span class="n">KEY_LEN</span>   <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_address_blocks</span> <span class="n">reg0</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_memory_maps</span> <span class="n">s_axi_control</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]]]</span>
<span class="n">set_property</span> <span class="n">description</span>    <span class="p">{</span><span class="n">AES</span> <span class="n">key</span> <span class="n">length</span><span class="p">}</span>    <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_registers</span> <span class="n">KEY_LEN</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_address_blocks</span> <span class="n">reg0</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_memory_maps</span> <span class="n">s_axi_control</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]]]]</span>
<span class="n">set_property</span> <span class="n">address_offset</span> <span class="p">{</span><span class="mh">0x018</span><span class="p">}</span>             <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_registers</span> <span class="n">KEY_LEN</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_address_blocks</span> <span class="n">reg0</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_memory_maps</span> <span class="n">s_axi_control</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]]]]</span>
<span class="n">set_property</span> <span class="n">size</span>           <span class="p">{</span><span class="mi">32</span><span class="p">}</span>                <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_registers</span> <span class="n">KEY_LEN</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_address_blocks</span> <span class="n">reg0</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">get_memory_maps</span> <span class="n">s_axi_control</span> <span class="o">-</span><span class="n">of_objects</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]]]]</span>
</pre></div>
</div>
<p>KEY_LEN はカーネル引数名、AES key length はレジスタの説明、0x018 はレジスタのアドレス オフセット、32 はレジスタのデータ幅 (スカラー カーネル引数はすべて 32 ビット幅にする必要あり) です。</p>
<p>提供される Tcl スクリプトからは、前の表で定義されたすべてのレジスタが追加され、正しく定義されていることがわかります。</p>
<p>krnl_aes カーネルには AXI マスターポートがないので、設定する必要はありません。AXI マスターの設定については、次の krnl_cbc カーネル部分を参照してください。</p>
</div>
<div class="section" id="step-4-package-vivado-ip-and-generate-vitis-kernel-file">
<h3>手順 4: Vivado IP のパッケージおよび Vitis カーネル ファイルの生成<a class="headerlink" href="#step-4-package-vivado-ip-and-generate-vitis-kernel-file" title="Permalink to this heading">¶</a></h3>
<p>ここでは、set_property コマンドを使用して、2 つの必須プロパティ (sdx_kernel と sdx_kernel_type) を設定します。次に、ipx::update_source_project_archive および ipx::save_core コマンドを実行して、Vivado プロジェクトを Vivado IP にパッケージします。最後に package_xo コマンドを使用して Vitis XO ファイルを生成します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">set_property</span> <span class="n">sdx_kernel</span> <span class="n">true</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">set_property</span> <span class="n">sdx_kernel_type</span> <span class="n">rtl</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">update_source_project_archive</span> <span class="o">-</span><span class="n">component</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">ipx</span><span class="p">::</span><span class="n">save_core</span> <span class="p">[</span><span class="n">ipx</span><span class="p">::</span><span class="n">current_core</span><span class="p">]</span>
<span class="n">package_xo</span> <span class="o">-</span><span class="n">force</span> <span class="o">-</span><span class="n">xo_path</span> <span class="o">../</span><span class="n">krnl_aes</span><span class="o">.</span><span class="n">xo</span> <span class="o">-</span><span class="n">kernel_name</span> <span class="n">krnl_aes</span> <span class="o">-</span><span class="n">ctrl_protocol</span> <span class="n">ap_ctrl_hs</span> <span class="o">-</span><span class="n">ip_directory</span> <span class="o">./</span><span class="n">krnl_aes_ip</span> <span class="o">-</span><span class="n">output_kernel_xml</span> <span class="o">../</span><span class="n">krnl_aes</span><span class="o">.</span><span class="n">xml</span>
</pre></div>
</div>
<p>上記の package_xo コマンドの使用方法では、カーネル記述 XML ファイルを自動的に生成するようにツールを設定しています。手動で作成する必要はありません。Vitis 対応の Vivado IP が存在し、そこから XO ファイルを生成する必要がある場合は、カーネル XML ファイルを手動で作成し、次のようにコマンドで指定することもできます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">package_xo</span> <span class="o">-</span><span class="n">xo_path</span> <span class="o">../</span><span class="n">krnl_aes</span><span class="o">.</span><span class="n">xo</span> <span class="o">-</span><span class="n">kernel_name</span> <span class="n">krnl_aes</span> <span class="o">-</span><span class="n">ip_directory</span> <span class="o">./</span><span class="n">krnl_aes_ip</span> <span class="o">-</span><span class="n">kernel_xml</span> <span class="o">../</span><span class="n">krnl_aes</span><span class="o">.</span><span class="n">xml</span>
</pre></div>
</div>
<p>In this way, the kernel execution model is specified in the XML file with <em>hwControlProtocol</em> property instead of in <em>package_xo</em> command line option.</p>
</div>
</div>
<p>この場合、カーネル実行モデルは package_xo コマンド ライン オプションではなく、hwControlProtocol プロパティを使用して XML ファイルで指定します。</p>
</div>
</div>
<div class="section" id="testbench">
<h2>テストベンチ<a class="headerlink" href="#testbench" title="Permalink to this heading">¶</a></h2>
<p>ザイリンクス AXI VIP を使用した krnl_aes モジュール用のシンプルな SystemVerilog テストベンチが提供されています。テストベンチ ソースは <strong>~/krnl_aes/tbench</strong> ディレクトリにあります。krnl_aes に 4 つの完全に同一の AES エンジンがあるので、4 つのエンジンのうち 2 つだけをテストします。2 つの AXI ストリーム マスター VIP を使用して入力データをカーネルに送信し、2 つの AXI ストリーム スレーブ VIP を使用してカーネルから出力データを受信します。また、AXI マスターは、AES キー拡張操作用にカーネル引数を設定し、ap_ctrl_hs の方法でカーネル実行を制御するために使用されます。AXI VIP をカーネルとのやり取りに使用する方法の詳細は、<strong>tb_krnl_aes.sv</strong> ファイルを参照してください。</p>
<p>テストベンチへの入力ランダム データは Perl スクリプト <strong>~/common/ plain_gen.pl</strong> によって生成され、出力チェック用の基準データは OpenSSL ツールによって生成されます。シェル スクリプト <strong>~/krnl_aes/runsim_krnl_aes_xsim.sh</strong> は、入力スティミュラス、出力基準を生成し、Vivado XSim でシミュレーションを実行するために使用されます。</p>
</div>
<div class="section" id="kernel-test-system-and-overlay-xclbin-generation">
<h2>カーネル テスト システムとオーバーレイ (XCLBIN) の生成<a class="headerlink" href="#kernel-test-system-and-overlay-xclbin-generation" title="Permalink to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> のテスト システム オーバーレイを構築するには、<code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> とデータをやり取りするのに AXI ストリーム マスターおよび AXI ストリーム スレーブが必要です。これには、メモリ マップされた単純な AXI から AXIS へのカーネルと、HLS C 言語での AXIS から AXI へのメモリ マップされたカーネルを記述します。これらは <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/hls</span></code> ディレクトリにあり、それぞれ <code class="docutils literal notranslate"><span class="pre">strm_issue.cpp</span></code> および <code class="docutils literal notranslate"><span class="pre">strm_dump.cpp</span></code> と呼ばれます。</p>
<p>これら 2 つのカーネルの HLS C インプリメンテーションは次のようになります。<code class="docutils literal notranslate"><span class="pre">j</span></code> 変数を含む for ループはエンディアン変換用です。入力/出力データは 128 ビットのデータ幅の AXI バスを介してリトル エンディアンとして転送されます。この 128 ビットのデータはビッグ エンディアンの積分ワードとみなされます。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#define PTR_WIDTH 128</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">strm_issue</span><span class="w"> </span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">data_output</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">data_input</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">byte_size</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">byte_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">PTR_WIDTH</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// clang-format off</span>
<span class="w">    </span><span class="cp">#pragma HLS PIPELINE II = 1</span>
<span class="w">    </span><span class="c1">// clang-format on</span>
<span class="w">        </span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data_in</span><span class="p">,</span><span class="w"> </span><span class="n">data_out</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">data_in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_input</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">PTR_WIDTH</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">data_out</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_in</span><span class="p">.</span><span class="n">range</span><span class="p">((</span><span class="n">PTR_WIDTH</span><span class="o">/</span><span class="mi">8-1</span><span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">PTR_WIDTH</span><span class="o">/</span><span class="mi">8-1</span><span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">temp</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_out</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">data_output</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">strm_dump</span><span class="w"> </span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">data_input</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">data_output</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">byte_size</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">byte_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">PTR_WIDTH</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// clang-format off</span>
<span class="w">    </span><span class="cp">#pragma HLS PIPELINE II = 1</span>
<span class="w">    </span><span class="c1">// clang-format on</span>
<span class="w">        </span><span class="n">ap_axiu</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_input</span><span class="p">.</span><span class="n">read</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data_in</span><span class="p">,</span><span class="w"> </span><span class="n">data_out</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">data_in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">.</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">PTR_WIDTH</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">data_out</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_in</span><span class="p">.</span><span class="n">range</span><span class="p">((</span><span class="n">PTR_WIDTH</span><span class="o">/</span><span class="mi">8-1</span><span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">PTR_WIDTH</span><span class="o">/</span><span class="mi">8-1</span><span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w">            </span>
<span class="w">        </span><span class="n">data_output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_out</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w">          </span>
</pre></div>
</div>
<p>合計で 4 つの <code class="docutils literal notranslate"><span class="pre">strm_issue</span></code> と 4 つの <code class="docutils literal notranslate"><span class="pre">strm_dump</span></code> カーネルがテスト システムの <code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> に統合されて、リンク操作は <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/Makefile</span></code> に記述されています。<code class="docutils literal notranslate"><span class="pre">~/krnl_aes/krnl_aes_test.cfg</span></code> ファイルには、このデザインに必要な Vitis リンク オプションがあります。</p>
</div>
<div class="section" id="host-programming">
<h2>ホスト プログラミング<a class="headerlink" href="#host-programming" title="Permalink to this heading">¶</a></h2>
<p>ホスト プログラミングでは、XRT ネイティブ C++ API を使用して、FPGA でのカーネル実行を制御できます。XRT ネイティブ API は、非常にわかりやすく使いやすいものです。特にホスト カーネル間の頻繁なやり取りを必要とする場合に、XRT OpenCL よりも効率が上がります。XRT ネイティブ API の詳細は、<a class="reference external" href="https://xilinx.github.io/XRT/master/html/xrt_native_apis.html">「XRT ネイティブ API」</a>を参照 してください。</p>
<p>ホスト プログラムは、ランダム データをプレーン入力として生成し、OpenSSL AES API を使用して基準暗号データを生成します。また、ハードウェア エミュレーション (<code class="docutils literal notranslate"><span class="pre">hw_emu</span></code>) フローもサポートし、<code class="docutils literal notranslate"><span class="pre">hw</span></code> または <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code> モードの正しい XCLBIN ファイルを選択します。</p>
<p>ホスト プログラムは、<code class="docutils literal notranslate"><span class="pre">run.start()</span></code> 関数の後に <code class="docutils literal notranslate"><span class="pre">run.wait()</span></code> 関数を 1 つのスレッドで使用します。これは、ap_ctrl_hs 実行モデルの一般的な使用方法です。</p>
<p><code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> カーネルが暗号化モードから復号化モードに移行する際には、<code class="docutils literal notranslate"><span class="pre">MODE</span></code> カーネル引数を使用してカーネルの機能を変更する必要があります。レジスタをアップデートするには、次の 2 つの方法があります。</p>
<ol class="simple"><li><p>下位レベルの <code class="docutils literal notranslate"><span class="pre">kernel.write_register()</span></code> API を使用</p></li> <li><p>高位レベルの <code class="docutils literal notranslate"><span class="pre">run.set_arg()</span></code> API を使用してから、<code class="docutils literal notranslate"><span class="pre">run.start()</span></code> を使用</p></li></ol>
<p>2 つ目の方法では、<code class="docutils literal notranslate"><span class="pre">run.set_arg()</span></code> 関数は<code class="docutils literal notranslate"><span class="pre">run.start()</span></code> 関数が呼び出されるまで有効になりませんので、レジスタの書き込み操作を実行するには、<code class="docutils literal notranslate"><span class="pre">run.start()</span></code> を実行する必要があります。キー拡張操作を再度実行する必要はなく、データ暗号化/復号化操作用のカーネルは <code class="docutils literal notranslate"><span class="pre">ap_ctrl_none</span></code> モードで動作します。</p>
<p>次に、この 2 つの方法のコード部分を示します。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// Method 1 to configure krnl_aes to decryption mode</span>
<span class="c1">//   use run instance to set kernel argument. The kernel register will not be updated until run()</span>
<span class="w">  </span><span class="n">run_key_exp</span><span class="p">.</span><span class="n">set_arg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="w">                       </span><span class="c1">// index for argument MODE is 0</span>
<span class="w">  </span><span class="n">run_key_exp</span><span class="p">.</span><span class="n">start</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">run_key_exp</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span><span class="w"></span>

<span class="c1">// Method 2 to configrue krnl_aes to decryption mode</span>
<span class="c1">//   use kernel write_register() to access the register directly</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">reg_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_krnl_aes</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">     </span><span class="c1">// reg_offset = 0x10 for krnl_aes kernel register MODE</span>
<span class="w">  </span><span class="n">kernel_krnl_aes</span><span class="p">.</span><span class="n">write_register</span><span class="p">(</span><span class="n">reg_offset</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// set MODE = 0</span>
</pre></div>
</div>
</div>
<div class="section" id="tutorial-usage">
<h2>チュートリアルの使用方法<a class="headerlink" href="#tutorial-usage" title="Permalink to this heading">¶</a></h2>
<div class="section" id="before-you-begin">
<h3>開始前の確認事項<a class="headerlink" href="#before-you-begin" title="Permalink to this heading">¶</a></h3>
<p>このチュートリアルでは、<code class="docutils literal notranslate"><span class="pre">~/krnl_aes</span></code> ディレクトリ内のファイルを使用します。</p>
<p>このチュートリアルでのホスト プログラムの実行を除くすべての手順は、GNU Make によって終了します。このデザイン例では、4 つの Alveo カード (U200、U250、U50、U280) がサポートされています。また、使用する Alveo カードに該当する行のコメント文字を解除して、各カードの <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/Makefile</span></code> を変更する必要があります。</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span> <span class="m">41</span> <span class="c1"># PART setting: uncomment the line matching your Alveo card</span>
 <span class="m">42</span> PART :<span class="o">=</span> xcu200-fsgd2104-2-e
 <span class="m">43</span> <span class="c1">#PART := cu250-figd2104-2L-e</span>
 <span class="m">44</span> <span class="c1">#PART := xcu50-fsvh2104-2-e</span>
 <span class="m">45</span> <span class="c1">#PART := xcu280-fsvh2892-2L-e</span>
 <span class="m">46</span>
 <span class="m">47</span> <span class="c1"># PLATFORM setting: uncomment the lin matching your Alveo card</span>
 <span class="m">48</span> PLATFORM :<span class="o">=</span> xilinx_u200_xdma_201830_2
 <span class="m">49</span> <span class="c1">#PLATFORM := xilinx_u250_xdma_201830_2</span>
 <span class="m">50</span> <span class="c1">#PLATFORM := xilinx_u50_gen3x16_xdma_201920_3</span>
 <span class="m">51</span> <span class="c1">#PLATFORM := xilinx_u280_xdma_201920_3</span>
</pre></div>
</div>
<p>または、この変更をせずに、コマンド ライン オプションを使用してデフォルト設定を上書きすることもできます。次の手順では、例として U50 カードの make ツールを使用します。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>make xxx <span class="nv">PART</span><span class="o">=</span>xcu50-fsvh2104-2-e <span class="nv">PLATFORM</span><span class="o">=</span>xilinx_u50_gen3x16_xdma_201920_3
</pre></div>
</div>
<p>開始する前に、XRT および Vitis インストール パスで設定スクリプトを読み込んでいることを確認してください。次に例を示します。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">source</span> /opt/xilinx/xrt/setup.sh
<span class="nb">source</span> /tools/Xilinx/Vitis/2020.2/settings64.sh
</pre></div>
</div>
</div>
<div class="section" id="tutorial-steps">
<h3>チュートリアルの手順<a class="headerlink" href="#tutorial-steps" title="Permalink to this heading">¶</a></h3>
<div class="section" id="generate-ips">
<h4>1.IP の生成<a class="headerlink" href="#generate-ips" title="Permalink to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">gen_ip</span></pre></div>
</div>
<p>これにより、Vivado がバッチ モードで起動し、<code class="docutils literal notranslate"><span class="pre">~/krnl_aes/gen_ip.tcl</span></code> が呼び出されて、必要なすべてのデザイン IP と Verification IP が生成されます。</p>
</div>
<div class="section" id="run-standalone-simulation">
<h4>2.スタンドアロン シミュレーションの実行<a class="headerlink" href="#run-standalone-simulation" title="Permalink to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">runsim</span></pre></div>
</div>
<p>これにより、<code class="docutils literal notranslate"><span class="pre">~/krnl_aes/runsim_krnl_aes_xsim.sh</span></code> が呼び出され、Vivado XSim でシミュレーションが実行されます。</p>
</div>
<div class="section" id="package-vivado-ip-and-generate-vitis-kernel-file">
<h4>3.Vivado IP のパッケージと Vitis カーネル ファイルの生成<a class="headerlink" href="#package-vivado-ip-and-generate-vitis-kernel-file" title="Permalink to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">pack_kernel</span></pre></div>
</div>
<p>これにより Vivado がバッチ モードで起動し、<code class="docutils literal notranslate"><span class="pre">~/krnl_aes/pack_kernel.tcl</span></code> が呼び出されて、RTL ソース、生成された IP XCI ファイル、および XDC ファイルが Vivado IP にパッケージされます。この後、Vitis カーネル ファイル <code class="docutils literal notranslate"><span class="pre">~/krnl_aes/krnl_aes.xo</span></code> が生成されます。</p>
</div>
<div class="section" id="build-kernel-testing-system-overlay-files">
<h4>4.カーネル テスト システムのオーバーレイ ファイルの構築<a class="headerlink" href="#build-kernel-testing-system-overlay-files" title="Permalink to this heading">¶</a></h4>
<div class="section" id="for-a-hardware-target">
<h5>ハードウェア ターゲットの場合<a class="headerlink" href="#for-a-hardware-target" title="Permalink to this heading">¶</a></h5>
<p>ハードウェア ターゲットの場合は、次のコマンドを使用します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">build_hw</span></pre></div>
</div>
<p>これにより、まず 2 つの HLS カーネルが XO ファイルにコンパイルされ、システム オーバーレイ ファイル全体 (<code class="docutils literal notranslate"><span class="pre">~/krnl_aes/krnl_aes_test_hw.xclbin</span></code>) が構築されます。</p>
</div>
<div class="section" id="for-a-hardware-emulation-target">
<h5>ハードウェア エミュレーション ターゲットの場合<a class="headerlink" href="#for-a-hardware-emulation-target" title="Permalink to this heading">¶</a></h5>
<p>ハードウェア エミュレーション ターゲットの場合は、次のコマンドを使用します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">build_hw</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw_emu</span></pre></div>
</div>
<p>これにより、まず 2 つの HLS カーネルが XO ファイルにコンパイルされ、システム オーバーレイ ファイル全体 (<code class="docutils literal notranslate"><span class="pre">~/krnl_aes/krnl_aes_test_hw_emu.xclbin</span></code>) が構築されます。</p>
</div>
</div>
<div class="section" id="compile-host-program">
<h4>5.ホスト プログラムのコンパイル<a class="headerlink" href="#compile-host-program" title="Permalink to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">build_sw</span></pre></div>
</div>
<p>これで、ホスト C++ プログラムのコンパイルは終了です。<code class="docutils literal notranslate"><span class="pre">hw</span></code> と <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code> モジュールの両方に対して実行可能ファイル (<code class="docutils literal notranslate"><span class="pre">~/krnl_aes/host_krnl_aes_test</span></code>) が生成されます。</p>
<div class="section" id="finding-the-device-id-of-your-target-card">
<h5>ターゲット カードのデバイス ID の検出<a class="headerlink" href="#finding-the-device-id-of-your-target-card" title="Permalink to this heading">¶</a></h5>
<p>ホスト マシンに複数の Alveo カードがインストールされている場合は、<code class="docutils literal notranslate"><span class="pre">xbutil</span> <span class="pre">list</span></code> コマンドを使用してターゲット カードのデバイス ID を見つけます。次に例を示します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xbutil</span> <span class="nb">list</span>
<span class="o">...</span>
 <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="mi">0000</span><span class="p">:</span><span class="n">d8</span><span class="p">:</span><span class="mf">00.1</span> <span class="n">xilinx_u250_gen3x16_base_3</span> <span class="n">user</span><span class="p">(</span><span class="n">inst</span><span class="o">=</span><span class="mi">131</span><span class="p">)</span>
 <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="mi">0000</span><span class="p">:</span><span class="n">af</span><span class="p">:</span><span class="mf">00.1</span> <span class="n">xilinx_vck5000</span><span class="o">-</span><span class="n">es1_gen3x16_base_2</span> <span class="n">user</span><span class="p">(</span><span class="n">inst</span><span class="o">=</span><span class="mi">130</span><span class="p">)</span>
 <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="mi">0000</span><span class="p">:</span><span class="mi">5</span><span class="n">e</span><span class="p">:</span><span class="mf">00.1</span> <span class="n">xilinx_u50_gen3x16_xdma_201920_3</span> <span class="n">user</span><span class="p">(</span><span class="n">inst</span><span class="o">=</span><span class="mi">129</span><span class="p">)</span>
</pre></div>
</div>
<p>この例では、ターゲット カードが U50 の場合、デバイス ID は 2 です。<code class="docutils literal notranslate"><span class="pre">~/krnl_aes/host/host_krnl_aes_test.cpp</span></code> の 30 行目を次のように変更する必要があります。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span> 28 // Use &#39;xbutil list&#39; command to get the device id of the target Alveo card if multiple
 29 //   cards are installed in the system.
 30 #define DEVICE_ID   2
</pre></div>
</div>
</div>
</div>
<div class="section" id="run-hardware-emulation-optional">
<h4>6.ハードウェア エミュレーションの実行 (オプション)<a class="headerlink" href="#run-hardware-emulation-optional" title="Permalink to this heading">¶</a></h4>
<p>ハードウェア エミュレーション用の XCLBIN ファイル (<code class="docutils literal notranslate"><span class="pre">~/krnl_aes/krnl_aes_test_hw_emu.xclbin</span></code>) が生成されると、ハードウェア エミュレーションを実行して、プラットフォーム環境でカーネルを検証し、デバッグや詳細なプロファイリングを実行できます。次のコマンドを参照してください。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">source</span> setup_emu.sh -s on -p PLATFORM_NAME ./host_krnl_aes_test -w <span class="m">32</span></pre></div>
</div>
<p>最初のコマンドは、スクリプトを呼び出してエミュレーション設定ファイルを生成し、必要な環境変数を設定します。PLATFORM_NAME は、使用している Alveo プラットフォームです。このプラットフォームは xilinx_u200_xdma_201830_2 (デフォルト)、xilinx_u250_xdma_201830_2、xilinx_u280_xdma_201920_3 または xilinx_u50_gen3x16_xdma_201920_3 のいずれかになります。</p>
<p>2 つ目のコマンドは、hw_emu モードでホスト プログラムを実行します。オプションのコマンド ライン パラメータの -w 32 は、処理する 128 ビット ワードの数を設定します。プログラムのソース コードのデフォルトのワード数は 1048576 (100 万) で、ハードウェア エミュレーションには大きすぎます。これを小さい値に設定すると、エミュレーションの実行時間を短縮できます。</p>
<p><code class="docutils literal notranslate"><span class="pre">~/krnl_aes/xrt.ini</span></code> ファイルは、次のように XRT エミュレーション オプションを制御するために使用されます。2 行目の <code class="docutils literal notranslate"><span class="pre">exclusive_cu_context=true</span></code> は、下位レベルの <code class="docutils literal notranslate"><span class="pre">kernel.write_register()</span></code> 関数が使用される場合は必須です。6 行目の <code class="docutils literal notranslate"><span class="pre">user_pre_sim_script=/home/workspace/bottom_up_rtl_kernel/krnl_aes/xsim.tcl</span></code> は、XSim が使用するシミュレーション前 Tcl スクリプトへの絶対パスを設定することで、すべての信号の波形をダンプするように指定しています。</p>
<p><strong>注記:</strong> 実際のパスに合わせてパスを変更してください。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="mi">1</span> <span class="p">[</span><span class="n">Runtime</span><span class="p">]</span>
  <span class="mi">2</span> <span class="n">exclusive_cu_context</span><span class="o">=</span><span class="n">true</span>
  <span class="mi">3</span>
  <span class="mi">4</span> <span class="p">[</span><span class="n">Emulation</span><span class="p">]</span>
  <span class="mi">5</span> <span class="n">debug_mode</span><span class="o">=</span><span class="n">batch</span>
  <span class="mi">6</span> <span class="n">user_pre_sim_script</span><span class="o">=/</span><span class="n">home</span><span class="o">/</span><span class="n">workspace</span><span class="o">/</span><span class="n">bottom_up_rtl_kernel</span><span class="o">/</span><span class="n">krnl_aes</span><span class="o">/</span><span class="n">xsim</span><span class="o">.</span><span class="n">tcl</span>
  <span class="mi">7</span>
  <span class="mi">8</span> <span class="p">[</span><span class="n">Debug</span><span class="p">]</span>
  <span class="mi">9</span> <span class="n">profile</span><span class="o">=</span><span class="n">true</span>
 <span class="mi">10</span> <span class="n">timeline_trace</span><span class="o">=</span><span class="n">true</span>
 <span class="mi">11</span> <span class="n">data_transfer_trace</span><span class="o">=</span><span class="n">fine</span>
</pre></div>
</div>
<p>ハードウェア エミュレーションの実行が完了したら、Vivado で生成された <code class="docutils literal notranslate"><span class="pre">xilinx_xxx-0-krnl_aes_test_hw_emu.wdb</span></code> ファイルを開いて波形を解析できます。次の図は、<code class="docutils literal notranslate"><span class="pre">krnl_aes</span></code> の 8 つの AXI ストリーム ポートの動作の波形を示しています。</p>
<div align="center"><img src="./images/krnl_aes_waveform.png" alt="krnl_aes waveform" > </div><br/><p>次の図は、<code class="docutils literal notranslate"><span class="pre">ap_ctrl_hs</span></code> モードの AXI 制御スレーブの制御信号の動作を示しています。</p>
<div align="center"><img src="./images/ap_ctrl_hs_waveform.png" alt="ap_ctrl_hs waveform" > </div><br/></div>
<div class="section" id="run-host-program-in-hardware-mode">
<h4>7.ホスト プログラムのハードウェア モードでの実行<a class="headerlink" href="#run-host-program-in-hardware-mode" title="Permalink to this heading">¶</a></h4>
<p>前の手順でハードウェア エミュレーションを試した場合は、次のコマンドを実行して <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code> モードを無効にする必要があります。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">source</span> setup_emu.sh -s off</pre></div>
</div>
<p>これで、コンパイルされた <code class="docutils literal notranslate"><span class="pre">host_krnl_aes_test</span></code> ファイルを実行して、ハードウェア モードでシステムをテストできます。処理するデフォルトのワード数は 1M の 128 ビット ワードなので、16 MB です。PCIe を介したホストと FPGA 間のデータ転送効率のため、十分な入力データで処理スループットを最大化できます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">host_krnl_aes_test</span>

<span class="o">------------------------</span> <span class="n">krnl_aes</span> <span class="n">test</span> <span class="n">program</span> <span class="o">------------------------</span>
 <span class="mi">128</span><span class="o">-</span><span class="n">bit</span> <span class="n">words</span> <span class="n">number</span> <span class="p">:</span> <span class="mi">1048576</span>
           <span class="n">Key</span> <span class="n">length</span> <span class="p">:</span> <span class="mi">256</span><span class="o">-</span><span class="n">bit</span>
                  <span class="n">Key</span> <span class="p">:</span> <span class="mi">123456789</span><span class="n">ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0</span>

<span class="n">Generating</span> <span class="n">plain</span> <span class="n">data</span>
<span class="p">[</span><span class="n">MESSAGE</span><span class="p">]</span> <span class="n">Program</span> <span class="n">running</span> <span class="ow">in</span> <span class="n">hardware</span> <span class="n">mode</span>
<span class="n">Load</span> <span class="n">krnl_aes_test_hw</span><span class="o">.</span><span class="n">xclbin</span>
<span class="n">Create</span> <span class="n">kernels</span>
<span class="n">Create</span> <span class="nb">input</span> <span class="ow">and</span> <span class="n">output</span> <span class="n">device</span> <span class="n">buffers</span>
<span class="n">Run</span> <span class="n">krnl_aes</span> <span class="k">for</span> <span class="n">AES</span> <span class="n">key</span> <span class="n">expansion</span>
<span class="n">Kernel</span> <span class="n">run</span> <span class="n">finish</span>

<span class="o">--------------</span> <span class="n">AES</span> <span class="n">Encryption</span> <span class="n">Test</span>
<span class="n">Transfer</span> <span class="n">plain</span> <span class="n">data</span> <span class="n">into</span> <span class="n">device</span> <span class="n">buffer</span>
<span class="n">Start</span> <span class="n">strm_issue</span> <span class="ow">and</span> <span class="n">strm_dump</span> <span class="n">kernels</span>
<span class="n">Kernel</span> <span class="n">run</span> <span class="n">finish</span>
<span class="n">AES</span> <span class="n">engines</span> <span class="n">execution</span> <span class="n">time</span> <span class="o">=</span> <span class="mf">170.820007</span> <span class="n">ms</span>
<span class="n">Transfer</span> <span class="n">cipher</span> <span class="n">data</span> <span class="kn">from</span> <span class="nn">device</span> <span class="n">buffer</span> <span class="ow">and</span> <span class="n">verification</span>
<span class="o">--</span> <span class="n">AES</span> <span class="n">Engine</span> <span class="mi">0</span>
   <span class="n">SUCCESS</span>
<span class="o">--</span> <span class="n">AES</span> <span class="n">Engine</span> <span class="mi">1</span>
   <span class="n">SUCCESS</span>
<span class="o">--</span> <span class="n">AES</span> <span class="n">Engine</span> <span class="mi">2</span>
   <span class="n">SUCCESS</span>
<span class="o">--</span> <span class="n">AES</span> <span class="n">Engine</span> <span class="mi">3</span>
   <span class="n">SUCCESS</span>
<span class="n">AES</span> <span class="n">total</span> <span class="n">encryption</span> <span class="n">throughput</span> <span class="o">=</span> <span class="mf">392.857971</span> <span class="n">MB</span><span class="o">/</span><span class="n">s</span>

<span class="o">--------------</span> <span class="n">AES</span> <span class="n">Decryption</span> <span class="n">Test</span>
<span class="n">Transfer</span> <span class="n">cipher</span> <span class="n">data</span> <span class="n">into</span> <span class="n">device</span> <span class="n">buffer</span>
<span class="n">Start</span> <span class="n">strm_issue</span> <span class="ow">and</span> <span class="n">strm_dump</span> <span class="n">kernels</span>
<span class="n">Kernel</span> <span class="n">run</span> <span class="n">finish</span>
<span class="n">AES</span> <span class="n">engines</span> <span class="n">execution</span> <span class="n">time</span> <span class="o">=</span> <span class="mf">170.800995</span> <span class="n">ms</span>
<span class="n">Transfer</span> <span class="n">plain</span> <span class="n">data</span> <span class="kn">from</span> <span class="nn">device</span> <span class="n">buffer</span> <span class="ow">and</span> <span class="n">verification</span>
<span class="o">--</span> <span class="n">AES</span> <span class="n">Engine</span> <span class="mi">0</span>
   <span class="n">SUCCESS</span>
<span class="o">--</span> <span class="n">AES</span> <span class="n">Engine</span> <span class="mi">1</span>
   <span class="n">SUCCESS</span>
<span class="o">--</span> <span class="n">AES</span> <span class="n">Engine</span> <span class="mi">2</span>
   <span class="n">SUCCESS</span>
<span class="o">--</span> <span class="n">AES</span> <span class="n">Engine</span> <span class="mi">3</span>
   <span class="n">SUCCESS</span>
<span class="n">AES</span> <span class="n">total</span> <span class="n">decryption</span> <span class="n">throughput</span> <span class="o">=</span> <span class="mf">392.901703</span> <span class="n">MB</span><span class="o">/</span><span class="n">s</span>
</pre></div>
</div>
<hr class="docutils" />
<p>これで、Vitis の RTL カーネル ファイルの <code class="docutils literal notranslate"><span class="pre">krnl_aes.xo</span></code> と <code class="docutils literal notranslate"><span class="pre">ap_ctrl_hs</span></code> 実行モデルが作成されました。次のセッションでは、<code class="docutils literal notranslate"><span class="pre">ap_ctrl_chain</span></code> モデルをサポートするもう 1 つの RTL カーネル、<code class="docutils literal notranslate"><span class="pre">krnl_cbc</span></code> について学び、これら 2 つのカーネルをハードウェア オーバーレイ (XCLBIN) に統合して、完全な AES-CBC アクセラレーション アプリケーションを形成します。詳細は、次のセクションの<a class="reference internal" href="krnl_cbc.html"><span class="doc">「RTL カーネル： krnl_cbc」</span></a>で説明します。</p>
</div>
</div>
</div>
</div>


           </div>
          </div>
          
                  <style>.footer { position: fixed; left: 0; bottom: 0; width: 100%; }</style>
				  
				  <footer>

  <hr/>

  <div role="contentinfo">
    <p>© Copyright 2019-2022, Xilinx, Inc.. <span class="lastupdated">最終更新日 2022 年 5 月 16 日。内容に相違が生じる場合には原文を優先します。英語版の更新に対応していないことがありますので、日本語版は参考用としてご使用の上、最新情報につきましては、必ず<a href="https://github.com/Xilinx/Vitis-Tutorials">最新英語版</a>をご参照ください。</span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div> </br> Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>